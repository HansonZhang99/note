# 线程控制

sysconf函数:获取环境资源的限制

```cpp
#include <pthread.h>
int pthread_equal(pthread_t tid1, pthread_t tid2);
```

相等返回非0，否则返回0

```cpp
pthread_t pthread_self(void);
```

获取自己的线程ID

```cpp
int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void*(*func)(void *), void *args);
```

创建线程函数，成功返回0，失败返回错误编号
创建成功后，线程tid从tid返回，attr用于设置线程属性，func为线程工作函数，args为传入工作函数的参数

线程可访问进程地址空间，继承进程的信号屏蔽字，但是该线程的挂起信号集被清空
每个线程都提供errno副本

线程终止：
线程三种退出方式：
1.从启动例程中返回，返回值为线程退出码(return void*)
2.被同一进程的其他线程取消
3.线程调用pthread_exit

```cpp
void pthread_exit(void *ptr);
```

进程中的其他线程可以通过pthread_join函数访问ptr指针

```cpp
int pthread_join(pthread_t tid, void **ptr)
```

调用线程调用此函数会一直阻塞，直到指定线程调用pthread_exit,从启动例程返回或取消。

从启动例程返回，ptr包含返回码，被取消返回PTHREAD_CANCELED

```cpp
pthread_cancel(pthread_t tid);
```

用来取消同一进程的其他线程，会使得指定线程如同调用了参数为PTHREAD_CANCELED的pthread_exit函数

线程可安排退出时需要调用的函数，称为线程清理处理程序，一个线程可建立多个处理程序，执行顺序与注册顺序相反（栈）

```cpp
void pthread_cleanup_push(void *(*func)(void *),void *args);
void pthread_cleanup_pop(int excute);
```

线程执行以下动作，pthread_cleanup_push调用参数中的函数，args是传给函数的参数：
1.调用pthread_exit时
2.响应取消请求时
3.用非0的excute参数调用pthread_cleanup_pop时（以0调用时，也会删除上一次pthread_cleanup_push建立的清理程序

进程与线程的对比：

```shell
fork        pthread_create            创建新的控制流
exit        pthread_exit            退出现有控制流
waitpid        pthread_join            从控制流得到退出状态
atexit        pthread_cleanup_push    注册在退出控制流时调用的函数
getpid        pthread_self            获取控制流ID
abort        pthread_cancel            请求控制流的非正常退出
```

分离线程：

```cpp
int pthread_detach(pthread_t tid)
```

对分离线程调用pthread_join会产生未定义行为

线程同步：

互斥锁：

```cpp
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)//通常不关心互斥锁属性，设备attr为NULL
int pthread_mutex_destroy(pthread_mutex_t *mutex)

int pthread_mutex_lock(pthread_mutex_t *mutex)
int pthread_mutex_unlock(pthread_mutex_t *mutex)
int pthread_mutex_trylock(pthread_mutex_t *mutex)//拿到锁返回0，否则返回EBUSY
int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *tsptr)//阻塞等待指定时间的锁，成功获取返回0，否则返回ETIMEDOUT,2参为绝对时间，即未来的时间点
```

死锁：产生的四个条件：互斥条件：一个资源每次只能被一个进程使用。请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。不可剥夺条件: 进程已获得的资源，在末使用完之前，不能强行剥夺。循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。



读写锁：
三种状态：
读模式加锁，写模式加锁，不加锁。
一次只能有一个线程占有写模式的读写锁，但是可以有多个线程占有读模式的读写锁

写锁被加锁时，所有对此锁加锁的线程都被阻塞（读写都会）
读锁被加锁时，所有对此锁加读锁的线程都能得到锁，但是加写锁的线程会被阻塞直到加读锁的所有线程释放读锁
当读锁被加锁时，有线程对写锁加锁，通常此时再对此锁加读锁的线程会被阻塞，直到加读锁的所有线程释放读锁

操作接口：

```cpp
int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)//通常不关心读写锁属性，设备attr为NULL
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
//两个函数成功返回0，失败返回错误编号
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)//读加锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)//写加锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)//释放读/写锁
//三个函数成功返回0，失败返回错误编号
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)
//两个函数成功返回0，失败返回EBUSY
//带有超时的读写锁：
int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock, const struct timespec *tsptr)
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *tsptr)
//成功返回0，失败返回ETIMEDOUT

```

条件变量：
给多线程提供回合的场所，条件变量与互斥量一次使用，允许线程以无竞争的方式的等待特定条件的发生

```cpp
//初始化和销毁：
int pthread_cond_init(pthread_cond_t *cond, const pthreadattr_t *attr)//通常不关心条件变量属性，设备attr为NULL
int pthread_cond_destroy(pthread_cond_t *cond)
//两个函数成功返回0失败返回错误编号
//等待条件变量：
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
int pthread_cond_timedwait(pthread_cond_t *cond, pthrad_mutex_t *mutex, const struct timespec *tsptr)
```

成功返回0，失败返回错误编号
传递给pthread_cond_wait的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数自动把调用线程放在等待条件的线程列表上，对互斥量解锁。
这就关闭了条件检查和线程进入休眠状态等待条件改变两个操作间的时间通道，这样线程就不会错过条件的任何变化。pthread_cond_wait返回时，互斥量再次被锁住
pthread_cond_timedwait类似互斥锁和读写锁。当超时时间到达后条件还没出现，会重新获取互斥量并返回ETIMEDOUT。

通知线程条件已经满足:

```cpp
int pthread_cond_signal(pthread_cond_t *cond)
int pthread_cond_broadcast(pthread_cond_t *cond)
```

成功返回0，失败返回错误编号
前者至少能唤醒一个等待该条件的线程，后者唤醒所有等待该条件的线程。

条件变量用法：

```cpp
void process_msg(void)
{
    //...
    //
    for( ; ; )
    {
        pthread_mutex_lock(&qlock);//上锁
        while(workq == NULL)//使用while而不是if，是因为pthread_cond_signal存在多个唤醒和误唤醒，因此在pthread_cond_wait返回后需要先检查一下临界资源是否准备好，如果没有则再次进入睡眠
            pthread_cond_wait(&cond, &qlcok);//睡眠前解锁进入睡眠，被唤醒后上锁。如果唤醒后线程没有释放互斥锁，依然会等待锁，拿到锁后才会返回。
        //deal
        pthread_mutex_unlock(&qlock);//解锁
    }
}

void queue_msg(struct msg* pmsg)
{
    pthread_mutx_lock(&qlock);
    //deal
    pthread_mutex_unlock(&qlock);//先解锁再唤醒条件
    pthread_cond_signal(&cond);//唤醒条件
}
```

自旋锁...

线程屏障：屏障允许任意数量的线程等待，知道所有合作线程都达到某一点，，然后所有线程解除阻塞从该点继续执行。
pthread_join就是一种屏障，一个线程等待另一个线程的退出。

函数：

```cpp
int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrieratrr_t *attr, unsigned int count)//通常不关心屏障属性，设备attr为NULL，count设置为需要等待线程的个数
int pthread_barrier_destroy(pthread_barrier_t *barrier)
//成功返回0，错误返回错误编号

int pthread_barrier_wait(pthread_barrier_t *barrier)
//调用此函数的线程的屏障计数没有达到初始化设置的值时，会进入睡眠。如果该线程是最后一个调用pthread_barrier_wait的线程满足屏障计数，所有线程都会被唤醒。
//所有线程在pthread_barrier_wait返回后，可获取返回值，其中返回值为PTHREAD_BARRIER_SERIAL_THREAD的为主线程，其他线程将看到返回值为0
//调用错误返回错误编号。
```

达到屏障计数后，解除阻塞后，屏障可被重用。除非调用destroy后调用init重新初始化计数，否则计数保持不变。

线程属性：
使用sysconf可获取线程一些限制：如进程可以创建的最大进程数。

线程自有属性设置：

```cpp
int pthread_attr_init(pthread_attr_t *attr)//attr中有参数为动态分配，因此需要调用destroy释放
int pthread_atr_destroy(pthread_attr_t *attr)
//成功返回0，失败返回错误编号
```

设置线程分离属性的函数：

1.直接调用pthread_detach告诉操作系统退出时回收线程资源
2.初始化阶段使用ptread_attr_setdetachstate函数设置线程为分离状态：

```cpp
int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate)//获取当前attr中的detachstate到detachstate
int pthread_attr_setdetachstate(pthread_attr_t *attr, int *detachstate)//设置detachstate到attr
//成功返回0，失败返回错误码
//deatchstate取值为：
//PTHREAD_CREATE_DETACHED分离状态启动线程
//PTHREAD_CREATE_JOINABLE会合状态启动线程，应用程序可获取线程终止状态
```

