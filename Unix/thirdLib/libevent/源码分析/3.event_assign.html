<html>
<head>
  <title>3.event_assign</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="930"/>
<h1>3.event_assign</h1>

<div>
<span><div>信号或套接字都可以作为一个event的监听对象，并且一个信号或套接字可同时加入到多个event。</div><div><span style="font-weight: bold;">结构体struct event_base</span></div><div><br/></div><div><span style="font-weight: bold;">结构体struct event：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event {</div><div>    <font color="#FF0000">struct event_callback ev_evcallback;</font></div><div><br/></div><div>    /* for managing timeouts */</div><div>    union {</div><div>        TAILQ_ENTRY(event) ev_next_with_common_timeout;</div><div>        size_t min_heap_idx;</div><div>    } ev_timeout_pos;//管理定时器事件</div><div>  <font color="#FF0000">  evutil_socket_t ev_fd;//监听对象套接字或信号</font></div><div><br/></div><div>    <font color="#FF0000">struct event_base *ev_base;//所属event_base</font></div><div><br/></div><div>    union {13</div><div>        /* used for io events */</div><div>        struct {</div><div>            LIST_ENTRY (event) ev_io_next;</div><div>            struct timeval ev_timeout;</div><div>        } ev_io;//套接字对象</div><div><br/></div><div><br/></div><div>        /* used by signal events */</div><div>        struct {</div><div>            LIST_ENTRY (event) ev_signal_next;</div><div>            short ev_ncalls;</div><div>            /* Allows deletes in callback */</div><div>            short *ev_pncalls;</div><div>        } ev_signal;//信号对象</div><div>    } ev_;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">short ev_events;//监听事件类型EV_READ...</font></div><div>    <font color="#FF0000">short ev_res;  //激活事件类型     /* result passed to event callback */</font></div><div>    <font color="#FF0000">struct timeval ev_timeout;//定时器超时值</font></div><div>};</div><div><br/></div><div>struct event_callback {</div><div>   <font color="#FF0000"> TAILQ_ENTRY(event_callback) evcb_active_next;//激活队列</font></div><div>    short evcb_flags;</div><div>   <font color="#FF0000"> ev_uint8_t evcb_pri;//event的优先级    /* smaller numbers are higher priority */</font></div><div>    ev_uint8_t evcb_closure;</div><div>    /* allows us to adopt for different types of events */</div><div>      <font color="#FF0000">  union {</font></div><div><font color="#FF0000">        void (*evcb_callback)(evutil_socket_t, short, void *);</font></div><div><font color="#FF0000">        void (*evcb_selfcb)(struct event_callback *, void *);</font></div><div><font color="#FF0000">        void (*evcb_evfinalize)(struct event *, void *);</font></div><div><font color="#FF0000">        void (*evcb_cbfinalize)(struct event_callback *, void *);</font></div><div><font color="#FF0000">    } evcb_cb_union;//回调函数</font></div><div>    <font color="#FF0000">void *evcb_arg;//回调函数参数</font></div><div>};</div></div><div><br/></div><div><span style="font-weight: bold;">创建event</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event *</div><div>event_new(struct event_base *base, evutil_socket_t fd, short events, void (*             </div><div>cb)(evutil_socket_t, short, void *), void *arg)</div><div>{</div><div>    struct event *ev;</div><div>   <font color="#FF0000"> ev = mm_malloc(sizeof(struct event));</font></div><div>    if (ev == NULL)</div><div>        return (NULL);</div><div>    <font color="#FF0000">if (event_assign(ev, base, fd, events, cb, arg) &lt; 0) {</font></div><div><font color="#FF0000">        mm_free(ev);</font></div><div>        return (NULL);</div><div>    }</div><div><br/></div><div><br/></div><div>    return (ev);</div><div>}</div><div><br/></div><div>int</div><div>event_assign(struct event *ev, struct event_base *base, evutil_socket_t fd, short</div><div>events, void (*callback)(evutil_socket_t, short, void *), void *arg)</div><div>{</div><div>    if (!base)</div><div>        <font color="#FF0000">base = current_base;//current_base为全局指针，被初始化为NULL</font></div><div>    if <font style="color: rgb(255, 0, 0);">(arg == &amp;event_self_cbarg_ptr_)</font><font color="#FF0000"><font>//</font>event_self_cbarg_ptr_为全局指针，初始化为NULL</font></div><div>        arg = ev;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if (!(events &amp; EV_SIGNAL))</font></div><div><font color="#FF0000">        event_debug_assert_socket_nonblocking_(fd);//如果event不是信号，判断套接字是否为非阻塞</font></div><div>   <font style="color: rgb(255, 0, 0);"> event_debug_assert_not_added_(ev);//判断此event是否是没有被&quot;add&quot;</font></div><div><br/></div><div><br/></div><div>    ev-&gt;ev_base = base;</div><div><br/></div><div><br/></div><div>    ev-&gt;ev_callback = callback;</div><div>    ev-&gt;ev_arg = arg;</div><div>    ev-&gt;ev_fd = fd;</div><div>    ev-&gt;ev_events = events;</div><div>    ev-&gt;ev_res = 0;</div><div>   <font color="#FF0000"> ev-&gt;ev_flags = EVLIST_INIT;</font></div><div>    ev-&gt;ev_ncalls = 0;</div><div>    ev-&gt;ev_pncalls = NULL;</div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> if (events &amp; EV_SIGNAL) {</font></div><div><font color="#FF0000">        if ((events &amp; (EV_READ|EV_WRITE|EV_CLOSED)) != 0) {</font></div><div><font color="#FF0000">            event_warnx(&quot;%s: EV_SIGNAL is not compatible with &quot;</font></div><div><font color="#FF0000">                &quot;EV_READ, EV_WRITE or EV_CLOSED&quot;, __func__);</font></div><div><font color="#FF0000">            return -1;</font></div><div><font color="#FF0000">        }</font></div><div><font style="color: rgb(255, 0, 0);">        ev-&gt;ev_closure = EV_CLOSURE_EVENT_SIGNAL;//如果event标志是信号，则判断是否还有EV_READ等标志，有就会出错，最后初始化ev_closure。</font></div><div>    <font color="#FF0000">} else {</font></div><div><font color="#FF0000">        if (events &amp; EV_PERSIST) {</font></div><div><font color="#FF0000">            evutil_timerclear(&amp;ev-&gt;ev_io_timeout);</font></div><div><font color="#FF0000">            ev-&gt;ev_closure = EV_CLOSURE_EVENT_PERSIST;</font></div><div><font color="#FF0000">       } else {</font></div><div><font color="#FF0000">            ev-&gt;ev_closure = EV_CLOSURE_EVENT;</font></div><div><font color="#FF0000">        }</font></div><div><font color="#FF0000">    }//如果event为套接字（文件描述符）标志，则判断event是否设置EV_PERSIST标志，并设置ev_closure为对应宏</font></div><div><br/></div><div><br/></div><div>    min_heap_elem_init_(ev);</div><div><br/></div><div><br/></div><div>    if (base != NULL) {</div><div>        /* by default, we put new events into the middle priority */</div><div>       <font color="#FF0000"> ev-&gt;ev_pri = base-&gt;nactivequeues / 2;//初始优先级</font></div><div>    }</div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> event_debug_note_setup_(ev);//加入event到全局队列global_debug_map</font></div><div><br/></div><div><br/></div><div>    return 0;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">event_assign初始化中，会将ev_flag初始化为EVLIST_INIT。</span></div><div><br/></div><div><span style="font-weight: bold;">event2/event_struct.h</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define EVLIST_TIMEOUT      0x01//event从属于定时器队列或者时间堆</div><div>#define EVLIST_INSERTED     0x02//event从属于注册队列</div><div>#define EVLIST_SIGNAL       0x04//没有使用</div><div>#define EVLIST_ACTIVE       0x08//event从属于活动队列</div><div>#define EVLIST_INTERNAL     0x10//该event是内部使用的。信号处理时有用到</div><div>#define EVLIST_ACTIVE_LATER 0x20</div><div>#define EVLIST_FINALIZING   0x40</div><div>#define EVLIST_INIT     0x80//event已经被初始化了</div><div>    </div><div>#define EVLIST_ALL          0xff//所有标志。这个不能取</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 