# 继承
## 公有继承
```cpp
//基类
class fruit
{
    private:
       double price;
       int num;
    public:
        fruit(double p = 0,int n = 0): price(p), num(n) {}
        //fruit() = default;
        ~fruit() = default;
        double get_price() const
        {
            return price;
        }
        int get_num() const
        {
            return num;
        }
        ...
}  
class banana : public fruit
{
    private:
        double price_precent;
    public:
        banana(double pp = 1.0, double p = 0, int n = 0) : fruit(p,n), rice_precent(pp) {}
        ~banana() = default;//与初始化方向相反，调用派生类析构函数，再调用基类析构函数
}
```
公有继承的派生类可以访问基类的公有和保护数据成员和方法。
派生类需要有自己的构造函数，派生类构造函数需要初始化基类对象（调用基类的一个构造函数），且必须使用成员初始化列表进行初始化。
派生类初始化的构造函数中不调用基类构造函数，会使用基类的默认构造函数。如果派生类初始化基类对象时调用了基类的拷贝构造函数，但是基类没有定义拷贝构造函数，则使用基类默认拷贝构造函数（浅赋值）。
### 派生类与基类的关系
派生类可以直接访问基类的共有方法和数据成员：
```cpp
class basic
{
    ...
    public:
        int get(void);
    ...
}
class derived : public basic
{
    ...
}
derived dr;
dr.get();
```
基类指针/引用可以在不进行显示转换的条件下指向派生类对象，调用基类方法，但是不能调用派生类方法。
```cpp
basic *bp;
derived dr;
bp = dr;
basic &br = dr;
bp->get();
br.get();
```
不能将派生类指针/引用指向基类对象
```cpp
void show(const basic& dr);
void show(const basic *dr);
basic bs;
derived dr;
show(bs);//show(&bs);
show(dr);//show(&br);
//构造函数同样适用
//derived有构造函数：
basic(const basic & bs);
//现在调用
basic bss(dr);
//但是没有basic(const derived & dr);
//将会调用隐式拷贝构造将派生类的基类部分初始化给bss
basic(const basic &dr);

basic bs;
derived dr;
bs = dr;//使用隐式赋值运算符basic operator=(const basic & bs) const
//dr的基类部分赋值给bs
```

### 多态公有继承
实现同一种方法因上下文不同而异
两种方法：
1.在派生类中重新定义基类方法
2.使用虚方法
```cpp
#include <iostream>
using namespace std;
class fruit
{
    private:
        int sum;
    public:
        fruit(int s = 0): sum(s) {}
        virtual ~fruit()
        {
            cout << "fruit's delete constructor called\n";
        };
        int getSum(void) const
        {
            return sum;
        }
        int addSum(int num)
        {
            sum += num;
        }
        int deleteSum(int num)
        {
            sum = sum - num < 0 ? 0 : sum;
        }
        virtual void show(void) const
        {
            cout << "fruit's num is " << sum << endl;
        }
        void what(void)
        {
            cout << "this is fruit class\n";
        }
};

class banana : public fruit
{
    private:
        double price;
    public:
        banana(double p = 3.5, int s = 0) : fruit(s), price(p) {}
        banana(const fruit& f, double p = 2.434):fruit(f),price(p) {}
        virtual ~banana()
        {
            cout << "banana's delete constructor called\n";
        }
        virtual void show(void) const
        {
            cout << "all banana's price is " << price * getSum() << endl;
        }
        void what(void)
        {
            cout << "this is banana class\n";
        }
};


int main()
{
    fruit f1 = 99;
    banana b1(3.423, 100);
    banana b2(f1);
    fruit f2;
    f2 = b2;
    f1.show();
    f2.show();
    b1.show();
    b2.show();
    fruit *fp;
    fp = &f1;//fruit &fp = f1;
    fp->show();//fp.show();
    fp->what();
    fp = &b1;
    fp->show();
    fp->fruit::show();//call basic class's what method
    b1.fruit::show();//call basic class's what method
    fp->what();
    
}
```
基类fruit和派生类banana包含同名函数show和what，其中show为虚方法。
虚方法和普通方法一样可以直接使用对象调用。
区别在当使用基类指针或引用调用虚方法show时，会调用指针指向对象的对应的show方法。
即在实例中，基类指针指向基类和派生类对象时，会分别调用指向的对象的同名方法show。
而对what方法，基类指针无论是指向基类还是派生类对象，调用的都是基类的what方法。
要在派生类中重新定义基类的方法，通常会在基类中将此方法声明为虚的，在派生类中也习惯加上virtual来指出此函数为基类定义的虚函数。

同时，在派生类中定义来自基类的虚函数时，如果在函数中要调用基类的同名虚函数，需要在函数前加上作用域解析运算符，如`banana`中的`what`方法如果要调用基类的`what`方法，则需要如下方式调用：
```cpp
void banana::what(void) const
{
    fruit::what();//如不加入fruit::,编译器会认为函数是一个派生类对象的函数递归调用
    cout << ....
}
```

虚析构函数：
虚方法的存在可以实现同时对基类对象和派生类对象的管理，因为基类指针可以指向派生类对象，而虚方法可以让基类指针正确调用派生类对象与基类对象的同名方法。
可以定义一个基类指针数组管理基类和派生类对象，使用new为每个对象分配内存。
```cpp
fruit *arr[100];
arr[0] = new fruit();
arr[1] = new banana();
...
//delete constructor???
```
然而在释放对象内存时，如果析构函数不是虚的，则基类指针只会调用基类的析构函数而不会调用派生类的析构函数导致内存泄漏。而虚析构函数能正确的调用指针指向对象类型的析构函数，如果指向派生类，会依次调用派生类和基类的析构函数完成内存释放。

### 动态和静态联编
将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。
C++在编译阶段完成重载函数的联编确定程序中使用的重载函数，称为静态联编（早期联编）。
由于继承中虚函数的出现，使用哪一个函数不能在编译阶段确定，需要在程序运行阶段再确定。称为动态联编（晚期联编）。

向上强制转换：将派生类引用或指针转换为基类引用或指针。可以直接转换
向下强制转换：将基类引用或指针转换为派生类引用或指针。需要强制转换

静态联编：能在编译阶段处理就在编译阶段处理，尽量不在运行阶段增加消耗。

虚函数工作原理：
编译器在编译为每个对象添加一个隐藏成员，隐藏成员包含一个指向函数指针数组的指针。数组称为虚函数表。
数组中存储了为类对象进行声明的虚函数的地址。
示例：
```cpp
class Scientist
{
    char name[40];
public:
    virtual void show_name();
    virtual void show_all();
}
class Physicist : public Scientist
{
    char field[40];
public:
    virtual void show_all();
    virtual void show_field();
}
```
Scientist的虚函数表：

| 表地址                         | 2008 |
| ------------------------------ | ---- |
| `Scientist::show_name()的地址` | 4064 |
| `Scientist::show_all()的地址`  | 6400 |

Physicist的虚函数表：

| 表地址                        | 2096 |
| ----------------------------- | ---- |
| `Physicist::show_name()地址`  | 4064 |
| `Physicist::show_all地址`     | 6820 |
| `Physicist::show_field()地址` | 7280 |

虚函数表中包含当前类对象所有虚函数的函数首地址。
派生类如果没有重新定义基类的虚函数，则派生类对象的虚函数表中的对应指针指向基类的函数地址。
派生类如果重新定义了基类的虚函数，则派生类对象的虚函数表中对应指针指向派生类的函数地址。
使用指针调用虚函数时：
```cpp
Physicist psc;
Scientist *st;
st = &psc;
psc->show_all();
//首先找到指向的对象的虚函数表首地址2096 ,psc->vptr
//获取表中调用函数的首地址6820，执行此函数。
```

#### 关于虚函数
1.构造函数不能是虚函数。
2.应当为类提供一个虚析构函数。当使用new为对象分配内存时，需要主动调用delete才能进而调用类的析构函数释放类中分配的自由存储区内存。当析构函数不为虚函数时，调用delete只会释放指针所指对象的指针类型部分的内存。如果派生类中有使用new内存且必须使用派生内析构函数才能释放，由于派生类析构函数不会被调用，导致内存泄漏。
3.友元函数不能是虚函数，友元函数不是类成员，虚函数必须是类成员。
4.派生类没有重新定制虚函数，将使用基类版本。如果派生类处于派生链中，将使用当前派生类链下最新的虚函数版本。
5.派生类重新定义基类方法，将隐藏--所有--同名基类方法。
```cpp
#include <iostream>
using namespace std;

class b
{
    public:
        virtual void show() const
        {
            cout << "basic show\n";
        }
        void show(int a) const
        {
            cout << "basic int show\n";
        }
        void show(double b) const
        {
            cout << "basic double show\n";
        }
};
class c : public b
{
    public:
        virtual void show(const char *) const
        {
            cout << "derived show\n";
        }
};

int main()
{
    c a;
    a.show("hello");
    a.show(1);//invalid
}
[Wed Sep 29 11:25:01~/test/cpp_learn/hire]$ g++ test2.cpp
test2.cpp: In function ‘int main()’:
test2.cpp:33:10: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]
  a.show(1);
          ^
test2.cpp:23:16: note:   initializing argument 1 of ‘virtual void c::show(const char*) const’
   virtual void show(const char *) const
                ^~~~
```
c重新定义b的方法，会使b中所有此方法的重载版本失效。可以在派生类重新定义所有重载版本来解决。
但是如果基类方法返回类型是基类引用或指针，派生类可以修改为返回派生类的引用和指针--返回类型协变。

### 抽象基类
在类的声明中包含纯虚函数，会使得此类变为抽象基类，不能直接使用此类定义对象，只能通过继承使用此类。
纯虚函数可以在抽象基类中不进行定义。
```cpp
class pure_basic//virtual base class
{
    public:
        virtual void show() const = 0;//abstract virtual func
}

```

### 继承与动态内存分配
###### 基类使用了new而派生类没有使用new
派生类在进行对象复制和赋值运算时，使用派生类的默认复制构造和赋值运算，这样会默认调用基类的复制构造和赋值运算，这样是合适的。派生类默认析构函数也会调用基类析构函数释放内存，不会导致浅复制指针和内存泄漏。
###### 派生类使用new
必须为派生类定义显示的拷贝构造，赋值运算和析构函数
首先派生类析构函数必须释放派生类构造函数所分配的内存
派生类拷贝构造函数需要使用成员初始化列表调用基类拷贝构造函数
派生类赋值运算符需要调用基类赋值运算符

```cpp
#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;
class base_string
{
    char *str;
    int length;
    public:
    base_string() : str(NULL) , length(0)
    {
        cout << "base_string()\n";
    }
    base_string(const char *st)
    {
        cout << "base_string(const char*)\n";
        length = strlen(st);
        str = new char[length + 1];
        memcpy(str, st, length);
    }
    base_string(const base_string & st)
    {
        cout << "base_string(const base_string&)\n";
        length = st.length;
        str = new char[length + 1];
        memcpy(str, st.str, length);
    }
    base_string& operator=(const base_string & st)
    {
        cout << "base_string opeator=\n";
        if(this == &st)
            return *this;
        delete[] str;
        length = st.length;
        str = new char[length + 1];
        memcpy(str, st.str, length);
        return *this;
    }
    void show() const
    {
        cout << str << endl;
    }
    ~base_string()
    {
        cout << "base_string delete\n";
        delete [] str;
    }
};
class sstring : public base_string
{
    char *sstr;
    int llength;
    public:
    sstring() : base_string() ,sstr(NULL), llength(0)
    {
        cout << "sstring()\n";
    }
    sstring(const char *st1, const char *st2) : base_string(st1)
    {
        cout << "sstring(const char *)\n";
        llength =strlen(st2);
        sstr = new char[llength + 1];
        memcpy(sstr, st2, llength);
    }
    sstring(const sstring& sst) : base_string(sst)
    {
        cout << "sstring(const sstring &)\n";
        llength = sst.llength;
        sstr = new char[llength + 1];
        memcpy(sstr, sst.sstr, llength);
    }
    sstring & operator=(const sstring& sst)
    {
        cout << "sstring opeator=\n";
        if(this == &sst)
            return *this;
        base_string::operator=(sst);
        delete[] sstr;
        llength = sst.llength;
        sstr = new char[llength + 1];
        memcpy(sstr, sst.sstr, llength);
    }
    void show() const
    {
        base_string::show();
        cout << sstr << endl;
    }
    ~sstring()
    {
        cout << "sstring delete\n";
        delete [] sstr;
    }
};

int main()
{
    sstring s("hello","world");
    sstring a;
    a = s;
    sstring c(a);
    s.show();
    a.show();
    c.show();
}
[Wed Sep 29 16:45:02~]$ ./a.out
base_string(const char*)
sstring(const char *)
base_string()
sstring()
sstring opeator=
base_string opeator=
base_string(const base_string&)
sstring(const sstring &)
hello
world
hello
world
hello
world
sstring delete
base_string delete
sstring delete
base_string delete
sstring delete
base_string delete
```

类包含类对象成员：将类对象成员想象成string类对象就行...


## 私有继承
使用私有继承，基类公有和保护成员，都将成为派生类的私有成员，基类方法将不能使用派生对象直接调用，只能在派生类成员函数中使用。
```cpp
class Student : private string, private vector<int>
{
    ...
};
class String
{
    string str;
    vector<int> vt;
};
```
初始化基类组件：使用类名初始化派生类中私有基类对象
```cpp
Student(const char *s, const size_t val, const size_t n) : std::string(s), std::vector<int>(n ,val) {}
```

访问基类方法：
基类类名::基类方法

访问基类对象：
```cpp
const string& getString(void) const
{
    return (const string&)*this;
}
```
访问基类友元函数：
```cpp
ostream & operator<<(ostream &os, const Student& st)
{
    os << "...." << (const string&) st<< endl;//调用string类的operator << 友元
}
```
私有继承中派生类指针到基类指针的转换必须显式指出
同时如果多重继承，即使派生类指针能隐式转化为基类指针，也会出现转换为哪一个基类指针从而导致的二义性。

私有继承和包含建立has-a的关系：
包含可以包含多个同类的对象，而私有继承只能继承一个同名对象，使用包含访问基类比私有继承更方便。
私有继承可以访问基类的保护成员，但是包含不可以。私有继承可以重新定义基类虚函数。

## 保护继承
使用保护继承，基类接口在派生类中是可用的，基类的公有和保护成员都将成为派生类的保护成员。
```cpp
class Student : protected std::string, protected std::vector<int>
{
    ...
};
```
使用私有继承时，第三代派生类将不能访问一代基类的接口，因为二代继承时一代基类已经成为二代基类的私有成员。
使用保护继承时，第三代派生类可以访问一代基类的保护和公有接口，因为二代继承时一代基类成为二代基类的保护成员。

|                  |                      |                      |                      |
| ---------------- | -------------------- | -------------------- | -------------------- |
| 特征             | 公有继承             | 保护继承             | 私有继承             |
| 公有成员         | 公有                 | 保护                 | 私有                 |
| 保护成员         | 保护                 | 保护                 | 私有                 |
| 私有成员         | 只能通过基类接口访问 | 只能通过基类接口访问 | 只能通过基类接口访问 |
| 能否隐式向上转换 | 是                   | 是（但只能在派生类） | 否                   |

使用using使派生类中基类的方法可在外面使用
```cpp
class Student : private std::string, private std::vector<int>
{
    public:
        using std::vector<int>::length;
        using std::vector<int>::resize;
        using std::vector<int>::operator[];//没有圆括号，函数特征标和返回类型
};
Student s;
...
cout << "..." << s.length() << endl;
```


## 多重继承
上面私有继承已经使用了多重继承。
现在有基类worker，派生类singer和waiter派生自此基类。基类和派生类都有各自的show和set成员函数，worker中的为虚函数。
因此可以使用基类指针指向派生类，调用派生类同名方法：
```cpp
worker * p;
singer s;
waiter w;
p = &s;
s->show();
s->set();
s->worker::show();
p = &w;
p->show();
p->set();
p->worker::show();
```
singerwaiter类公有多重继承自singer和waiter类。
`class singerwaiter : public singer, public waiter`
此时singerwaiter从两个继承了了两个worker对象。以下调用会出错
```cpp
singerwaiter sw;
worker *p = &sw//指向哪一个基类的worker
```
可以通过强制转换解决：
```cpp
worker *p = (singer *)&sw;
worker *p = (waiter *)&sw;
```

大部分情况下并不需要两个worker,C++在引入多重继承时，引入了虚基类。
```cpp
class singer : virtual public worker
class waiter : public virtual worker
```
然后：
`class singerwaiter : public singer, public waiter`
此时singerwaiter将只包含一个worker。
这样将不能如下构造对象：
```cpp
singerwaiter(const worker &wk, int p = 0, int v = singer::other) : waiter(wk, p), singer(wk, v) {}
```
因为只有一个worker，而singer和waiter都相对其基类worker进行构造。为了避免冲突，c++在基类是虚的时，禁止信息通过中间类传递给基类。上述将使用worker的默认构造函数。
需要使用如下构造函数构造worker对象：
```cpp
singerwaiter(const worker &wk, int p = 0, int v = singer::other) : worker(wk), waiter(wk, p), singer(wk, v) {}
```
对于虚基类，必须这样做。这将调用worker的`worker(const worker&)`
调用基类同名函数：
```cpp
singerwaiter.singer::show();
singerwaiter.waiter::show();
singerwaiter.worker::show();//worker public虚基类继承
//or
singerwaiter sw;
singerwaiter *psw = &sw;
psw->singer::show();
psw->waiter::show();
psw->worker::show();
```

eg:
```cpp
#include <iostream>
#include <string>

using namespace std;

class  worker
{
    string name;
public:
    worker(const char *str = "null") : name(str)
    {
        cout << "worker constructor\n";
    }
    virtual ~worker() = 0;
    virtual void show() const
    {
        cout << "worker's name " << name <<endl;
    }
    virtual void length() const
    {
        cout << "worker's name length " << name.length() << endl;
    }
};
worker::~worker()
{
    cout << "worker deleted\n";
}

class singer : virtual public worker
{
    string singername;
public:
    singer(const char *str = "null", const char *sstr = "null") : worker(str), singername(sstr)
    {
        cout << "singer constructor\n";
    }

    virtual ~singer ()
    {
        cout << "singer deleted\n";
    }
    virtual void show() const
    {
        worker::show();
        cout << "singer's name " << singername << endl;
    }
    virtual void length() const
    {
        worker::length();
        cout << "singer's name length "<< singername.length() << endl;
    }
};

class waiter : virtual public worker
{
    string waitername;
    public:
    waiter(const char *str = "null", const char *sstr = "null") : worker(str), waitername(sstr)
    {
        cout << "waiter constructor\n";
    }
    virtual ~waiter()
    {
        cout << "waiter deleted\n";
    }
    virtual void show() const
    {
        worker::show();
        cout << "waiter's name " << waitername << endl;
    }
    virtual void length() const
    {
        worker::length();
        cout << "waiter's name length " << waitername.length() << endl;
    }
};

class singerwaiter : public singer, public waiter
{
    string swname;
    public:
    singerwaiter(const char *w = "null",const char *s = "null", const char *wt = "null",const char *sw = "null") : worker(w), singer(w, s), waiter(w, wt), swname(sw)
    {
        cout << "singerwaiter constructor\n";
    }
    virtual ~singerwaiter()
    {
        cout << "singerwaiter deleted\n";
    }
    void show() const
    {
        singer::show();
        waiter::show();
        cout << "singerwaiter's name " << swname << endl;
    }
    void length() const
    {
        singer::length();
        waiter::length();
        cout << "singerwaiter's name length " << swname.length() << endl;
    }
};

int main()
{
    singerwaiter sw("worker", "singer", "waiter", "singerwaiter");
    sw.show();
    sw.length();
    singerwaiter *psw = &sw;
    psw->show();
    psw->length();
    psw->waiter::show();
    psw->singer::show();
    psw->worker::show();
    singer *sp = &sw;
    sp->show();
    sp->length();
}
```
```
[Thu Sep 30 15:01:50~/test/cpp_learn/hire]$ ./a.out
worker constructor
singer constructor
waiter constructor
singerwaiter constructor
worker's name worker
singer's name singer
worker's name worker
waiter's name waiter
singerwaiter's name singerwaiter
worker's name length 6
singer's name length 6
worker's name length 6
waiter's name length 6
singerwaiter's name length 12
worker's name worker
singer's name singer
worker's name worker
waiter's name waiter
singerwaiter's name singerwaiter
worker's name length 6
singer's name length 6
worker's name length 6
waiter's name length 6
singerwaiter's name length 12
worker's name worker
waiter's name waiter
worker's name worker
singer's name singer
worker's name worker
worker's name worker
singer's name singer
worker's name worker
waiter's name waiter
singerwaiter's name singerwaiter
worker's name length 6
singer's name length 6
worker's name length 6
waiter's name length 6
singerwaiter's name length 12
singerwaiter deleted
waiter deleted
singer deleted
worker deleted
```