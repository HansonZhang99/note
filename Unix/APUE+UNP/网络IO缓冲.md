# 网络IO缓冲

### 关于Linux网络内核缓冲区
Linux内核为每个套接字分配了一定字节数的接收缓冲区和发送缓冲区，可使用setsockopt和getsockopt来设置和获取两缓冲区的大小。
```cpp
int ret;
int len;
int optlen = sizeof(int);
ret = getsockopt(socket,SOL_SOCKET,SO_SNDBUF,&len,&optlen);//获取发送缓冲区大小
ret = setsockopt(socket,SOL_SOCKET,SO_SNDBUF, (char *)&snd_size, optlen);//设置发送缓冲区大小
//服务器端对监听套接字设置即可，连接套接字会自动继承监听套接字的缓冲区大小
ret = getsockopt(socket,SOL_SOCKET,SO_RCVBUF,&len,&optlen);//获取接收缓冲区大小
ret = setsockopt(socket,SOL_SOCKET,SO_RCVBUF, (char *)&snd_size, optlen);//设置接收缓冲区大小
```
Linux内核规定了内核两缓冲区的最大值和最小值，设置不在两值之间系统会自动选择两值，可在setsockopt使用getsockopt查看设置是否成功。

**getsockopt会返回set的缓冲区的两倍。虽然设置的缓冲区get到会是两倍，实际测试中缓冲区大小还是1倍左右，这个左右的意思是指设置的缓冲区大小可能并不是实际设置大小，但是也接近实际大小。****

测试缓冲区大小可以使用常规的TCP C-S通信，某一端持续写，另一端不去读取数据，数据会在缓冲区堆积直到接收缓冲区满，可使用recv函数的MSG_PEEK标志窥探接收缓冲区数据量。


### Linux write系统调用阻塞测试
write系统调用，只负责将数据放入发送缓冲区，当一次write发送的数据量大于本地发送缓冲区和对方接收缓冲区总的空闲大小的时候，write会阻塞，write会尽量的将数据写入缓冲区，但是不会返回，write只会在所有数据全部写入后才会返回。网卡将发送缓冲区的数据写到对方接收缓冲区每次写多少都由操作系统决定，和用户无关。
TCP的发送/接受缓冲区（也就是发送/接受滑动窗口），是针对某一个具体的TCP连接来说的，每一个TCP连接都会有相应的滑动窗口，但是内核的发送/接受缓冲区是针对整个系统的，里面存放着整个系统的所有TCP连接的接收/发送的数据。


### Linux网络编程中的errno




### Linux setsockopt常用选项
man 7 socket可查看所有

* SO_REUSEADDR
如果在已经处于   ESTABLISHED状态下的socket(一般由端口号和标志符区分）调用 
 closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket：
```
 BOOL   bReuseaddr=TRUE;
 setsockopt(s,SOL_SOCKET   ,SO_REUSEADDR,(const   char*)&bReuseaddr,sizeof(BOOL));
```
* SO_RCVBUF
设置或获取最大套接字接收缓冲区（以字节为单位）。使用setsockopt（2）设置时，内核会将这个值加倍（以留出空间用于簿记开销），并且取值由getsockopt（2）返回。默认值由/ proc / sys / net / core / rmem_default文件设置，最大允许值由/ proc / sys / net / core / rmem_max文件。此选项的最小（加倍）值为256。

* SO_SNDBUF
              设置或获取最大套接字发送缓冲区（以字节为单位）。使用setsockopt（2）设置时，内核会将这个值加倍（以留出空间用于簿记开销），并且将其加倍
              值由getsockopt（2）返回。缺省值由/ proc / sys / net / core / wmem_default文件设置，最大允许值由/ proc / sys / net / core / wmem_max设置。
              文件。此选项的最小值（两倍）为2048。

* SO_RCVLOWAT和SO_SNDLOWAT
              指定缓冲区中的最小字节数，直到套接字层将数据传递给协议（SO_SNDLOWAT）或接收时的用户（SO_RCVLOWAT）。这两个值
              初始化为1。SO_SNDLOWAT在Linux上不可更改（setsockopt（2）失败，错误为ENOPROTOOPT）。仅从Linux 2.4开始，SO_RCVLOWAT才可以更改。 select（2）和
              poll（2）系统调用当前不支持Linux上的SO_RCVLOWAT设置，并且即使有一个字节的数据可用，也将套接字标记为可读。随后的阅读
              套接字将阻塞，直到SO_RCVLOWAT字节可用为止。

* SO_RCVTIMEO和SO_SNDTIMEO
              指定接收或发送超时，直到报告错误。该参数是一个struct timeval。如果输入或输出功能在这段时间内阻塞，并且数据
              发送或接收时，该函数的返回值将是传输的数据量；如果没有数据传输并且已经达到超时，则返回-1
              将errno设置为EAGAIN或EWOULDBLOCK或EINPROGRESS（对于connect（2）），就像将套接字指定为非阻塞一样。如果超时设置为零（默认值），则
              操作将永远不会超时。超时仅对执行套接字I / O的系统调用有效（例如read（2），recvmsg（2），send（2），sendmsg（2））;超时对没有影响

* SO_ERROR
              获取并清除挂起的套接字错误。此套接字选项是只读的。需要一个整数。

* SO_KEEPALIVE
              启用在面向连接的套接字上发送保持活动消息。需要一个整数布尔值标志。

* SO_LINGER
              设置或获取SO_LINGER选项。该论点是一个持久的结构。
```cpp
                    struct linger {
                      int l_onoff; / *持续有效* /
                      int l_linger; / *持续多少秒* /
                  };
```
启用后，close（2）或shutdown（2）不会返回，直到成功发送了套接字的所有排队消息或达到了超时为止。否则，调用立即返回，并且关闭在后台完成。当套接字作为exit（2）的一部分关闭时，它始终在后台徘徊。

* SO_PRIORITY
              为要在此套接字上发送的所有数据包设置协议定义的优先级。 Linux使用此值对网络队列进行排序：可以处理优先级较高的数据包
              首先取决于所选设备的排队规则。对于ip（7），这还将设置传出数据包的IP服务类型（TOS）字段。设置优先级超出范围
              0到6需要CAP_NET_ADMIN功能。



### 关于TCP长连接
TCP长连接，TCP长连接用于连接之间数据量时大时小分布不均匀的情况下，而为了维持连接，服务器和客户端都需要实现心跳，在心跳不存在时即时再次建立连接。

### Linux带缓冲IO和不带缓冲IO
Linux中对文件的IO操作通常可以调用read,write函数，这是标准的Linux系统调用，这些调用通常是不带缓冲的，这里的不带缓冲是一个相对的概念，指的是在用户层缓冲区是不带缓冲的，系统调用都会陷入到内核，内核还是会对数据进行缓存。
标准C库的标准IO函数fread，fwrite，fgets，fputs这些函数是带缓冲的，也就是说它们在用户层也就是标准C库上是由缓冲的，它们在Linux上最终也会调用read,write系统调用，也就是说它们在内核也会有缓冲。

对于不带缓冲的IO，也就是标准系统调用，每一次系统调用read，write都会陷入内核，涉及到进程上下文的切换，如果内核缓冲区大小为100字节，每次write 10个字节，进行10次write才能将缓冲区填满，数据才会从内核缓冲区刷新到磁盘，这样频繁的系统调用会使得IO操作的效率变低。

而对带缓冲的IO，标准IO在用户层上开辟了另一块缓冲区，设为50字节，当用户层的缓冲区被填满时，才会执行一次系统调用将数据写入内核缓冲区，这样就减少了系统调用次数，提升了IO效率。

所以数据并不是调用write或fwrite写入到文件流FILE*指针或文件描述符就成功写入到文件，其中要经过缓冲区，如果缓冲区的数据没有刷新到磁盘就调用fclose或close将文件关闭，数据是不会写入到磁盘的。可以调用fsync或sync系列系统调用，强制将缓冲区数据刷新到磁盘，这些系统调用对write和fwrite都适用。

无缓存IO操作数据流向路径：数据——内核缓存区——磁盘
标准IO操作数据流向路径：数据——流缓存区——内核缓存区——磁盘

标准I/O库就是带缓存的I/O，它由ANSI C标准说明。当然，标准I/O最终都会调用系统调用。标准I/O库代替用户处理很多细节，比如缓存分配、以优化长度执行I/O等。
标准I/O提供缓存的目的就是减少调用read和write的次数，它对每个I/O流自动进行缓存管理（标准I/O函数通常调用malloc来分配缓存）。它提供了三种类型的缓存：
1. 全缓存。当填满标准I/O缓存后才执行I/O操作。磁盘上的文件通常是全缓存的。
2. 行缓存。当输入输出遇到换行符\n或缓存满时，才由标准I/O库执行实际I/O操作。stdin、stdout通常是行缓存的。如printf函数就是行缓存，数据只有遇到\n或者缓冲区满，数据才会输出到stdout，也可以调用fllush(stdout)强制将输出缓冲区刷新，并将其中数据打印到标准输出。当然主函数retun时会强制刷新所有缓冲区，输出缓冲区数据也会被打印到屏幕。
3. 无缓存。相当于read、write了。stderr通常是无缓存的，因为它必须尽快输出。

例：第一次执行fread时会调用read从内核缓冲中读取更多的字节到用户空间缓冲，而下一次读取就直接从用户缓冲中取字节而不经过系统调用。而read每次都会从内核缓冲取字节。

*为什么总是需要将数据由内核缓冲区换到用户缓冲区或者相反呢？
答：用户进程是运行在用户空间的，不能直接操作内核缓冲区的数据。 用户进程进行系统调用的时候，会由用户态切换到内核态，待内核处理完之后再返回用户态
应用缓冲技术能很明显的提高系统效率。内核与外围设备的数据交换，内核与用户空间的数据交换都是比较费时的，使用缓冲区就是为了优化这些费时的操作。其实核心到用户空间的操作本身是不buffer的，是由I/O库用buffer来优化了这个操作。比如read本来从内核读取数据时是比较费时的，所以一次取出一块，以避免多次陷入内核。
      应用内核缓冲区的 主要思想就是一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据。
      管理员模式和用户模式之间的切换需要消耗时间，但相比之下，磁盘的I/O操作消耗的时间更多，为了提高效率，内核也使用缓冲区技术来提高对磁盘的访问速度。磁盘是数据块 的集合，内核会对磁盘上的数据块做缓冲。内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，内核一般不直接读磁盘，而 是将内核缓冲区中的数据复制到进程的缓冲区中。当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求队列，然后把该进程挂起，接着为其 他进程服务。一段时间之后(其实很短的时间)，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，最后唤醒被挂起的进程。
      注：理解内核缓冲区技术的原理有助于更好的掌握系统调用read&write，read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换。
      从理论上讲，内核可以在任何时候写磁盘，但并不是所有的write操作都会导致内核的写动作。内核会把要写的数据暂时存在缓冲区中，积累到一定数量后再一 次写入。有时会导致意外情况，比如断电，内核还来不及把内核缓冲区中的数据写道磁盘上，这些更新的数据就会丢失。
      应用内核缓冲技术导致的结果是：提高了磁盘的I/O效率；优化了磁盘的写操作；需要及时的将缓冲数据写到磁盘。*

相关未提及：setbuf函数，sync，fync函数，延迟写，页高速缓存。



https://blog.csdn.net/cxxmaker/article/details/24651457