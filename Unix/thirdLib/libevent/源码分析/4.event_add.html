<html>
<head>
  <title>4.event_add</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="925"/>
<h1>4.event_add</h1>

<div>
<span><div><span style="font-weight: bold;">在Linux下，结构体</span><span style="font-weight: bold;">event_io_map就被定义为</span><span style="font-weight: bold;">event_signal_map。</span></div><div><br/></div><div><span style="font-weight: bold;">在头文件</span><span style="font-weight: bold;">event-internal.h中，有这样一段话：</span></div><div><br/></div><div><span style="font-weight: bold;">#ifdef _WIN32</span></div><div><span style="font-weight: bold;">/* If we're on win32, then file descriptors are not nice low densely packed</span></div><div><span style="font-weight: bold;">   integers.  Instead, they are pointer-like windows handles, and we want to</span></div><div><span style="font-weight: bold;">   use a hashtable instead of an array to map fds to events.</span></div><div><span style="font-weight: bold;">*/</span></div><div><span style="font-weight: bold;">#define EVMAP_USE_HT</span></div><div><span style="font-weight: bold;">#endif</span></div><div><span style="font-weight: bold;">#ifdef EVMAP_USE_HT</span></div><div><span style="font-weight: bold;">#define HT_NO_CACHE_HASH_VALUES</span></div><div><span style="font-weight: bold;">#include &quot;ht-internal.h&quot;</span></div><div><span style="font-weight: bold;">struct event_map_entry;</span></div><div><span style="font-weight: bold;">HT_HEAD(event_io_map, event_map_entry);</span></div><div><span style="font-weight: bold;">#else</span></div><div><span style="font-weight: bold;">#define event_io_map event_signal_map</span></div><div><span style="font-weight: bold;">#endif</span></div><div><span style="font-weight: bold;">    </span></div><div><span style="font-weight: bold;">/* Used to map signal numbers to a list of events.  If EVMAP_USE_HT is not</span></div><div><span style="font-weight: bold;">   defined, this structure is also used as event_io_map, which maps fds to a</span></div><div><span style="font-weight: bold;">   list of events.</span></div><div><span style="font-weight: bold;">*/  </span></div><div><span style="font-weight: bold;">在Linux下是没有定义</span><span style="font-weight: bold;">EVMAP_USE_HT的所以结构体</span><span style="font-weight: bold;">event_io_map就被定义为</span><span style="font-weight: bold;">event_signal_map。</span></div><div><span style="font-weight: bold;">而对应的操作宏，也会有相应的变化。而在Windows下，宏</span><span style="font-weight: bold;">EVMAP_USE_HT是存在的，所以</span><span style="font-weight: bold;">event_io_map被定义为：</span></div><div><span style="font-weight: bold;">struct event_io_map</span></div><div><span style="font-weight: bold;">{</span></div><div><span style="font-weight: bold;">    //哈希表</span></div><div><span style="font-weight: bold;">    struct event_map_entry **hth_table;</span></div><div><span style="font-weight: bold;">    //哈希表的长度</span></div><div><span style="font-weight: bold;">    unsigned hth_table_length;</span></div><div><span style="font-weight: bold;">    //哈希的元素个数</span></div><div><span style="font-weight: bold;">    unsigned hth_n_entries;</span></div><div><span style="font-weight: bold;">    //resize 之前可以存多少个元素</span></div><div><span style="font-weight: bold;">    //在event_io_map_HT_GROW函数中可以看到其值为hth_table_length的</span></div><div><span style="font-weight: bold;">    //一半。但hth_n_entries&gt;=hth_load_limit时，就会发生增长哈希表的长度</span></div><div><span style="font-weight: bold;">    unsigned hth_load_limit;</span></div><div><span style="font-weight: bold;">    //后面素数表中的下标值。主要是指明用到了哪个素数</span></div><div><span style="font-weight: bold;">    int hth_prime_idx;</span></div><div><span style="font-weight: bold;">};复杂结构体</span></div><div><span style="font-weight: bold;">对应的宏操作也非常麻烦：具体参考：</span></div><div><a href="https://blog.csdn.net/luotuo44/article/details/38403241" style="font-weight: bold;">https://blog.csdn.net/luotuo44/article/details/38403241</a></div><div><br/></div><div><span style="font-weight: bold;">现在分析Linux下对应操作，选取函数</span><span style="font-weight: bold;">evmap_io_add_中的一个关键宏</span><span style="font-weight: bold;">GET_IO_SLOT_AND_CTOR</span><span style="font-weight: bold;">为例：</span></div><div><br/></div><div><span style="font-weight: bold;">同样Linux下和Windows下此宏都存在，由于数据结构的不同，操作也不同：</span></div><div><br/></div><div><span style="font-weight: bold;">#ifndef EVMAP_USE_HT</span></div><div><span style="font-weight: bold;">#define GET_IO_SLOT(x,map,slot,type) GET_SIGNAL_SLOT(x,map,slot,type)</span></div><div><span style="font-weight: bold;">#define</span> <span style="color: rgb(255, 0, 0); font-weight: bold;">GET_IO_SLOT_AND_CTOR</span><span style="font-weight: bold;">(x,map,slot,type,ctor,fdinfo_len)   \</span></div><div><span style="font-weight: bold;">    GET_SIGNAL_SLOT_AND_CTOR(x,map,slot,type,ctor,fdinfo_len)</span></div><div><span style="font-weight: bold;">#define FDINFO_OFFSET sizeof(struct evmap_io)</span></div><div><br/></div><div><span style="font-weight: bold;">先看一下关键结构体：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define event_io_map event_signal_map</div><div><br/></div><div>struct event_io_map {</div><div>   <font color="#A8A8A8"> /* An array of evmap_io * or of evmap_signal *; empty entries are</font></div><div><font color="#A8A8A8">     * set to NULL. */</font></div><div>    void **entries;</div><div>  <font color="#A8A8A8">  /* The number of entries available in entries */</font></div><div>    int nentries;</div><div>};</div><div><br/></div><div>struct event_list</div><div>{</div><div>    struct event *tqh_first;</div><div>    struct event **tqh_last;</div><div>};</div><div><br/></div><div>struct evmap_io {</div><div>    struct event_list events;</div><div>    ev_uint16_t nread;</div><div>    ev_uint16_t nwrite;</div><div>    ev_uint16_t nclose;</div><div>};</div><div><br/></div><div>struct event_map_entry {</div><div>    HT_ENTRY(event_map_entry) map_node;</div><div>    evutil_socket_t fd;</div><div>    union { /* This is a union in case we need to make more things that can</div><div>               be in the hashtable. */</div><div>        struct evmap_io evmap_io;</div><div>    } ent;</div><div>};</div><div><br/></div><div>#define HT_ENTRY(type)                          \</div><div>  struct {                                      \</div><div>    struct type *hte_next;                      \</div><div>  }</div></div><div><br/></div><div><span style="font-weight: bold;">函数event_add</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>event_add(struct event *ev, const struct timeval *tv)</div><div>{</div><div>    int res;</div><div><br/></div><div><br/></div><div>    if (EVUTIL_FAILURE_CHECK(!ev-&gt;ev_base)) {</div><div>        event_warnx(&quot;%s: event has no event_base set.&quot;, __func__);</div><div>        return -1;</div><div>    }</div><div><br/></div><div><br/></div><div>    EVBASE_ACQUIRE_LOCK(ev-&gt;ev_base, th_base_lock);</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">res = event_add_nolock_(ev, tv, 0);</font></div><div><br/></div><div><br/></div><div>    EVBASE_RELEASE_LOCK(ev-&gt;ev_base, th_base_lock);</div><div><br/></div><div><br/></div><div>    return (res);</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">event_add_nolock_</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>event_add_nolock_(struct event *ev, const struct timeval *tv,</div><div>    int tv_is_absolute)</div><div>{</div><div>    struct event_base *base = ev-&gt;ev_base;</div><div>    int res = 0;</div><div>    int notify = 0;</div><div><br/></div><div><br/></div><div>    EVENT_BASE_ASSERT_LOCKED(base);</div><div>    event_debug_assert_is_setup_(ev);</div><div><br/></div><div><br/></div><div>   <font color="#A8A8A8"> event_debug((</font></div><div><font color="#A8A8A8">         &quot;event_add: event: %p (fd &quot;EV_SOCK_FMT&quot;), %s%s%s%scall %p&quot;,</font></div><div><font color="#A8A8A8">         ev,</font></div><div><font color="#A8A8A8">         EV_SOCK_ARG(ev-&gt;ev_fd),</font></div><div><font color="#A8A8A8">         ev-&gt;ev_events &amp; EV_READ ? &quot;EV_READ &quot; : &quot; &quot;,</font></div><div><font color="#A8A8A8">         ev-&gt;ev_events &amp; EV_WRITE ? &quot;EV_WRITE &quot; : &quot; &quot;,</font></div><div><font color="#A8A8A8">         ev-&gt;ev_events &amp; EV_CLOSED ? &quot;EV_CLOSED &quot; : &quot; &quot;,</font></div><div><font color="#A8A8A8">         tv ? &quot;EV_TIMEOUT &quot; : &quot; &quot;,</font></div><div><font color="#A8A8A8">         ev-&gt;ev_callback));</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">    EVUTIL_ASSERT(!(ev-&gt;ev_flags &amp; ~EVLIST_ALL));</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">    if (ev-&gt;ev_flags &amp; EVLIST_FINALIZING) {</font></div><div><font color="#A8A8A8">        /* XXXX debug */</font></div><div><font color="#A8A8A8">        return (-1);</font></div><div><font color="#A8A8A8">    }</font></div><div><br/></div><div><br/></div><div>    /*</div><div>     * prepare for timeout insertion further below, if we get a</div><div>     * failure on any step, we should not change any state.</div><div>     */</div><div>    if (tv != NULL &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) {</div><div>        if (min_heap_reserve_(&amp;base-&gt;timeheap,</div><div>            1 + min_heap_size_(&amp;base-&gt;timeheap)) == -1)</div><div>            return (-1);  /* ENOMEM == errno */</div><div>    }//超时事件为其在小根堆中预留一个位置</div><div><br/></div><div><br/></div><div>    /* If the main thread is currently executing a signal event's</div><div>     * callback, and we are not the main thread, then we want to wait</div><div>     * until the callback is done before we mess with the event, or else</div><div>     * we can race on ev_ncalls and ev_pncalls below. */</div><div>#ifndef EVENT__DISABLE_THREAD_SUPPORT</div><div>    if (base-&gt;current_event == event_to_event_callback(ev) &amp;&amp;</div><div>        (ev-&gt;ev_events &amp; EV_SIGNAL)</div><div>        &amp;&amp; !EVBASE_IN_THREAD(base)) {</div><div>        ++base-&gt;current_event_waiters;</div><div>        EVTHREAD_COND_WAIT(base-&gt;current_event_cond, base-&gt;th_base_lock);</div><div>    }</div><div>#endif</div><div><br/></div><div><br/></div><div>    if ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED|EV_SIGNAL)) &amp;&amp;</div><div>        !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE|EVLIST_ACTIVE_LATER))) {</div><div>        if (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED))</div><div>           <font color="#FF0000"> res = evmap_io_add_(base, ev-&gt;ev_fd, ev);</font></div><div>        else if (ev-&gt;ev_events &amp; EV_SIGNAL)</div><div>            <font color="#FF0000">res = evmap_signal_add_(base, (int)ev-&gt;ev_fd, ev);</font></div><div>        if (res != -1)</div><div><font color="#FF0000">            event_queue_insert_inserted(base, ev);//ev-&gt;ev_flags |= EVLIST_INSERTED;</font></div><div>        if (res == 1) {</div><div>            /* evmap says we need to notify the main thread. */</div><div>            notify = 1;</div><div>            res = 0;</div><div>        }</div><div>    }</div><div>   /*</div><div>     * we should change the timeout state only if the previous event</div><div>     * addition succeeded.</div><div>     */</div><div>    if (res != -1 &amp;&amp; tv != NULL) {</div><div>        struct timeval now;</div><div>        int common_timeout;</div><div>#ifdef USE_REINSERT_TIMEOUT</div><div>        int was_common;</div><div>        int old_timeout_idx;</div><div>#endif</div><div><br/></div><div><br/></div><div>        /*</div><div>         * for persistent timeout events, we remember the</div><div>         * timeout value and re-add the event.</div><div>         *</div><div>         * If tv_is_absolute, this was already set.</div><div>         */</div><div>        if (ev-&gt;ev_closure == EV_CLOSURE_EVENT_PERSIST &amp;&amp; !tv_is_absolute)</div><div>            ev-&gt;ev_io_timeout = *tv;</div><div><br/></div><div><br/></div><div>#ifndef USE_REINSERT_TIMEOUT</div><div>        if (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT) {</div><div>            event_queue_remove_timeout(base, ev);</div><div>        }</div><div>#endif</div><div><br/></div><div><br/></div><div>        /* Check if it is active due to a timeout.  Rescheduling</div><div>         * this timeout before the callback can be executed</div><div>         * removes it from the active list. */</div><div>        if ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp;</div><div>            (ev-&gt;ev_res &amp; EV_TIMEOUT)) {</div><div>            if (ev-&gt;ev_events &amp; EV_SIGNAL) {</div><div>                /* See if we are just active executing</div><div>                 * this event in a loop</div><div>                 */</div><div>                if (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) {</div><div>                    /* Abort loop */</div><div>                    *ev-&gt;ev_pncalls = 0;</div><div>                }</div><div>            }</div><div><br/></div><div><br/></div><div>            event_queue_remove_active(base, event_to_event_callback(ev));</div><div>        }</div><div><br/></div><div><br/></div><div>        gettime(base, &amp;now);</div><div><br/></div><div><br/></div><div>        common_timeout = is_common_timeout(tv, base);</div><div>#ifdef USE_REINSERT_TIMEOUT</div><div>        was_common = is_common_timeout(&amp;ev-&gt;ev_timeout, base);</div><div>        old_timeout_idx = COMMON_TIMEOUT_IDX(&amp;ev-&gt;ev_timeout);</div><div>#endif</div><div><br/></div><div><br/></div><div>        if (tv_is_absolute) {</div><div>            ev-&gt;ev_timeout = *tv;</div><div>        } else if (common_timeout) {</div><div>            struct timeval tmp = *tv;</div><div>            tmp.tv_usec &amp;= MICROSECONDS_MASK;</div><div>            <font style="color: rgb(255, 0, 0);">evutil_timeradd(&amp;now, &amp;tmp, &amp;ev-&gt;ev_timeout);</font></div><div>            ev-&gt;ev_timeout.tv_usec |=</div><div>                (tv-&gt;tv_usec &amp; ~MICROSECONDS_MASK);</div><div>        } else {</div><div>           <font color="#FF0000"> evutil_timeradd(&amp;now, tv, &amp;ev-&gt;ev_timeout);</font></div><div>        }</div><div><br/></div><div><br/></div><div>        event_debug((</div><div>             &quot;event_add: event %p, timeout in %d seconds %d useconds, call %p&quot;,</div><div>             ev, (int)tv-&gt;tv_sec, (int)tv-&gt;tv_usec, ev-&gt;ev_callback));</div><div>#ifdef USE_REINSERT_TIMEOUT</div><div>        <font color="#FF0000">event_queue_reinsert_timeout(base, ev, was_common, common_timeout,</font></div><div>old_timeout_idx);</div><div>#else</div><div>       <font color="#FF0000"> event_queue_insert_timeout(base, ev);</font></div><div>#endif</div><div><br/></div><div><br/></div><div>        if (common_timeout) {</div><div>            struct common_timeout_list *ctl =</div><div>                get_common_timeout_list(base, &amp;ev-&gt;ev_timeout);</div><div>            if (ev == TAILQ_FIRST(&amp;ctl-&gt;events)) {</div><div>                common_timeout_schedule(ctl, &amp;now, ev);</div><div>            }</div><div>        } else {</div><div>            struct event* top = NULL;</div><div>            /* See if the earliest timeout is now earlier than it</div><div>             * was before: if so, we will need to tell the main</div><div>             * thread to wake up earlier than it would otherwise.</div><div>             * We double check the timeout of the top element to</div><div>             * handle time distortions due to system suspension.</div><div>             */</div><div>            if (min_heap_elt_is_top_(ev))</div><div>                notify = 1;</div><div>            else if ((top = min_heap_top_(&amp;base-&gt;timeheap)) != NULL &amp;&amp;</div><div>                     evutil_timercmp(&amp;top-&gt;ev_timeout, &amp;now, &lt;))</div><div>                notify = 1;</div><div>       }</div><div>    }</div><div><br/></div><div><br/></div><div>    /* if we are not in the right thread, we need to wake up the loop */</div><div>    if (res != -1 &amp;&amp; notify &amp;&amp; EVBASE_NEED_NOTIFY(base))</div><div>        evthread_notify_base(base);</div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> event_debug_note_add_(ev);</font></div><div><br/></div><div><br/></div><div>    return (res);</div><div>}</div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div><div><span style="font-weight: bold;">展示函数</span><span style="font-weight: bold;">evmap_io_add_中的宏</span><span style="font-weight: bold;">GET_IO_SLOT_AND_CTOR</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int evmap_io_add_(struct event_base *base, evutil_socket_t fd, struct event *ev)</div><div>{</div><div>    const struct eventop *evsel = base-&gt;evsel;</div><div>    struct event_io_map *io = &amp;base-&gt;io;</div><div>    </div><div><font color="#A8A8A8">/*event_base初始化</font></div><div><font color="#A8A8A8">evmap_io_initmap_(&amp;base-&gt;io);</font></div><div><font color="#A8A8A8">void </font><span style="color: rgb(168, 168, 168);">evmap_io_initmap_(struct event_io_map* ctx)</span></div><div><font color="#A8A8A8">{</font></div><div><font color="#A8A8A8">    evmap_signal_initmap_(ctx);</font></div><div><font color="#A8A8A8">}</font></div><div><font color="#A8A8A8">void </font><span style="color: rgb(168, 168, 168);">evmap_signal_initmap_(struct event_signal_map *ctx)</span></div><div><font color="#A8A8A8">{</font></div><div><font color="#A8A8A8">    ctx-&gt;nentries = 0;</font></div><div><font color="#A8A8A8">    ctx-&gt;entries = NULL;</font></div><div><font color="#A8A8A8">}*/</font></div><div>    struct evmap_io *ctx = NULL;</div><div>    int nread, nwrite, nclose, retval = 0;</div><div>    short res = 0, old = 0;</div><div>    struct event *old_ev;</div><div><br/></div><div>    EVUTIL_ASSERT(fd == ev-&gt;ev_fd);</div><div><br/></div><div>    if (fd &lt; 0)</div><div>        return 0;</div><div><br/></div><div>#ifndef EVMAP_USE_HT</div><div>       <font style="color: rgb(255, 0, 0);"> if (fd &gt;= io-&gt;nentries) {//第一次调用时，io-</font><font color="#FF0000"><font>&gt;</font>nentries为0</font></div><div><font color="#FF0000">            if (evmap_make_space(io, fd, sizeof(struct evmap_io *)) == -1)</font></div><div><font color="#FF0000">                return (-1);</font></div><div><font color="#FF0000">        }</font></div><div>#endif</div><div><br/></div><div>  </div><div>GET_IO_SLOT_AND_CTOR(ctx, io, fd, evmap_io, evmap_io_init,evsel-&gt;fdinfo_len);</div><div><br/></div><div><font color="#FF0000">do {</font></div><div><font color="#FF0000">     if ((io)-&gt;entries[fd] == ((void *)0))//内存有效且为NULL</font></div><div><font color="#FF0000">     {</font></div><div><font color="#FF0000">         (io)-&gt;entries[fd] = event_mm_calloc_((1), (sizeof(struct evmap_io)+evsel-       </font></div><div><font color="#FF0000">&gt;fdinfo_len));//为内存指针分配一个evmap_io结构体，</font></div><div><font color="#FF0000">         if (__builtin_expect(!!((io)-&gt;entries[fd] == ((void *)0)),0))</font></div><div><font color="#FF0000">             return (-1);</font></div><div><font style="color: rgb(255, 0, 0);">         (evmap_io_init)((struct evmap_io *)(io)-&gt;entries[fd]);//初始化</font></div><div><font color="#FF0000">     }</font></div><div><font color="#FF0000">     (ctx) = (struct evmap_io *)((io)-&gt;entries[fd]);//指针ctx指向为新fd分配的内存</font></div><div><font color="#FF0000">} while (0);</font></div><div><font color="#FF0000"><br/></font></div><div><font color="#A8A8A8">函数evmap_io_init：</font></div><div><font color="#A8A8A8">static void</font></div><div><font color="#A8A8A8">evmap_io_init(struct evmap_io *entry)</font></div><div><font color="#A8A8A8">{</font></div><div><font color="#A8A8A8">do { </font></div><div><font color="#A8A8A8">       (&amp;entry-&gt;events)-&gt;lh_first = ((void *)0); </font></div><div><font color="#A8A8A8">   } while ( 0);</font></div><div><font color="#A8A8A8">entry-&gt;nread = 0;</font></div><div><font color="#A8A8A8">entry-&gt;nwrite = 0;</font></div><div><font color="#A8A8A8">entry-&gt;nclose = 0;</font></div><div><font color="#A8A8A8">}  </font></div><div>    nread = ctx-&gt;nread;</div><div>    nwrite = ctx-&gt;nwrite;</div><div>    nclose = ctx-&gt;nclose;</div><div><br/></div><div><font color="#000000"><br/></font></div><div><font color="#000000">    if (nread)</font></div><div><font color="#000000">        old |= EV_READ;</font></div><div><font color="#000000">    if (nwrite)</font></div><div><font color="#000000">        old |= EV_WRITE;</font></div><div><font color="#000000">    if (nclose)</font></div><div><font color="#000000">        old |= EV_CLOSED;//第一次此代码是不会被执行的</font></div><div><br/></div><div><br/></div><div>    <font color="#000000">if (</font><font color="#FF0000">ev-&gt;ev_events</font> <font color="#000000">&amp; EV_READ) {</font></div><div><font color="#000000">        if (++nread == 1)</font></div><div><font color="#000000">            res |= EV_READ;</font></div><div><font color="#000000">    }</font></div><div><font color="#000000">    if (ev-&gt;ev_events &amp; EV_WRITE) {</font></div><div><font color="#000000">        if (++nwrite == 1)</font></div><div><font color="#000000">            res |= EV_WRITE;</font></div><div><font color="#000000">    }</font></div><div><font color="#000000">    if (ev-&gt;ev_events &amp; EV_CLOSED) {</font></div><div><font color="#000000">        if (++nclose == 1)</font></div><div><font color="#000000">            res |= EV_CLOSED;</font></div><div><font color="#000000">    }//返回值res会在后面用到，如果我们加入的event的ev-&gt;events为EV_READ,则res会为非0，如果我们再次将event的ev-&gt;events的标志EV_READ再次加入到event_base,则会为0。即一个fd虽然可以添加多次，但是同一个标志只允许添加一次，</font><font color="#FF0000">这里说的有问题，一个fd的一个标志可以有多个event</font></div><div><font color="#A8A8A8">    if (EVUTIL_UNLIKELY(nread &gt; 0xffff || nwrite &gt; 0xffff || nclose &gt; 0xffff)) {</font></div><div><font color="#A8A8A8">        event_warnx(&quot;Too many events reading or writing on fd %d&quot;,</font></div><div><font color="#A8A8A8">            (int)fd);</font></div><div><font color="#A8A8A8">        return -1;</font></div><div><font color="#A8A8A8">    }</font></div><div>    if (EVENT_DEBUG_MODE_IS_ON() &amp;&amp;</div><div>        (old_ev = LIST_FIRST(&amp;ctx-&gt;events)) &amp;&amp;</div><div>        (old_ev-&gt;ev_events&amp;EV_ET) != (ev-&gt;ev_events&amp;EV_ET)) {</div><div>        event_warnx(&quot;Tried to mix edge-triggered and non-edge-triggered&quot;</div><div>            &quot; events on fd %d&quot;, (int)fd);</div><div>        return -1;</div><div>    }</div><div>   if (res) {</div><div>        void *extra = ((char*)ctx) + sizeof(struct evmap_io);</div><div>        /* XXX(niels): we cannot mix edge-triggered and</div><div>         * level-triggered, we should probably assert on</div><div>         * this. */</div><div>        <font color="#FF0000">if (evsel-&gt;add(base, ev-&gt;ev_fd,</font></div><div><font color="#FF0000">            old, (ev-&gt;ev_events &amp; EV_ET) | res, extra) == -1)//对应后端的add函数</font></div><div>            return (-1);</div><div>        retval = 1;</div><div>    }</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">ctx-&gt;nread = (ev_uint16_t) nread;</font></div><div><font color="#FF0000">    ctx-&gt;nwrite = (ev_uint16_t) nwrite;</font></div><div><font color="#FF0000">    ctx-&gt;nclose = (ev_uint16_t) nclose;//更新fd内存</font></div><div>    <font color="#FF0000">LIST_INSERT_HEAD(&amp;ctx-&gt;events, ev, ev_io_next);//将此fd加入到此event的链表</font></div><div><br/></div><div><br/></div><div>    return (retval);</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int</div><div>evmap_make_space(struct event_signal_map *map, int slot, int msize)</div><div>{                        </div><div>    if (map-&gt;nentries &lt;= slot) {</div><div>        int nentries = map-&gt;nentries ? map-&gt;nentries : 32;</div><div>        void **tmp;</div><div>    </div><div>        if (slot &gt; INT_MAX / 2)</div><div>            return (-1);</div><div>        </div><div>        while (nentries &lt;= slot)</div><div>            nentries &lt;&lt;= 1;</div><div>    </div><div>        if (nentries &gt; INT_MAX / msize)</div><div>            return (-1);</div><div><br/></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000">        tmp = (void **)mm_realloc(map-&gt;entries, nentries * msize);//回调用realloc函数在原内存基础上&quot;添加&quot;一段内存</font></div><div>        if (tmp == NULL)</div><div>            return (-1);</div><div><br/></div><div><br/></div><div>     <font color="#FF0000">   memset(&amp;tmp[map-&gt;nentries], 0,</font></div><div><font color="#FF0000">            (nentries - map-&gt;nentries) * msize);//清零新分配那段内存</font></div><div><br/></div><div><br/></div><div>       <font color="#FF0000"> map-&gt;nentries = nentries;</font></div><div><font color="#FF0000">        map-&gt;entries = tmp;//新分配的地址可能变化，更新指针</font></div><div>    }</div><div><br/></div><div><br/></div><div>    return (0);</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">接下来看看select的add函数的实现</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int</div><div>select_add(struct event_base *base, int fd, short old, short events, void *p)</div><div>{</div><div>    struct selectop *sop = base-&gt;evbase;</div><div>    (void) p;</div><div><br/></div><div><br/></div><div>    EVUTIL_ASSERT((events &amp; EV_SIGNAL) == 0);</div><div>    check_selectop(sop);</div><div>    /*</div><div>     * Keep track of the highest fd, so that we can calculate the size</div><div>     * of the fd_sets for select(2)</div><div>     */</div><div>   <font color="#FF0000"> if (sop-&gt;event_fds &lt; fd) {</font></div><div><font color="#FF0000">        int fdsz = sop-&gt;event_fdsz;//更新select最大文件描述符，扩展内存</font></div><div><br/></div><div><br/></div><div>        if (fdsz &lt; (int)sizeof(fd_mask))</div><div>            fdsz = (int)sizeof(fd_mask);</div><div><br/></div><div><br/></div><div>        /* In theory we should worry about overflow here.  In</div><div>         * reality, though, the highest fd on a unixy system will</div><div>         * not overflow here. XXXX */</div><div>        while (fdsz &lt; (int) SELECT_ALLOC_SIZE(fd + 1))</div><div>            fdsz *= 2;</div><div><br/></div><div><br/></div><div>        if (fdsz != sop-&gt;event_fdsz) {</div><div>            if (select_resize(sop, fdsz)) {</div><div>                check_selectop(sop);</div><div>                return (-1);</div><div>            }</div><div>        }</div><div><br/></div><div><br/></div><div>        sop-&gt;event_fds = fd;</div><div>    }</div><div>   <font color="#FF0000"> if (events &amp; EV_READ)</font></div><div><font color="#FF0000">        FD_SET(fd, sop-&gt;event_readset_in);</font></div><div><font color="#FF0000">    if (events &amp; EV_WRITE)</font></div><div><font color="#FF0000">        FD_SET(fd, sop-&gt;event_writeset_in);//加入文件描述符到对应位数组</font></div><div>    check_selectop(sop);</div><div><br/></div><div><br/></div><div>    return (0);</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 