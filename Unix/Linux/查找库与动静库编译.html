<html>
<head>
  <title>查找库与动静库编译</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1323"/>
<h1>查找库与动静库编译</h1>

<div>
<span><div>在交叉编译libcurl后，移植到设备上使用http协议正常，但是使用https协议时会报错如下：</div><div>curl_easy_perform() failed: Unsupported protocol</div><div>设置curl选项：curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);</div><div>后查看报错如下：Protocol &quot;https&quot; not supported or disabled in libcurl</div><div><br/></div><div>查询原因后发现liburl库编译时默认不支持SSL，在./config是需手动开启对SSL的支持：./config --with-ssl=openssl安装路径</div><div>在./config完成时可以查看openssl已经支持SSL    enable</div><div><br/></div><div>openssl相关：<a href="https://www.cnblogs.com/Anker/p/6018032.html">https://www.cnblogs.com/Anker/p/6018032.html</a></div><div>    <a href="https://www.cnblogs.com/lsdb/p/9391979.html">https://www.cnblogs.com/lsdb/p/9391979.html</a></div><div>https相关：<a href="https://www.cnblogs.com/twoheads/p/12797652.html">https://www.cnblogs.com/twoheads/p/12797652.html</a></div><div><br/></div><div>liburl https双向认证</div><div><a href="https://www.cnblogs.com/yongpan/p/8084854.html">https://www.cnblogs.com/yongpan/p/8084854.html</a></div><div><br/></div><div>对所有用户有效在/etc/profile增加以下内容。只对当前用户有效在Home目录下的</div><div>.bashrc或.bash_profile里增加下面的内容：</div><div>(注意：等号前面不要加空格,否则可能出现 command not found)</div><div><br/></div><div>#在PATH中找到可执行文件程序的路径。</div><div>export PATH =$PATH:$HOME/bin</div><div><br/></div><div>#gcc找到头文件的路径</div><div>C_INCLUDE_PATH=/usr/include/libxml2:/MyLib</div><div>export C_INCLUDE_PATH</div><div><br/></div><div>#g++找到头文件的路径</div><div>CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/include/libxml2:/MyLib</div><div>export CPLUS_INCLUDE_PATH</div><div><br/></div><div>#找到动态链接库的路径</div><div>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/MyLib</div><div>export LD_LIBRARY_PATH</div><div><br/></div><div>#找到静态库的路径</div><div>LIBRARY_PATH=$LIBRARY_PATH:/MyLib</div><div>export LIBRARY_PATH</div><div><br/></div><div>Linux系统库文件/etc/ld.so.conf</div><div>Linux库查找优先级：<a href="https://blog.csdn.net/lumping/article/details/108149983">https://blog.csdn.net/lumping/article/details/108149983</a></div><div><br/></div><div><br/></div><div>ldconfig命令在默认搜寻目录/lib和/usr/lib以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库（格式如lib*.so*）</div><div>搜索结果按名字排序后写入缓存文件/etc/ld.so.cache</div><div>往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但之后要调一下ldconfig</div><div>往其他目录，一定要修改/etc/ld.so.conf，然后再调用ldconfig</div><div><br/></div><div>关于使用第三方库的链接顺序：</div><div>之前遇到一个项目使用liburl库，其交叉编译会依赖openssl库，因此程序链接时会依赖liburl和openssl库，liburl对应连接为-lcurl，openssl对应为-lssl -lcrypto，当我先连接openssl再链接liburl时，</div><div>链接会报错所有的有关liburl中调用的openssl函数为未定义，这个问题搞了我好久，后来抱着怀疑和试一下的心态，将LD的链接顺序改为先liburl再openssl编译就通过了，百度了一下后发现确实存在链接库有先后顺序。</div><div><br/></div><div><br/></div><div>编译器gcc对源文件编译成可执行文件的过程可分为：预处理，编译，汇编，链接四个阶段</div><div>预处理打开原文件中引用的宏gcc -E hello.c -o hello.i</div><div>编译过程生成汇编语言文件gcc -S hello.i &gt; hello.s</div><div>汇编过程把汇编语言代码翻译成目标机器指令gcc hello.s -c hello.o</div><div>链接过程将众多的目标文件(.o文件)链接生成真正的可执行文件</div><div><br/></div><div>链接过程以main函数所在的目标文件链接出可执行文件，在链接之前，实际文件可分为两类，1个是主函数所在.o文件，其他文件是主函数调用函数所依赖的.o文件。</div><div>对于这些依赖的文件，可以将其&quot;打包&quot;成一个文件，在链接是，只需要这个文件和主函数所在的.o文件链接即可。而这样一个文件就叫库。</div><div>Linux下的库分为两类：动态库和静态库</div><div><br/></div><div>动态库的制作过程：</div><div>1.将目标文件汇编为.o文件，gcc -c -fPIC target1.c target2.c target3.c生成target*.o</div><div>2.将目标文件打包成动态库文件：gcc -shared target1.o target2.o target3.o -o libtarget.so</div><div><br/></div><div>静态库的制作过程：</div><div>1.将目标文件汇编为.o文件，gcc -c -fPIC target1.c target2.c target3.c生成target*.o</div><div>2.将目标文件打包为静态库文件：ar -rcs libtarget.a target1.o target2.o target3.o</div><div><br/></div><div>一般gcc默认的链接选项是动态链接，可以再gcc 后追加-static指定使用静态库进行静态链接，静态链接的可执行文件会被动态链接的要大，程序运行时不依赖其他库，但是当静态库库函数修改重新编译后，可执行文件需要重新链接静态库。使用动态库编译的可执行文件比较小，运行时需要链接动态库运行，当动态库库函数修改重新编译后，可执行文件并不需要重新链接即可依赖修改后的动态库执行。</div><div><br/></div><div>相关命令readelf  ldd</div><div><br/></div><div>Linux prctl函数：可获取和设置线程名称，使用ps命令可查看线程</div><div><br/></div><div><br/></div><div>Linux系统维护：nohup命令，/etc/inittab，/etc/rc.d/rc.sysinit，/etc/rcN.d/</div><div><br/></div><div>jobs命令，Ctrl+z</div><div><br/></div><div>syslog: /var/log</div><div>日志服务syslogd</div><div>配置文件/etc/syslog.conf</div><div><br/></div><div><br/></div><div><br/></div><div>IP_TOS</div><div><a href="https://blog.csdn.net/weixin_33716154/article/details/85841545">https://blog.csdn.net/weixin_33716154/article/details/85841545</a></div><div><br/></div><div>TCP_KEEPALIVE</div><div><a href="http://www.blogjava.net/yongboy/archive/2015/04/14/424413.html">http://www.blogjava.net/yongboy/archive/2015/04/14/424413.html</a></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>kernel learning</div><div><a href="http://www.wowotech.net/pm_subsystem/regulator_framework_overview.html">http://www.wowotech.net/pm_subsystem/regulator_framework_overview.html</a></div><div><br/></div><div><br/></div><div>不可捕捉信号：SIGKILL和SIGSTOP</div><div><br/></div><div>SIGABRT：调用abort函数产生此信号，默认终止进程</div><div>SIGALRM：调用alarm定时器函数在未来某个时间点产生此信号。</div><div>SIGFPE：算术异常，除0等</div><div>SIGINT：CTRL+C</div><div>SIGKILL：kill -9+进程号杀死任意进程号</div><div>SIGPIPE：写一个读端关闭的管道产生此信号，套接字</div><div>SIGQUIT：CTRL+\，相比SIGINT此信号会产生core文件</div><div>SIGSEGV：段错误</div><div>SIGSTOP：同SIGKILL</div><div>SIGTERM：kill+进程号，可被捕获，相比SIGKILL让程序退出时有机会做好清理工作</div><div>SIGURG：通知进程发生一个紧急情况，网络接收带外数据可选择性产生此信号</div><div>SIGUSR1，SIGUSR2：用户自定义信号，通过kill函数发送信号执行用户定义的信号处理程序</div></span>
</div></body></html> 