<html>
<head>
  <title>4.stm32--OLED驱动（控制逻辑IIC）</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="770"/>
<h1>4.stm32--OLED驱动（控制逻辑IIC）</h1>

<div>
<span><div>之前使用printf串口打印可以STM将STM32的数据通过串口发送到主机并显示，对于STM32上的程序调试是非常方便的，但是如果需要实时在开发板上查看传感器数据信息如温湿度等，每次都要通过串口到主机才能查看实在不方便，而在开发板上搭载一块oled屏幕，将数据显示在屏幕上不失是一个好的选择。</div><div><br/></div><div>小熊座上搭载了一块0.91寸，分辨率128*32（每行能显示128个位数据，每列能显示32位数据）的oled屏幕，控制逻辑为IIC，并通过oled控制寄存器的特定命令操作oled屏幕将数据显示在屏幕上。</div><div>电路图：（下面为型号）</div><div><img src="4.stm32--OLED驱动（控制逻辑IIC）_files/Image.png" type="image/png" data-filename="Image.png" width="437"/></div><div>在MCU上对应的管脚为PB8和PB9，可以下载对应datasheet查看此oled屏幕的数据，以及操作方法。</div><div><br/></div><div>对于控制逻辑为IIC的器件，对引脚OLED_SDA以及OLED_SCL的控制代码几乎是通用的：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define OLED_SCLK_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8, GPIO_PIN_RESET);//SCL IIC接口的时钟信号</div><div>#define OLED_SCLK_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8, GPIO_PIN_SET);</div><div><br/></div><div><br/></div><div>#define OLED_SDIN_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_9, GPIO_PIN_RESET);//SDA IIC接口的数据信号</div><div>#define OLED_SDIN_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_9, GPIO_PIN_SET);</div><div><br/></div><div><br/></div><div>void IIC_Start(void)</div><div>{</div><div>    OLED_SCLK_Set();</div><div>    OLED_SDIN_Set();</div><div>    OLED_SDIN_Clr();</div><div>    OLED_SCLK_Clr();</div><div>}</div><div><br/></div><div>void IIC_Stop(void)</div><div>{</div><div>    OLED_SCLK_Set();</div><div>    OLED_SDIN_Clr();</div><div>    OLED_SDIN_Set();</div><div>}</div><div><br/></div><div>void IIC_Wait_Ack(void)</div><div>{</div><div>    OLED_SCLK_Set();</div><div>    OLED_SCLK_Clr();</div><div>}</div><div><br/></div><div>void Write_IIC_Byte(unsigned char IIC_Byte)</div><div>{</div><div>    unsigned char i;</div><div>    unsigned char m,da;</div><div>    da=IIC_Byte;</div><div>    OLED_SCLK_Clr();</div><div>    for(i=0;i&lt;8;i++)        </div><div>    {</div><div>        m=da;</div><div>        m=m&amp;0x80;</div><div>        if(m==0x80)</div><div>        {</div><div>            OLED_SDIN_Set();</div><div>        }</div><div>        else</div><div>            OLED_SDIN_Clr();</div><div>        da=da&lt;&lt;1;</div><div>        OLED_SCLK_Set();</div><div>        OLED_SCLK_Clr();</div><div>    }</div><div>}</div></div><div><br/></div><div>IIC协议，首先发送从机地址到IIC总线上，对于此OLED屏，只需要向其写入数据而没有读取步骤，从机地址为0x78（写入数据）</div><div><img src="4.stm32--OLED驱动（控制逻辑IIC）_files/Image [1].png" type="image/png" data-filename="Image.png" width="485"/></div><div><br/></div><div>向IIC设备写入一个字节：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void Write_IIC_Command(unsigned char IIC_Command)</div><div>{</div><div>    IIC_Start();</div><div>    Write_IIC_Byte(0x78);     //Slave address,SA0=0</div><div>    IIC_Wait_Ack();    </div><div>    Write_IIC_Byte(0x00);            //write command</div><div>    IIC_Wait_Ack();    </div><div>    Write_IIC_Byte(IIC_Command);</div><div>    IIC_Wait_Ack();    </div><div>    IIC_Stop();</div><div>}</div><div><br/></div><div>void Write_IIC_Data(unsigned char IIC_Data)</div><div>{</div><div>    IIC_Start();</div><div>    Write_IIC_Byte(0x78);            //D/C#=0; R/W#=0</div><div>    IIC_Wait_Ack();    </div><div>    Write_IIC_Byte(0x40);            //write data</div><div>    IIC_Wait_Ack();    </div><div>    Write_IIC_Byte(IIC_Data);</div><div>    IIC_Wait_Ack();    </div><div>    IIC_Stop();</div><div>}</div><div><br/></div><div>void OLED_WR_Byte(unsigned dat,unsigned cmd)</div><div>{</div><div>    if(cmd)</div><div>    {</div><div>        Write_IIC_Data(dat);</div><div>    }</div><div>    else</div><div>    {</div><div>        Write_IIC_Command(dat);    </div><div>    }</div><div>}</div></div><div>在这里，根据上面的时序图，写入数据首先发送IIC地址&lt;&lt;1,并置末位为0(0为写），再发送控制字节，控制字节第7位代表下一字节位数据还是命令，若下一字节为数据，则此位为1，反之为0，最后写入数据或命令。</div><div><br/></div><div>接下来是设备的初始化：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void OLED_Inits(void)</div><div>{</div><div>    HAL_Delay(200); //这里的延时很重要</div><div>    </div><div>    OLED_WR_Byte(0xAE,OLED_CMD);    //关闭显示</div><div><br/></div><div>    OLED_WR_Byte(0x00,OLED_CMD);    //设置低列地址  </div><div>    OLED_WR_Byte(0x10,OLED_CMD);    //设置高列地址</div><div>    </div><div>    OLED_WR_Byte(0x00,OLED_CMD);    //设置展示开始行即低列地址</div><div>    OLED_WR_Byte(0xB0,OLED_CMD);    //设置目标显示页的开始地址</div><div><br/></div><div>    OLED_WR_Byte(0x81,OLED_CMD);    //设置对比度控制寄存器</div><div>    OLED_WR_Byte(0xff,OLED_CMD);    //最高为0xff</div><div><br/></div><div>    OLED_WR_Byte(0xa1,OLED_CMD);    //段重定义设置,bit0:0,0-&gt;0;1,0-&gt;127; 0xa0左右反置 0xa1正常</div><div>    </div><div>    OLED_WR_Byte(0xa6,OLED_CMD);    //设置正常显示(设置显示方式;bit0:1,反相显示;0,正常显示 )</div><div><br/></div><div>    OLED_WR_Byte(0xa8,OLED_CMD);    //设置驱动路数 设置多路复用比(1比32)</div><div>    OLED_WR_Byte(0x1f,OLED_CMD);    //  1/32</div><div><br/></div><div>    OLED_WR_Byte(0xc8,OLED_CMD);    //设置COM输出扫描方向</div><div>    OLED_WR_Byte(0xd3,OLED_CMD);    //和上一条命令有关，下条命令指定显示映射的开始行到COM0-&gt;COM63中一个</div><div>    OLED_WR_Byte(0x00,OLED_CMD);    //COM0为0x00</div><div><br/></div><div>    OLED_WR_Byte(0xd5,OLED_CMD);    //设置显示时钟分频比/振荡器频率</div><div>    OLED_WR_Byte(0x80,OLED_CMD);    //设置分频比，设置时钟为100帧/秒</div><div><br/></div><div>    OLED_WR_Byte(0xd9,OLED_CMD);    //设置预充电周期</div><div>    OLED_WR_Byte(0x1f,OLED_CMD);    //设置预充1个时钟，放电15个时钟([3:0],PHASE 1;[7:4],PHASE 2;)</div><div><br/></div><div>    OLED_WR_Byte(0xda,OLED_CMD);    //设置COM硬件引脚配置</div><div>    OLED_WR_Byte(0x00,OLED_CMD); </div><div><br/></div><div>    OLED_WR_Byte(0xdb,OLED_CMD);    //设置VCOMH 电压倍率 </div><div>    OLED_WR_Byte(0x40,OLED_CMD);    //Set VCOM 释放电压([6:4]000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;)</div><div>    OLED_WR_Byte(0x8d,OLED_CMD);    //设置充电泵启用/禁用</div><div>    OLED_WR_Byte(0x14,OLED_CMD);    //设置(0x10禁用,0x14启用)</div><div><br/></div><div><br/></div><div>    OLED_WR_Byte(0xaf,OLED_CMD);    //开启显示</div><div>}</div></div><div><br/></div><div>上面这份代码是此OLED datasheet提供的标准代码</div><div><br/></div><div>开启和关闭OLED显示：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//开启OLED显示    </div><div>void OLED_Display_On(void)</div><div>{</div><div>    OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令（设置电荷泵）</div><div>    OLED_WR_Byte(0X14,OLED_CMD);  //DCDC ON（开启电荷泵）</div><div>    OLED_WR_Byte(0XAF,OLED_CMD);  //DISPLAY ON</div><div>}</div><div>//关闭OLED显示     </div><div>void OLED_Display_Off(void)</div><div>{</div><div>    OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令</div><div>    OLED_WR_Byte(0X10,OLED_CMD);  //DCDC OFF（关闭电荷泵）</div><div>    OLED_WR_Byte(0XAE,OLED_CMD);  //DISPLAY OFF</div><div>}           </div></div><div><br/></div><div>这里先来了解一下OLED的显示原理，这块OLED屏幕分辨率为128*32，即每行最多显示128个位，即16个字节，每列最多显示32位，即4个字节。</div><div>在这里，显示方规则是我们自己定的，但是一旦显示规则定下来，所有ASCII字符或者汉字的规则就被定下来，OLED显示采用点阵式显示，如ASCII码字符‘A'在采用8*16显示时，这里8*16代表此字符的显示要占8个位的列，和16个位的行，显然需要16个字节才能显示，在8*16点阵显示中，字符‘A'所对应的规则即16个字节为：0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20。画个图可能更清晰明了：</div><div><img src="4.stm32--OLED驱动（控制逻辑IIC）_files/Image [2].png" type="image/png" data-filename="Image.png" width="363"/></div><div>丑是丑了点，谁让分辨率这么低呢，唉。这就是字符‘A在OLED上8*16的显示，16个字节每个字节代表一列，从左至右，从上到下，当然这是在初始化时配置过的。后面会讲到页的水平垂直寻址等。只不过这种寻址是最常见的水平寻址（从左至右再从上至下）。</div><div><br/></div><div><br/></div><div>到这里，我们有了初始化函数，有了写数据函数，我们想要写入数据，直接将要写入的字节发给OLED即可，但是还有一个问题：如何让屏幕知道我们要从那里开始写呢，初始化时告诉屏幕从低列地址即最左上方开始写，但是写完第一个字节，如何再写第二个呢?</div><div><br/></div><div>定点函数：（类似光标）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void OLED_Set_Pos(unsigned char x, unsigned char y)</div><div>{     </div><div>    OLED_WR_Byte(0xb0+y,OLED_CMD);</div><div>    OLED_WR_Byte(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);</div><div>    OLED_WR_Byte((x&amp;0x0f),OLED_CMD);</div><div>}   </div></div><div>代码第一行意思就是将光标定位到低列地址首</div><div>接下来一句，</div><div>OLED_WR_Byte(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);</div><div>x0是等于x的，可以认为是x，我们看手册的定义如下图：</div><div><img src="4.stm32--OLED驱动（控制逻辑IIC）_files/Image [3].png" type="image/png" data-filename="Image.png" width="594"/></div><div>我们对应表格，当发送十六进制数字00~0FH表示页寻址方式下低位的列开始地址。当发送十六进制数字10~17H代表在页寻址方式下发送高位的列开始地址，所以x坐标是被切割位地位和高位分别发送给OLED的，所以程序的语句就不难理解了，x&amp;0xf0)&gt;&gt;4就是保留高4位然后移位4位，地址数据已移到了低四位，再或上0x10，就是组成10~17命令码，告诉OLED芯片这是地址寻址，高位开始的数值。</div><div>低位地址的语句：</div><div>OLED_WR_Byte((x&amp;0x0f),OLED_CMD);</div><div>这个同高位时同样的道理，见上图发送地位地址是00~0F，高位一定是0，只要或上0x0f屏蔽掉高位，将低位地址x4,x3,x2,x1直接发给OLED即可。</div><div>高位的x2,x1,x0,加上地位的x3,x2,x1,x0一共7个位，7个位可以寻址2的7次方就是128个地址，看刚好同128列匹配了。</div><div>举一个具体实例：</div><div>OLED_WR_Byte (0xb2,0); // b2：b代表页寻址，2是第2页；</div><div>OLED_WR_Byte (0x10,0); // 10: 1代表是列高位，0代表高3位为0；</div><div>OLED_WR_Byte (0x03,0); // 03：0代表是列低位，3代表低4位为3；</div><div>连起来意思是0x03,就是第3列的意思</div><div>（以下来自datasheet，其中改正高列地址为10h)</div><div><img src="4.stm32--OLED驱动（控制逻辑IIC）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>即可以通过传入参数x，y改变光标的位置，即下一个数据写上的位置，x，就相当于坐标系的存在。</div><div><br/></div><div>可以用此方法代替Display设置电荷泵开启和关闭屏幕：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//注意：清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!      </div><div>void OLED_Clear(void)  </div><div>{  </div><div>    uint8_t i,n;            </div><div>    for(i=0;i&lt;8;i++)  </div><div>    {  </div><div>        OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）</div><div>        OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置—列低地址</div><div>        OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置—列高地址   </div><div>        for(n=0;n&lt;128;n++)</div><div>            OLED_WR_Byte(0,OLED_DATA);</div><div>    } //更新显示</div><div>}</div><div>void OLED_On(void)  </div><div>{  </div><div>    uint8_t i,n;            </div><div>    for(i=0;i&lt;8;i++)  </div><div>    {  </div><div>        OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）</div><div>        OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置—列低地址</div><div>        OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置—列高地址   </div><div>        for(n=0;n&lt;128;n++)OLED_WR_Byte(1,OLED_DATA);</div><div>    } //更新显示</div><div>}</div><div>void fill_picture(unsigned char fill_Data)</div><div>{</div><div>    unsigned char m,n;</div><div>    for(m=0;m&lt;8;m++)</div><div>    {</div><div>        OLED_WR_Byte(0xb0+m,0);        //page0-page1</div><div>        OLED_WR_Byte(0x00,0);        //low column start address</div><div>        OLED_WR_Byte(0x10,0);        //high column start address</div><div>        for(n=0;n&lt;128;n++)</div><div>        {</div><div>            OLED_WR_Byte(fill_Data,1);</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div>最后给出显示字符和字符串函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//在指定位置显示一个字符,包括部分字符</div><div>//x:0~127</div><div>//y:0~63</div><div>//                 </div><div>//size:选择字体 16/12</div><div>void OLED_ShowChar(uint8_t x,uint8_t y,uint8_t chr,uint8_t Char_Size)</div><div>{          </div><div>    unsigned char c=0,i=0;    </div><div>    c=chr-' ';//得到偏移后的值            </div><div>    if(x&gt;Max_Column-1){x=0;y=y+2;}</div><div>    if(Char_Size ==16)</div><div>    {</div><div>        OLED_Set_Pos(x,y);    </div><div>        for(i=0;i&lt;8;i++)</div><div>            OLED_WR_Byte(F8X16[c*16+i],OLED_DATA);</div><div>            OLED_Set_Pos(x,y+1);</div><div>        for(i=0;i&lt;8;i++)</div><div>            OLED_WR_Byte(F8X16[c*16+i+8],OLED_DATA);</div><div>    }</div><div>    else</div><div>    {    </div><div>        OLED_Set_Pos(x,y);</div><div>        for(i=0;i&lt;6;i++)</div><div>            OLED_WR_Byte(F6x8[c][i],OLED_DATA);</div><div>    }</div><div>}</div><div><br/></div><div>//显示一个字符号串</div><div>void OLED_ShowString(uint8_t x,uint8_t y,uint8_t *chr,uint8_t Char_Size)</div><div>{</div><div>    unsigned char j=0;</div><div>    while (chr[j]!='\0')</div><div>    {        </div><div>        OLED_ShowChar(x,y,chr[j],Char_Size);</div><div>        x+=8;</div><div>        if(x&gt;120)</div><div>        {</div><div>            x=0;y+=2;</div><div>        }</div><div>        j++;</div><div>    }</div><div>}</div></div><div>其中数组F8X16和F6x8代表分辨率为8*16和6*8下的两个ASCII字符点阵库。</div><div><br/></div><div>这里没有该模块的对应指令集，用的ssd1306的指令集，操作试着让屏幕滚动，结果不行，可能是此屏幕的滚动命令和ssd1306不同。</div><div>相关资料和代码：</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 