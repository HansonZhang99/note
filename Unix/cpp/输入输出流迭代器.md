# 输入输出流迭代器

## 输入流迭代器
输入流迭代器在文本模式下从流中提取数据，这意味着它无法处理二进制流。

一般用两个输入流迭代器从流中读取全部的值。指向要读取的第一个值的开始迭代器，指向流末尾的结束迭代器。输入流结束状态EOF被识别时，可以确定结束迭代器。

定义在iterator头文件中的istream_iterator模板会使用提取运算符>>从流中读入T类型的值。不许有一个从istream对象读取T类型值得operator>>()函数重载版本。因为istream_iterator是一个输入迭代器，也就是一个单向迭代器，只能被使用一次。默认情况下，认为这种流包含的是char类型的字符。

创建istream_iterator对象：
```cpp
std::istream_iterator<string> in{std::cin};//read strings from cin
std::istream_iterator<string> end;//default constructor creates EOF-stream iterator
```
以下使用输入流迭代器处理宽字符：
```cpp
std::basic_ifstream<wchar_t> file{"test.txt"};
std::istream_iterator<std::wstring, wchar_t> in{file};
std::istream_iterator<std::wstring, wchar_t> end;
std::istream_iterator<std::wstring, wchar_t> in{wcin};
```

输入流迭代器成员函数：
`operator*()`返回迭代器当前指向对象的解除引用，可以多次重读相同的值。
`operator->()`返回当前对象的地址
`operator++()`会从底层输入流中读取一个值，并将它保存到一个迭代器对象中，返回一个迭代器对象的引用。因此，表达式 `*++in` 的值为最新的被保存的值。这不是一般的用法，因为它可能会跳过流中的第一个值。
`operator++(int)` 会从底层输入流读取一个值，并将它保存到一个迭代器对象中，为使用 `operator*()` 或 `operator->()` 访问做准备。在流中的新值被保存之前，这个函数会返回迭代器对象的一个代理。这意味着在读和保存底层输入流中的最新值之前，表达式 `*in++` 的值是保存在迭代器中的对象。

也有非成员函数，operator==() 和 operator!=() 可以比较相同类型的对象。两个输入迭代器是相等的，前提是它们都是同一个流的迭代器或者都是流的结束迭代器；否则，它们就不相等。

#### 迭代器和流迭代器
输入流迭代器和常规迭代器在数据项序列的关联方式上是不同的，明白这一点很重要。常规迭代器指向的是数组或容器中的元素。递增一个常规迭代器会改变它所指向的元素；这对指向同一个序列的元素的其他迭代器没有影响。这一点和流迭代器不同。

当用流迭代器来从标准输入流读取数据时，显然要考虑会发生什么；当流迭代器指向文件时，就可能不那么明显，但仍然可以应用。如果生成了两个和同一个流相关的输入流迭代器，初始时它们都指向第一个数据项。如果用一个迭代器来读取流，另一个不会再引用第一个数据值。当从标准输入流读取时，值会被第一个迭代器消耗。这是因为这个迭代器在读取一个值时，会修改流对象。输入流迭代器不仅会改变它所指向的元素(在引用时得到的结果)，也会改变底层流中确定下一次读操作从哪里开始的位置。

因此，给定流的两个或两个以上的输入流迭代器会指向从这个流中得到的下一个数据项。这意味着两个输入流迭代器所确定的序列只能由开始迭代器和流的结束迭代器组成。我们无法生成两个指向同一个流中两个不同值的流迭代器，这并不是说不能用输入流迭代器来访问数据项。在适当时，我们会看到可以这么做。
```cpp
#include <iostream>
#include <vector>
#include <iterator>
#include <string>
int main()
{
    using namespace std;
    std::cout << "Enter one or more words. Enter ! to end:";
    std::istream_iterator<string> in {std::cin}; // Reads strings from cin
    std::istream_iterator<string> in1 {std::cin}; // Reads strings from cin
    //std::istream_iterator<int> in1 {in};        // 如果调用拷贝构造函数，in1在从输入流取数据时，会指向in取的第一个数据
    std::vector<string> words;
    while(true)
    {
        string word = *in;
        if(word == "!") break;
        words.push_back(word);
        ++in;
    }
    cin.clear();
    cin.ignore();
    cout << "next" << endl;
    while(true)
    {
        string word = *in1;
        if(word == "!") break;
        words.push_back(word);
        ++in1;
    }

    std::cout << "You entered " << words.size() << "words." << std::endl;
    for(auto x : words)
        cout << x << endl;
}
```

`[Sun Sep 26 11:02:40~/test/cpp_learn/iterator]$ ./a.out
Enter one or more words. Enter ! to end:how are you !
next
i am fine, thanks !
You entered 7words.
how
you
are
i
am
fine,
thanks
`

```cpp
/ Calling istream_iterator function members
#include <iostream>                                   // For standard streams
#include <iterator>                                   // For stream iterators

int main()
{
    std::cout << "Enter some integers - enter Ctrl+Z to end.\n";
    std::istream_iterator<int> iter {std::cin};         // Create begin input stream iterator...
    std::istream_iterator<int> copy_iter {iter};        // ...and a copy
    std::istream_iterator<int> end_iter;                // Create end input stream iterator

    // Read some integers to sum
    int sum {};
    while(iter != end_iter)                             // Continue until Ctrl+Z read
    {
        sum += *iter++;
    }
    std::cout << "Total is " << sum << std::endl;

    std::cin.clear();                                   // Clear EOF state
    std::cin.ignore();                                  // Skip characters

    // Read integers using the copy of the iterator
    std::cout << "Enter some more integers - enter Ctrl+Z to end.\n";
    int product {1};
    while(true)
    {
        if(copy_iter == end_iter) break;                  // Break if Ctrl+Z was read
        product *= *copy_iter++;
    }
    std::cout << "product is " << product << std::endl;
}
```
`Enter some integers - enter Ctrl+Z to end.
2 3  ctrl+d
Total is 5
3 4  ctrl+d
Enter some more integers - enter Ctrl+Z to end.
product is 8
`

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <iterator>

int main()
{
    using std::string;
    using std::cin;
    using std::cout;
    using std::vector;
    using std::istream_iterator;
    using std::endl;
    vector<string> vt;
    cout << "Enter strings ,ctrl + D to stop:\n";
    istream_iterator<string> in{cin};
    istream_iterator<string> end;
    while(in != end)
    {
        string temp = *in++;
        vt.push_back(temp);
    }
    cout << "your entered " << vt.size() << " strings:\n";
    for( auto x : vt)
        cout << x << " ";
    cout << endl;
    cin.clear();
    //cin.ignore();
    cout << "Enter strings ,ctrl + D to stop:\n";
    istream_iterator<string> in1{cin};
    while(in1 != end)
    {
        string temp = *in1++;
        vt.push_back(temp);
    }
    cout << "your entered " << vt.size() << " strings:\n";
    for( auto x : vt)
        cout << x << " ";
    cout << endl;
    cin.clear();
    cout << "Enter integers ,ctrl + D to stop:\n";
    vector<int> vt1{1,2,3,4};
    std::copy(istream_iterator<int>{cin},istream_iterator<int>{}, std::back_inserter(vt1));
    for( auto x : vt1)
        cout << x << " ";
    cout << endl;
}
```
`[Sun Sep 26 11:23:01~/test/cpp_learn/iterator]$ ./a.out
Enter strings ,ctrl + D to stop:
how are you
your entered 3 strings:
how are you
Enter strings ,ctrl + D to stop:
i am fine
your entered 6 strings:
how are you i am fine
Enter integers ,ctrl + D to stop:
1 2 3 4 5 4 3
1 2 3 4 1 2 3 4 5 4 3
`

vector 容器有一个接受序列来初始化元素的构造函数，因此可以用生成容器的语句中的输入流迭代器来读取值：
`std::vector<double> data {std::istream_iterator<double>{std::cin},std::istream_iterator<double>{}};`


## 输出流迭代器
输出流迭代器是由 ostream_iterator 模板定义的，这个模板的第一个模板参数是被写值的类型，第二个模板参数是流字符的类型；第二个模板参数默认是 char 类型的值。ostream_iterator 是一个能够将任意 T 类型对象写到文本模式的输出流中的输出迭代器；只要 T 类型的对象实现了将 T 类型对象写到流中的 operator<<()。

因为它是一个输出迭代器，所以它支持前向和后向递增操作，并且是一个单向传入的迭代器。输出流迭代器定义了它的拷贝赋值运算符，因此可以用插入运算符将 T 对象写到流中。默认的输出流迭代器会按照 char 字符的序列来写入值。通过指定第二个模板类型参数，可以写包含不同类型字符的流。

ostream_iterator 类型定义了下面这些成员函数：
构造函数：第一个构造函数会用作为第一个参数的 ostream 对象的输出流生成一个开始迭代器，第二个参数是分隔符字符串。输出流对象会在每个被它写入到流中的对象的后面写分隔符字符串。第二个构造函数可以省略第二个差数，它会生成一个写对象时后面不跟分隔符的迭代器。
operator=(const T& obj) 会将 obj 写到流中，然后写分隔符字符串，前提是在构造函数中指定了一个。这个函数返回一个迭代器的引用。
operator*() 不做任何事，除了返回迭代器对象。为了将迭代器限定为输出迭代器，这个操作必须被定义。
operator++() 和 operator++(int) 都被定义了但不做任何事，除了返回迭代器对象。为了将迭代器限定为输出迭代器，前向或后向自增操作必须被支持。

不做任何事的运算符函数是必要的，因为它们是说明输出迭代器可以做些什么的规范的一部分。如果想写数据到一个文本模式的流中，并且随后打算以文本方式读取，流的值之间就需要分隔符。出于这个原因，尽管可以显式地写分隔符，但通常会使用有两个参数的构造函数。

```cpp
// Using output stream iterator function members
#include <iostream>                                      // For standard streams
#include <iterator>                                      // For iterators and begin() and end()
#include <vector>                                        // For vector container
#include <algorithm>                                     // For copy() algorithm
#include <string>
using std::string;

int main()
{
    std::vector<string> words {"The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"};

    // Write the words container using conventional iterator notation
    std::ostream_iterator<string> out_iter1 {std::cout};   // Iterator with no delimiter output
    for(const auto& word : words)
    {
        out_iter1 = word;                                 // Write a word
        out_iter1 = " ";                                  // Write a delimiter
    }
    *out_iter1 = "\n";                                   // Write newline

    // Write the words container again using the iterator
    for(const auto& word : words)
    {
        (out_iter1 = word) = " ";                            // Write the word and delimiter
    }
    *out_iter1++ = "\n";                                      // Write newline

    // Write the words container using copy()
    std::ostream_iterator<string> out_iter2 {std::cout, " "};
    std::copy(std::begin(words), std::end(words), out_iter2);
    out_iter2++ = "\n";
}
```
`[Sun Sep 26 11:34:56~/test/cpp_learn/iterator]$ ./a.out
The quick brown fox jumped over the lazy dog
The quick brown fox jumped over the lazy dog
The quick brown fox jumped over the lazy dog
`