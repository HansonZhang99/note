<html>
<head>
  <title>6.evbuffer的常用操作函数</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="938"/>
<h1>6.evbuffer的常用操作函数</h1>

<div>
<span><div>通常这些函数我们不会自己去调用他们，首先一般使用到它们是在bufferevent中，即在调用bufferevent_socket_new时会为input和output的bufferevent分配内存，并封装一系列的接口供用户调用，而接口的底层都是对evbuffer的操作，现在我们从struct evbuffer结构体开始:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct evbuffer {</div><div>    <font color="#A8A8A8">/** The first chain in this buffer's linked list of chains. */</font></div><div>    <font color="#FF0000">struct evbuffer_chain *first;</font></div><div>    <font color="#A8A8A8">/** The last chain in this buffer's linked list of chains. */</font></div><div>    <font color="#FF0000">struct evbuffer_chain *last;</font></div><div>  <font color="#A8A8A8">  /**</font><font color="#A8A8A8">The last_with_data chain is the last chain that has any data in it.</font></div><div><font color="#A8A8A8">     * If all chains in the buffer are empty, it is the first chain.</font></div><div><font color="#A8A8A8">     * If the buffer has no chains, it is NULL.<br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><span>    </span><span> </span>* The last_with_datap pointer points at _whatever 'next' pointer_</font></div><div><font color="#A8A8A8">     * pointing at the last_with_data chain. If the last_with_data chain</font></div><div><font color="#A8A8A8">     * is the first chain, or it is NULL, then the last_with_datap pointer</font></div><div><font color="#A8A8A8">     * is &amp;buf-&gt;first.</font></div><div><font color="#A8A8A8">     */</font></div><div><font color="#A8A8A8">    struct</font> <font color="#FF0000">evbuffer_chain **last_with_datap;</font></div><div><br/></div><div><br/></div><div>  <font color="#A8A8A8">  /** Total amount of bytes stored in all chains.*/</font></div><div>    size_t total_len;</div><div><br/></div><div><br/></div><div>    <font color="#A8A8A8">/** Number of bytes we have added to the buffer since we last tried to</font></div><div><font color="#A8A8A8">     * invoke callbacks. */</font></div><div>    size_t n_add_for_cb;</div><div>    <font color="#A8A8A8">/** Number of bytes we have removed from the buffer since we last</font></div><div><font color="#A8A8A8">     * tried to invoke callbacks. */</font></div><div>    size_t n_del_for_cb;</div><div><br/></div><div><br/></div><div>#ifndef EVENT__DISABLE_THREAD_SUPPORT</div><div>   <font color="#A8A8A8"> /** A lock used to mediate access to this buffer. */</font></div><div>    void *lock;</div><div>#endif</div><div>   <font color="#A8A8A8"> /** True iff we should free the lock field when we free this</font></div><div><font color="#A8A8A8">     * evbuffer. */</font></div><div>    unsigned own_lock : 1;</div><div>    <font color="#A8A8A8">/** True iff we should not allow changes to the front of the buffer</font></div><div><font color="#A8A8A8">     * (drains or prepends). */</font></div><div>    unsigned freeze_start : 1;</div><div>    <font color="#A8A8A8">/** True iff we should not allow changes to the end of the buffer</font></div><div><font color="#A8A8A8">     * (appends) */</font></div><div>    unsigned freeze_end : 1;</div><div>   <font color="#A8A8A8"> /** True iff this evbuffer's callbacks are not invoked immediately</font></div><div><font color="#A8A8A8">     * upon a change in the buffer, but instead are deferred to be invoked</font></div><div><font color="#A8A8A8">     * from the event_base's loop.  Useful for preventing enormous stack</font></div><div><font color="#A8A8A8">     * overflows when we have mutually recursive callbacks, and for</font></div><div><font color="#A8A8A8">     * serializing callbacks in a single thread. */</font></div><div>    unsigned deferred_cbs : 1;</div><div>#ifdef _WIN32</div><div>    <font color="#A8A8A8">/** True iff this buffer is set up for overlapped IO. */</font></div><div>    unsigned is_overlapped : 1;</div><div>#endif</div><div>    <font color="#A8A8A8">/** Zero or more EVBUFFER_FLAG_* bits */</font></div><div>    ev_uint32_t flags;</div><div><br/></div><div><br/></div><div>    <font color="#A8A8A8">/** Used to implement deferred callbacks. */</font></div><div>    struct event_base *cb_queue;</div><div><br/></div><div><br/></div><div>    <font color="#A8A8A8">/** A reference count on this evbuffer.  When the reference count</font></div><div><font color="#A8A8A8">     * reaches 0, the buffer is destroyed.  Manipulated with</font></div><div><font color="#A8A8A8">     * evbuffer_incref and evbuffer_decref_and_unlock and</font></div><div><font color="#A8A8A8">     * evbuffer_free. */</font></div><div>    int refcnt;</div><div><br/></div><div><br/></div><div>   <font color="#A8A8A8"> /** A struct event_callback handle to make all of this buffer's callbacks</font></div><div><font color="#A8A8A8">     * invoked from the event loop. */</font></div><div>    struct event_callback deferred;</div><div><br/></div><div><br/></div><div>   <font color="#A8A8A8"> /** A doubly-linked-list of callback functions */</font></div><div>    <font style="color: rgb(255, 0, 0);">LIST_HEAD(evbuffer_cb_queue, evbuffer_cb_entry) callbacks;</font></div><div><br/></div><div><br/></div><div>    /<font color="#A8A8A8">** The parent bufferevent object this evbuffer belongs to.</font></div><div><font color="#A8A8A8">     * NULL if the evbuffer stands alone. */</font></div><div>   <font color="#FF0000"> struct bufferevent *parent;</font></div><div>};</div></div><div><br/></div><div><b>struct evbuffer_chain</b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct evbuffer_chain {</div><div>    /** points to next buffer in the chain */</div><div>   <font color="#FF0000"> struct evbuffer_chain *next;</font></div><div><br/></div><div><br/></div><div>    /** total allocation available in the buffer field. */</div><div>    <font color="#FF0000">size_t buffer_len;</font></div><div><br/></div><div><br/></div><div>    /** unused space at the beginning of buffer or an offset into a</div><div>     * file for sendfile buffers. */</div><div>    ev_misalign_t misalign;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">/** Offset into buffer + misalign at which to start writing.</font></div><div><font color="#FF0000">     * In other words, the total number of bytes actually stored</font></div><div><font color="#FF0000">     * in buffer. */</font></div><div><font color="#FF0000">    size_t off;</font></div><div><br/></div><div><br/></div><div>    /** Set if special handling is required for this chain */</div><div>    unsigned flags;</div><div><font color="#A8A8A8">#define EVBUFFER_FILESEGMENT    0x0001  /**&lt; A chain used for a file segment */</font></div><div><font color="#A8A8A8">#define EVBUFFER_SENDFILE   0x0002  /**&lt; a chain used with sendfile */</font></div><div><font color="#A8A8A8">#define EVBUFFER_REFERENCE  0x0004  /**&lt; a chain with a mem reference */</font></div><div><font color="#A8A8A8">#define EVBUFFER_IMMUTABLE  0x0008  /**&lt; read-only chain */</font></div><div><font color="#A8A8A8">    /** a chain that mustn't be reallocated or freed, or have its contents</font></div><div><font color="#A8A8A8">     * memmoved, until the chain is un-pinned. */</font></div><div><font color="#A8A8A8">#define EVBUFFER_MEM_PINNED_R   0x0010</font></div><div><font color="#A8A8A8">#define EVBUFFER_MEM_PINNED_W   0x0020</font></div><div><font color="#A8A8A8">#define EVBUFFER_MEM_PINNED_ANY (EVBUFFER_MEM_PINNED_R|EVBUFFER_MEM_PINNED_W)</font></div><div><font color="#A8A8A8">    /** a chain that should be freed, but can't be freed until it is</font></div><div><font color="#A8A8A8">     * un-pinned. */</font></div><div><font color="#A8A8A8">#define EVBUFFER_DANGLING   0x0040</font></div><div><font color="#A8A8A8">    /** a chain that is a referenced copy of another chain */</font></div><div><font color="#A8A8A8">#define EVBUFFER_MULTICAST  0x0080</font></div><div><br/></div><div><br/></div><div>    /** number of references to this chain */</div><div>    int refcnt;</div><div><br/></div><div><br/></div><div>  <font color="#A8A8A8">  /** Usually points to the read-write memory belonging to this</font></div><div><font color="#A8A8A8">     * buffer allocated as part of the evbuffer_chain allocation.</font></div><div><font color="#A8A8A8">     * For mmap, this can be a read-only buffer and</font></div><div><font color="#A8A8A8">     * EVBUFFER_IMMUTABLE will be set in flags.  For sendfile, it</font></div><div><font color="#A8A8A8">     * may point to NULL.</font></div><div><font color="#A8A8A8">     */</font></div><div>  <font color="#FF0000">  unsigned char *buffer;</font></div><div>};</div></div><div><br/></div><div>evbuffer结构体在bufferevent中是用来存储数据的，这些数据存放在evbuffer的一条链表中，每个链表成员都是一个evbufer_chain结构。</div><div><b>图示如下：</b></div><div><b><img src="6.evbuffer的常用操作函数_files/Image.png" type="image/png" data-filename="Image.png"/></b></div><div><br/></div><div><br/></div><div><b>创建一个evbuffer结构，在bufferevent_socket_new中函数bufferevent_init_common_会分配两个evuffer分别作为输入和输出缓冲区。</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct evbuffer *</div><div>evbuffer_new(void)</div><div>{</div><div>    struct evbuffer *buffer;</div><div><br/></div><div><font color="#FF0000">    buffer = mm_calloc(1, sizeof(struct evbuffer));//为evbuffer分配内存</font></div><div>    if (buffer == NULL)</div><div>        return (NULL);</div><div><br/></div><div><br/></div><div>  <font color="#FF0000">  LIST_INIT(&amp;buffer-&gt;callbacks);//初始化回调函数队列</font></div><div>    buffer-&gt;refcnt = 1;</div><div>    buffer-&gt;last_with_datap = &amp;buffer-&gt;first;</div><div><br/></div><div><br/></div><div>    return (buffer);</div><div>}</div></div><div><br/></div><div><b>函数evbuffer_chain_new用于创建一个数据块（就这么称呼吧）</b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static struct evbuffer_chain *evbuffer_chain_new(size_t size)</div><div>{</div><div>    struct evbuffer_chain *chain;</div><div>    size_t to_alloc;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if (size &gt; EVBUFFER_CHAIN_MAX - EVBUFFER_CHAIN_SIZE)</font></div><div><font color="#FF0000">        return (NULL);//限制了最大的evbuffer_chain的数据存放区大小，这个大小是((size_t)(9223372036854775807L)) - sizeof(struct evbuffer_chain))</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">size += EVBUFFER_CHAIN_SIZE;//此时size为evbuffer_chain结构和数据存放区大小的总和</font></div><div><br/></div><div><br/></div><div>    /* get the next largest memory that can hold the buffer */</div><div>    <font color="#FF0000">if (size &lt; EVBUFFER_CHAIN_MAX / 2) {</font></div><div><font color="#FF0000">        to_alloc = MIN_BUFFER_SIZE;</font></div><div><font color="#FF0000">        while (to_alloc &lt; size) {</font></div><div><font color="#FF0000">            to_alloc &lt;&lt;= 1;</font></div><div><font style="color: rgb(255, 0, 0);">        }//如果size小于最大内存块的一半，则以内存块最小值开始翻倍，直到内存块值大于size</font></div><div>    <font color="#FF0000">} else {</font></div><div><font color="#FF0000">        to_alloc = size;//如果size大于最大内存块的一半，就直接分配size大小的内存</font></div><div>    }</div><div><br/></div><div><br/></div><div>    /* we get everything in one chunk */</div><div>   <font color="#FF0000"> if ((chain = mm_malloc(to_alloc)) == NULL)</font></div><div><font color="#FF0000">        return (NULL);//内存分配</font></div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> memset(chain, 0, EVBUFFER_CHAIN_SIZE);。。//清0除数据块之外的内存</font></div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> chain-&gt;buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;//此时buffer_len记录为数据块的大小</font></div><div><br/></div><div><br/></div><div>    /* this way we can manipulate the buffer to different addresses,</div><div>     * which is required for mmap for example.</div><div>     */</div><div>   <font color="#FF0000"> chain-&gt;buffer = EVBUFFER_CHAIN_EXTRA(unsigned char, chain);//chain-&gt;buffer = (unsigned char *)((struct evbuffer_chain *)(chain) + 1);指向此struct evbuffer_chain的尾地址的下一个字节</font></div><div><br/></div><div><br/></div><div>    chain-&gt;refcnt = 1;</div><div><br/></div><div><br/></div><div>    return (chain);</div><div>}</div></div><div><b><br/></b></div><div><b>函数evbuffer_chain_insert，用于插入数据块到evbuffer</b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void</div><div>evbuffer_chain_insert(struct evbuffer *buf,</div><div>    struct evbuffer_chain *chain)</div><div>{</div><div>    ASSERT_EVBUFFER_LOCKED(buf);</div><div>    if (*buf-&gt;last_with_datap == NULL) {</div><div>        /* There are no chains data on the buffer at all. */</div><div>        EVUTIL_ASSERT(buf-&gt;last_with_datap == &amp;buf-&gt;first);</div><div>        EVUTIL_ASSERT(buf-&gt;first == NULL);</div><div>        <font color="#FF0000">buf-&gt;first = buf-&gt;last = chain;//第一次插入数据，首尾指针都应该指向此内存块</font></div><div><span style="font-size: 9pt; color: rgb(214, 214, 214); font-family: Monaco;"><br/></span></div><div>    } else {</div><div>        struct evbuffer_chain **chp;</div><div>   <font color="#FF0000">     chp = evbuffer_free_trailing_empty_chains(buf);</font></div><div>   <font color="#A8A8A8">     static struct evbuffer_chain **</font></div><div><font color="#A8A8A8">        evbuffer_free_trailing_empty_chains(struct evbuffer *buf)</font></div><div><font color="#A8A8A8">        {</font></div><div><font color="#A8A8A8">            struct evbuffer_chain **ch = buf-&gt;last_with_datap;</font></div><div><font color="#A8A8A8">            /* Find the first victim chain.  It might be *last_with_datap */</font></div><div><font color="#A8A8A8">            while ((*ch) &amp;&amp; ((*ch)-&gt;off != 0 || CHAIN_PINNED(*ch)))</font></div><div><font color="#A8A8A8">//(*ch)-&gt;off != 0表示该evbuffer_chain有数据了，CHAIN_PINNED(*ch)则表示该evbuffer_chain不能被修改，在链表中寻找到一个可以使用的evbuffer_chain，可以使用是指该chain没有数据并且可以修改</font></div><div><font color="#A8A8A8">                ch = &amp;(*ch)-&gt;next;//直到找到一个这样的内存块</font></div><div><font color="#A8A8A8">            if (*ch) {//evbuffer_chain始终是指向最后一个有数据的buffer_chain，如果后面有空的数据块，就都释放掉</font></div><div><font color="#A8A8A8">                EVUTIL_ASSERT(evbuffer_chains_all_empty(*ch));</font></div><div><font color="#A8A8A8">                evbuffer_free_all_chains(*ch);</font></div><div><font color="#A8A8A8">                *ch = NULL;</font></div><div><font color="#A8A8A8">            }</font></div><div><font color="#A8A8A8">            return ch;</font></div><div><font color="#A8A8A8">        }</font></div><div>        <font color="#FF0000">*chp = chain;</font></div><div><font color="#FF0000">        if (chain-&gt;off)</font></div><div><font style="color: rgb(255, 0, 0);">      </font><font color="#FF0000"><font>      buf-&gt;last_with_datap = chp;//指向传如的chain的地址，，如果此chain的off不为0，即里面有数据，则让</font>buf-&gt;last_with_datap指向它</font></div><div>        <font color="#FF0000">buf-&gt;last = chain;</font></div><div>    }</div><div>    buf-&gt;total_len += chain-&gt;off;</div><div>}</div></div><div><b><br/></b></div><div><b>向链表尾部添加数据，函数evbuffer_add</b></div><div><b><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)</div><div>{</div><div>    struct evbuffer_chain *chain, *tmp;</div><div>    const unsigned char *data = data_in;</div><div>    size_t remain, to_alloc;</div><div>    int result = -1;</div><div><br/></div><div><br/></div><div>    EVBUFFER_LOCK(buf);</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if (buf-&gt;freeze_end) {</font></div><div><font color="#FF0000">        goto done;</font></div><div><font color="#FF0000">    }/冻结缓冲区尾部，禁止诗句追加</font></div><div>    /* Prevent buf-&gt;total_len overflow */</div><div>   <font color="#FF0000"> if (datlen &gt; EV_SIZE_MAX - buf-&gt;total_len) {</font></div><div><font color="#FF0000">        goto done;</font></div><div><font color="#FF0000">    }//数据长度大于了最大长度减去buf中已经存放数据的长度，EV_SIZE_MAX值为</font>18446744073709551615UL</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if (*buf-&gt;last_with_datap == NULL) {</font></div><div><font color="#FF0000">        chain = buf-&gt;last;//第一次插入数据</font></div><div>   <font color="#FF0000"> } else {</font></div><div><font color="#FF0000">        chain = *buf-&gt;last_with_datap;</font></div><div><font color="#FF0000">    }//如果不是第一次插入数据，chain指向最后一和存放有数据的evbuffer_chain</font></div><div><br/></div><div><br/></div><div>    /* If there are no chains allocated for this buffer, allocate one</div><div>     * big enough to hold all the data. */</div><div>    <font color="#FF0000">if (chain == NULL) {</font></div><div><font color="#FF0000">        chain = evbuffer_chain_new(datlen);</font></div><div><font color="#FF0000">        if (!chain)</font></div><div><font color="#FF0000">            goto done;</font></div><div><font style="color: rgb(255, 0, 0);">        evbuffer_chain_insert(buf, chain);</font></div><div><font color="#FF0000">    }//chain为NULL表明第一次插入数据，分配一个能hold住这些数据的内存块</font></div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> if ((chain-&gt;flags &amp; EVBUFFER_IMMUTABLE) == 0) {//如果最后一个chain不是一个read-only的chain</font></div><div>        /* Always true for mutable buffers */</div><div>        EVUTIL_ASSERT(chain-&gt;misalign &gt;= 0 &amp;&amp;</div><div>            (ev_uint64_t)chain-&gt;misalign &lt;= EVBUFFER_CHAIN_MAX);</div><div>        <font color="#FF0000">remain = chain-&gt;buffer_len - (size_t)chain-&gt;misalign - chain-&gt;off;//最后一个chain有剩余数据块空间</font></div><div>        <font color="#FF0000">if (remain &gt;= datlen) {//剩余空间可以存放下数据</font></div><div>            /* there's enough space to hold all the data in the</div><div>             * current last chain */</div><div>           <font color="#FF0000"> memcpy(chain-&gt;buffer + chain-&gt;misalign + chain-&gt;off,</font></div><div><font color="#FF0000">                data, datlen);</font></div><div>            <font color="#FF0000">chain-&gt;off += datlen;</font></div><div><font color="#FF0000">            buf-&gt;total_len += datlen;</font></div><div><font color="#FF0000">            buf-&gt;n_add_for_cb += datlen;</font></div><div>            goto out;</div><div>        <font color="#FF0000">} else if (!CHAIN_PINNED(chain) &amp;&amp;</font></div><div><font color="#FF0000">            evbuffer_chain_should_realign(chain, datlen)) {//该chain可修改，且通过调整后也可以放下此次数据。这里调整的意思应该是这个chain的中本来有数据，但是数据并不在数据块的首地址，即数据块前面是有空余的，将chain中的原始数据移动到数据块首地址后，剩余空间可以放下此次数据</font></div><div>            /* we can fit the data into the misalignment */</div><div>            <font color="#FF0000">evbuffer_chain_align(chain);//调整数据</font></div><div><br/></div><div><br/></div><div>           <font color="#FF0000"> memcpy(chain-&gt;buffer + chain-&gt;off, data, datlen);</font></div><div><font color="#FF0000">            chain-&gt;off += datlen;</font></div><div><font color="#FF0000">            buf-&gt;total_len += datlen;</font></div><div><font color="#FF0000">            buf-&gt;n_add_for_cb += datlen;</font></div><div>            goto out;</div><div>        }</div><div>  <font color="#FF0000">  } else {</font></div><div><font color="#FF0000">        /* we cannot write any data to the last chain */</font></div><div><font style="color: rgb(255, 0, 0);">        remain = 0;//这个数据块不能再写入数据了，即本来chian链表中最后一个数据块有数据，但是数据刚好写满，或者此数据块中数据不满，但是调整后也不能容纳此次数据，就该分配新的数据块了</font></div><div>    }</div><div>    <font color="#FF0000">to_alloc = chain-&gt;buffer_len;</font></div><div>    if (to_alloc &lt;= EVBUFFER_CHAIN_MAX_AUTO_SIZE/2)</div><div>        to_alloc &lt;&lt;= 1;</div><div>    if (datlen &gt; to_alloc)</div><div>        to_alloc = datlen;</div><div>   <font color="#FF0000"> tmp = evbuffer_chain_new(to_alloc);//分配一个chain内存块</font></div><div>    if (tmp == NULL)</div><div>        goto done;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if (remain) {</font></div><div><font color="#FF0000">        memcpy(chain-&gt;buffer + chain-&gt;misalign + chain-&gt;off,</font></div><div><font color="#FF0000">            data, remain);</font></div><div><font color="#FF0000">        chain-&gt;off += remain;</font></div><div><font color="#FF0000">        buf-&gt;total_len += remain;</font></div><div><font color="#FF0000">        buf-&gt;n_add_for_cb += remain;</font></div><div><font color="#FF0000">    }//前一个数据块中数据不满，但是调整后也不能容纳此次数据，先将前一个数据块写满</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">data += remain;</font></div><div><font color="#FF0000">    datlen -= remain;</font></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000">    memcpy(tmp-&gt;buffer, data, datlen);//将多于数据放入到新分配的内存块</font></div><div>    tmp-&gt;off = datlen;</div><div>   <font color="#FF0000"> evbuffer_chain_insert(buf, tmp);/插入此chain</font></div><div>    <font color="#FF0000">buf-&gt;n_add_for_cb += datlen;//记录添加了多少数据</font></div><div><br/></div><div><br/></div><div>out:</div><div>    <font color="#FF0000">evbuffer_invoke_callbacks_(buf);//这个函数待会分析</font></div><div>    result = 0;</div><div>done:</div><div>    EVBUFFER_UNLOCK(buf);</div><div>    return result;</div><div>}</div></div><div><b><br/></b></div><div><b>同样还有操在链表头部添加数据，从中复制数据的操作</b></div><div><b><br/></b></div><div><b>现在看看从evbuffer中删除数据：<br/></b><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>evbuffer_drain(struct evbuffer *buf, size_t len)</div><div>{</div><div>    struct evbuffer_chain *chain, *next;</div><div>    size_t remaining, old_len;</div><div>    int result = 0;</div><div><br/></div><div><br/></div><div>    EVBUFFER_LOCK(buf);</div><div>    old_len = buf-&gt;total_len;</div><div><br/></div><div><br/></div><div>    if (old_len == 0)</div><div>        goto done;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if (buf-&gt;freeze_start) {</font></div><div><font color="#FF0000">        result = -1;</font></div><div><font color="#FF0000">        goto done;</font></div><div><font color="#FF0000">    }//冻结数据首部，防止添加数据到evbuffer的chain链首部</font></div><div><br/></div><div><br/></div><div>   <font style="color: rgb(255, 0, 0);"> if (len &gt;= old_len &amp;&amp; !HAS_PINNED_R(buf)) {//要删除的数据量大于等于已有的数据量。并且这个evbuffer是可以删除的</font></div><div>        len = old_len;</div><div>       <font color="#FF0000"> for (chain = buf-&gt;first; chain != NULL; chain = next) {</font></div><div><font color="#FF0000">            next = chain-&gt;next;</font></div><div><font color="#FF0000">            evbuffer_chain_free(chain);//删除所有数据块</font></div><div>        }</div><div><br/></div><div><br/></div><div>        <font color="#FF0000">ZERO_CHAIN(buf);//重新初始化evbuffer_chain链表</font></div><div>   <font color="#FF0000"> } else {//要删除的数据量小于已有的数据量</font></div><div>        if (len &gt;= old_len)</div><div>            len = old_len;</div><div><br/></div><div><br/></div><div>        buf-&gt;total_len -= len;</div><div>        remaining = len;</div><div>        for (chain = buf-&gt;first;</div><div>             remaining &gt;= chain-&gt;off;</div><div>             chain = next) {</div><div>            next = chain-&gt;next;</div><div>            remaining -= chain-&gt;off;</div><div><br/></div><div><br/></div><div>           <font color="#FF0000"> if (chain == *buf-&gt;last_with_datap) {//如果已经删除到最后一个数据块</font></div><div><font color="#FF0000">                buf-&gt;last_with_datap = &amp;buf-&gt;first;</font></div><div><font style="color: rgb(255, 0, 0);">            }</font></div><div>           <font color="#FF0000"> if (&amp;chain-&gt;next == buf-&gt;last_with_datap)//删除到倒数第二个有数据的evbuffer_chain</font></div><div><font color="#FF0000">                buf-&gt;last_with_datap = &amp;buf-&gt;first;</font></div><div><br/></div><div><br/></div><div>           <font color="#FF0000"> if (CHAIN_PINNED_R(chain)) {//这个chain被固定了，不能删除</font></div><div>                EVUTIL_ASSERT(remaining == 0);</div><div>                chain-&gt;misalign += chain-&gt;off;</div><div>                chain-&gt;off = 0;</div><div>                break;//后面的evbuffer_chain也是固定的</div><div>            } else</div><div>                <font color="#FF0000">evbuffer_chain_free(chain);//直接删除chain</font></div><div>        }</div><div><span>    </span><span>    //到这里，表明这个chain中只能删除部分数据</span><br/></div><div><br/></div><div>        buf-&gt;first = chain;</div><div>        EVUTIL_ASSERT(remaining &lt;= chain-&gt;off);</div><div>        <font style="color: rgb(255, 0, 0);">chain-&gt;misalign += remaining;//清除掉应该删除的数据，这个域存放没有被删除的数据的第一个字节的数组下标</font></div><div><font color="#FF0000">        chain-&gt;off -= remaining;//删除数据，记录偏移量，此处偏移量已经不是从数据块首部开始了，而是从misalign开始</font></div><div>    }</div><div><br/></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000">    buf-&gt;n_del_for_cb += len;//记录被删除了多少数据</font></div><div>    /* Tell someone about changes in this buffer */</div><div>   <font style="color: rgb(255, 0, 0);"> evbuffer_invoke_callbacks_(buf);//这个待会看</font></div><div><br/></div><div><br/></div><div>done:</div><div>    EVBUFFER_UNLOCK(buf);</div><div>    return result;</div><div>}</div></div><div><br/></div><div><span style="font-family: Monaco;"><font style="font-size: 11pt;"><b>我们一般不会直接删除数据，而是获取这些数据再从数据块删除它们，也就是先复制这些数据到另一个地方，再删除这些数据。</b></font></span></div><div><span style="font-family: Monaco;"><font style="font-size: 11pt;"><b><br/></b></font></span></div><div><div><b>通常我们会调用函数evbuffer_remove</b></div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/* Reads data from an event buffer and drains the bytes read */</div><div>int</div><div>evbuffer_remove(struct evbuffer *buf, void *data_out, size_t datlen)</div><div>{</div><div>    ev_ssize_t n;</div><div>    EVBUFFER_LOCK(buf);</div><div>    <font color="#FF0000">n = evbuffer_copyout_from(buf, NULL, data_out, datlen);//复制原理很简单，memcpy</font></div><div>    if (n &gt; 0) {</div><div>       <font color="#FF0000"> if (evbuffer_drain(buf, n)&lt;0)//删除</font></div><div>            n = -1;</div><div>    }</div><div>    EVBUFFER_UNLOCK(buf);</div><div>    return (int)n;</div><div>}</div></div><div><br/></div><div><b><br/></b></div><div><b>至此一般我们添加数据会调用到函数evbuffer_add，删除或说移除数据调用函数evbuffer_remove</b></div><div><br/></div><div><b>现在看看evbuffer的回调函数</b></div><div><b><br/></b></div><div><b>evbuffer中还有一个很重要的成员：LIST_HEAD(evbuffer_cb_queue, evbuffer_cb_entry) callbacks;回调函数链表。</b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct evbuffer_cb_info {</div><div>    /** The number of bytes in this evbuffer when callbacks were last</div><div>     * invoked. */</div><div>    size_t orig_size;//添加或者删除数据之前的evbuffer有多少字节的数据</div><div>    /** The number of bytes added since callbacks were last invoked. */</div><div>    size_t n_added;//添加了多少数据</div><div>    /** The number of bytes removed since callbacks were last invoked. */</div><div>    size_t n_deleted;//删除了多少数据</div><div><span>    </span>因为每次删除或者添加数据都会调用回调函数，所以上面的三个成员只能记录从上一次</div><div><br/></div><div><span>    </span>回调函数被调用后，到本次回调函数被调用这段时间的情况</div><div><br/></div><div>};</div><div><br/></div><div>struct evbuffer_cb_entry {</div><div>    /** Structures to implement a doubly-linked queue of callbacks */</div><div>   <font color="#FF0000"> LIST_ENTRY(evbuffer_cb_entry) next;</font></div><div>    /** The callback function to invoke when this callback is called.</div><div>        If EVBUFFER_CB_OBSOLETE is set in flags, the cb_obsolete field is</div><div>        valid; otherwise, cb_func is valid. */</div><div>    union {</div><div>        evbuffer_cb_func cb_func;</div><div>        evbuffer_cb cb_obsolete;</div><div>    } cb;</div><div>    /** Argument to pass to cb. */</div><div>   <font color="#FF0000"> void *cbarg;</font></div><div>    /** Currently set flags on this callback. */</div><div>    ev_uint32_t flags;</div><div>};</div><div>typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *</div><div>info, void *arg);</div><div>typedef void (*evbuffer_cb)(struct evbuffer *buffer, size_t old_len, size_t new_len,</div><div>void *arg);</div></div><div><b><br/></b></div><div><b><br/></b></div><div><b>设置回调函数：</b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct evbuffer_cb_entry *</div><div>evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)</div><div>{</div><div>    struct evbuffer_cb_entry *e;</div><div>    if (! (e = mm_calloc(1, sizeof(struct evbuffer_cb_entry))))</div><div>        return NULL;</div><div>    EVBUFFER_LOCK(buffer);</div><div>    e-&gt;cb.cb_func = cb;</div><div>    e-&gt;cbarg = cbarg;</div><div>    e-&gt;flags = EVBUFFER_CB_ENABLED;</div><div>    <font color="#FF0000">LIST_INSERT_HEAD(&amp;buffer-&gt;callbacks, e, next);//插入到回调函数链表</font></div><div>    EVBUFFER_UNLOCK(buffer);</div><div>    return e;</div><div>}</div></div><div><b><br/></b></div><div><b>如何调用回调函数</b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void</div><div>evbuffer_run_callbacks(struct evbuffer *buffer, int running_deferred)</div><div>{</div><div>    struct evbuffer_cb_entry *cbent, *next;</div><div>    struct evbuffer_cb_info info;</div><div>    size_t new_size;</div><div>    ev_uint32_t mask, masked_val;</div><div>    int clear = 1;</div><div><br/></div><div><br/></div><div>    if (running_deferred) {</div><div>        mask = EVBUFFER_CB_NODEFER|EVBUFFER_CB_ENABLED;</div><div>        masked_val = EVBUFFER_CB_ENABLED;</div><div>    } else if (buffer-&gt;deferred_cbs) {</div><div>        mask = EVBUFFER_CB_NODEFER|EVBUFFER_CB_ENABLED;</div><div>        masked_val = EVBUFFER_CB_NODEFER|EVBUFFER_CB_ENABLED;</div><div>        /* Don't zero-out n_add/n_del, since the deferred callbacks</div><div>           will want to see them. */</div><div>        clear = 0;</div><div>    } else {</div><div>        mask = EVBUFFER_CB_ENABLED;</div><div>        masked_val = EVBUFFER_CB_ENABLED;</div><div>    }</div><div><br/></div><div><br/></div><div>    ASSERT_EVBUFFER_LOCKED(buffer);</div><div><br/></div><div><br/></div><div>    if (LIST_EMPTY(&amp;buffer-&gt;callbacks)) {</div><div>        buffer-&gt;n_add_for_cb = buffer-&gt;n_del_for_cb = 0;</div><div>        return;</div><div>    }</div><div>    if (buffer-&gt;n_add_for_cb == 0 &amp;&amp; buffer-&gt;n_del_for_cb == 0)</div><div>        return;</div><div><br/></div><div><br/></div><div>    new_size = buffer-&gt;total_len;</div><div>    info.orig_size = new_size + buffer-&gt;n_del_for_cb - buffer-&gt;n_add_for_cb;</div><div>    info.n_added = buffer-&gt;n_add_for_cb;</div><div>    info.n_deleted = buffer-&gt;n_del_for_cb;</div><div>    if (clear) {</div><div>        buffer-&gt;n_add_for_cb = 0;</div><div>        buffer-&gt;n_del_for_cb = 0;</div><div>    }</div><div>   <font color="#FF0000"> for (cbent = LIST_FIRST(&amp;buffer-&gt;callbacks);</font></div><div><font color="#FF0000">         cbent != LIST_END(&amp;buffer-&gt;callbacks);</font></div><div><font color="#FF0000">         cbent = next) {</font></div><div>        /* Get the 'next' pointer now in case this callback decides</div><div>         * to remove itself or something. */</div><div>        next = LIST_NEXT(cbent, next);</div><div><br/></div><div><br/></div><div>        if ((cbent-&gt;flags &amp; mask) != masked_val)</div><div>            continue;</div><div><br/></div><div><br/></div><div>       <font color="#FF0000"> if ((cbent-&gt;flags &amp; EVBUFFER_CB_OBSOLETE))</font></div><div><font color="#FF0000">            cbent-&gt;cb.cb_obsolete(buffer,</font></div><div><font color="#FF0000">                info.orig_size, new_size, cbent-&gt;cbarg);</font></div><div><font color="#FF0000">        else</font></div><div><font color="#FF0000">            cbent-&gt;cb.cb_func(buffer, &amp;info, cbent-&gt;cbarg);//遍历回调函数队列，调用回调函数</font></div><div>    }</div><div>}</div></div><div><b><br/></b></div><div><b><br/></b></div><div><b>在看到<font style="font-size: 11pt;">前面的</font></b><font style="font-size: 11pt;"><b> evbuffer_invoke_callbacks_函数</b></font></div><div><font style="font-size: 11pt;"><b><br/></b></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void</div><div>evbuffer_invoke_callbacks_(struct evbuffer *buffer)</div><div>{</div><div>    if (LIST_EMPTY(&amp;buffer-&gt;callbacks)) {</div><div>        buffer-&gt;n_add_for_cb = buffer-&gt;n_del_for_cb = 0;</div><div>        return;</div><div>    }</div><div><br/></div><div><br/></div><div>    if (buffer-&gt;deferred_cbs) {</div><div>        if (event_deferred_cb_schedule_(buffer-&gt;cb_queue, &amp;buffer-&gt;deferred)) {</div><div>            evbuffer_incref_and_lock_(buffer);</div><div>            if (buffer-&gt;parent)</div><div>                bufferevent_incref_(buffer-&gt;parent);</div><div>            EVBUFFER_UNLOCK(buffer);</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">evbuffer_run_callbacks(buffer, 0);</font></div><div>}</div></div><div><b><br/></b></div><div><b>即每次添加数据到evbuffer或从evbuffer删除数据，都会调用此函数</b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 