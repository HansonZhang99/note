<html>
<head>
  <title>1.bufferevent相关函数分析</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="934"/>
<h1>1.bufferevent相关函数分析</h1>

<div>
<span><div><div><span style="font-weight: bold;">先来看一下bufferevent的创建和工作流程：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>base=event_base_new();</div><div>bev=bufferevent_socket_new();</div><div>bufferevent_setcb(bev,do_read,do_write,do_event,(void *)base);</div><div>bufferevent_enable(bev, EV_READ|EV_WRITE);</div><div>bufferevent_socket_connect();</div><div>event_base_dispatch(base);</div></div><div><br/></div><div>大致过程就是这样，创建一个event_base,然后调用bufferevent_socket_new为其分配内存，bufferevent_setcb设置回调函数，bufferevent_enable使能某些标志，最后循环event_base。event_base坚监听此bufferevent上enable的事件，事件触发，调用响应的回调函数去处理事件。</div><div><br/></div><div><span style="font-weight: bold;">结构体bufferevent(include/event2/bufferevent_struct.h)</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct bufferevent {</div><div>    struct event_base *ev_base;//创建此缓冲区事件的事件库</div><div><br/></div><div>    const struct bufferevent_ops *be_ops;</div><div><br/></div><div>    struct event ev_read;//当超时或套接字发生时触发的读取事件准备读取数据。仅用于某些子类型bufferevent</div><div>    struct event ev_write;//当超时或套接字发生时触发的写入事件准备读取数据。仅用于某些子类型bufferevent</div><div><br/></div><div><br/></div><div>    struct evbuffer *input;//一个输入缓冲区。只允许bufferevent向其中添加数据这个缓冲区，允许用户将其耗尽</div><div>    struct evbuffer *output;//一个输入缓冲区。只有bufferevent允许清空数据，允许用户从这个缓冲区添加它</div><div><br/></div><div>    struct event_watermark wm_read;</div><div>    struct event_watermark wm_write;//读取和写入水位设置结构体</div><div><br/></div><div>    bufferevent_data_cb readcb;</div><div>    bufferevent_data_cb writecb;</div><div>    bufferevent_event_cb errorcb;//这应该被称为'eventcb</div><div>    //分别是可读可写出错事件发生时，调用的回调函数</div><div>    void *cbarg;//传给回调函数的参数</div><div>    </div><div>    struct timeval timeout_read;</div><div>    struct timeval timeout_write;//读写事件event的超时值</div><div>    </div><div>    short enabled;//当前支持的事件</div><div>};</div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">结构体evbuffer</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct evbuffer {</div><div>    /** The first chain in this buffer's linked list of chains. */</div><div>    struct evbuffer_chain *first;</div><div>    /** The last chain in this buffer's linked list of chains. */</div><div>    struct evbuffer_chain *last;</div><div><br/></div><div><br/></div><div>    /** Pointer to the next pointer pointing at the 'last_with_data' chain.</div><div>     *</div><div>     * To unpack:</div><div>     *</div><div>     * The last_with_data chain is the last chain that has any data in it.</div><div>     * If all chains in the buffer are empty, it is the first chain.</div><div>     * If the buffer has no chains, it is NULL.</div><div>     *</div><div>     * The last_with_datap pointer points at _whatever 'next' pointer_</div><div>     * pointing at the last_with_data chain. If the last_with_data chain</div><div>     * is the first chain, or it is NULL, then the last_with_datap pointer</div><div>     * is &amp;buf-&gt;first.</div><div>     */</div><div>    struct evbuffer_chain **last_with_datap;</div><div><br/></div><div><br/></div><div>    /** Total amount of bytes stored in all chains.*/</div><div>    size_t total_len;</div><div><br/></div><div><br/></div><div>    /** Number of bytes we have added to the buffer since we last tried to</div><div>     * invoke callbacks. */</div><div>    size_t n_add_for_cb;</div><div>    /** Number of bytes we have removed from the buffer since we last</div><div>     * tried to invoke callbacks. */</div><div>    size_t n_del_for_cb;</div><div><br/></div><div><br/></div><div>#ifndef EVENT__DISABLE_THREAD_SUPPORT</div><div>    /** A lock used to mediate access to this buffer. */</div><div>    void *lock;</div><div>#endif</div><div>    /** True iff we should free the lock field when we free this</div><div>     * evbuffer. */</div><div>    unsigned own_lock : 1;</div><div>    /** True iff we should not allow changes to the front of the buffer</div><div>     * (drains or prepends). */</div><div>    unsigned freeze_start : 1;</div><div>    /** True iff we should not allow changes to the end of the buffer</div><div>     * (appends) */</div><div>    unsigned freeze_end : 1;</div><div>    /** True iff this evbuffer's callbacks are not invoked immediately</div><div>     * upon a change in the buffer, but instead are deferred to be invoked</div><div>     * from the event_base's loop.  Useful for preventing enormous stack</div><div>     * overflows when we have mutually recursive callbacks, and for</div><div>     * serializing callbacks in a single thread. */</div><div>    unsigned deferred_cbs : 1;</div><div>#ifdef _WIN32</div><div>    /** True iff this buffer is set up for overlapped IO. */</div><div>    unsigned is_overlapped : 1;</div><div>#endif</div><div>    /** Zero or more EVBUFFER_FLAG_* bits */</div><div>    ev_uint32_t flags;</div><div><br/></div><div><br/></div><div>    /** Used to implement deferred callbacks. */</div><div>    struct event_base *cb_queue;</div><div><br/></div><div><br/></div><div>    /** A reference count on this evbuffer.  When the reference count</div><div>     * reaches 0, the buffer is destroyed.  Manipulated with</div><div>     * evbuffer_incref and evbuffer_decref_and_unlock and</div><div>     * evbuffer_free. */</div><div>    int refcnt;</div><div><br/></div><div><br/></div><div>    /** A struct event_callback handle to make all of this buffer's callbacks</div><div>     * invoked from the event loop. */</div><div>    struct event_callback deferred;</div><div><br/></div><div><br/></div><div>    /** A doubly-linked-list of callback functions */</div><div>    LIST_HEAD(evbuffer_cb_queue, evbuffer_cb_entry) callbacks;</div><div><br/></div><div><br/></div><div>    /** The parent bufferevent object this evbuffer belongs to.</div><div>     * NULL if the evbuffer stands alone. */</div><div>    struct bufferevent *parent;</div><div>};</div></div><div><span style="font-weight: bold;">结构体bufferevent_private(bufferevent_sock.c)</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct bufferevent_private</div><div>{</div><div>struct bufferevent bev;//底层bufferevent结构</div><div>struct evbuffer_cb_entry *read_watermarks_cb;//设置input evbuffer的高水位时，需要一个evbuffer回调函数配合工作</div><div>/** If set, we should free the lock when we free the bufferevent. */</div><div>unsigned own_lock : 1;</div><div><br/></div><div>unsigned readcb_pending : 1;</div><div>unsigned writecb_pending : 1;</div><div><br/></div><div>unsigned connecting : 1;</div><div><br/></div><div>unsigned connection_refused : 1;</div><div><br/></div><div>short eventcb_pending;</div><div><br/></div><div>bufferevent_suspend_flags read_suspended;</div><div>bufferevent_suspend_flags write_suspended;</div><div><br/></div><div>int errno_pending;</div><div>int dns_error;</div><div><br/></div><div>struct event_callback deferred;</div><div><br/></div><div>enum bufferevent_options options;</div><div><br/></div><div>int refcnt;</div><div><br/></div><div>void *lock;</div><div><br/></div><div>ev_ssize_t max_single_read;</div><div>ev_ssize_t max_single_write;</div><div><br/></div><div>struct bufferevent_rate_limit *rate_limiting;</div><div>union {</div><div>        struct sockaddr_in6 in6;</div><div>        struct sockaddr_in in;</div><div>    } conn_address;</div><div><br/></div><div>    struct evdns_getaddrinfo_request *dns_request;</div><div>}</div></div><div><br/></div><hr/><div><span style="font-weight: bold;">新建一个bufferevent</span></div><div><br/></div><div><span style="font-weight: bold;">结构体bufferevent_ops(</span><span style="font-weight: bold;">bufferevent-internal.h)</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct bufferevent_ops {</div><div>    /** The name of the bufferevent's type. */</div><div>    const char *type;</div><div>    /** At what offset into the implementation type will we find a</div><div>        bufferevent structure?</div><div><br/></div><div><br/></div><div>        Example: if the type is implemented as</div><div>        struct bufferevent_x {</div><div>           int extra_data;</div><div>           struct bufferevent bev;</div><div>        }</div><div>        then mem_offset should be offsetof(struct bufferevent_x, bev)</div><div>    */</div><div>    off_t mem_offset;</div><div>    </div><div>    /** Enables one or more of EV_READ|EV_WRITE on a bufferevent.  Does</div><div>        not need to adjust the 'enabled' field.  Returns 0 on success, -1</div><div>        on failure.</div><div>     */</div><div>    int (*enable)(struct bufferevent *, short);</div><div><br/></div><div><br/></div><div>    /** Disables one or more of EV_READ|EV_WRITE on a bufferevent.  Does</div><div>        not need to adjust the 'enabled' field.  Returns 0 on success, -1</div><div>        on failure.</div><div>     */</div><div>    int (*disable)(struct bufferevent *, short);</div><div><br/></div><div><br/></div><div>    /** Detatches the bufferevent from related data structures. Called as</div><div>     * soon as its reference count reaches 0. */</div><div>    void (*unlink)(struct bufferevent *);</div><div><br/></div><div><br/></div><div>    /** Free any storage and deallocate any extra data or structures used</div><div>        in this implementation. Called when the bufferevent is</div><div>        finalized.</div><div>     */</div><div>    void (*destruct)(struct bufferevent *);</div><div><br/></div><div><br/></div><div>    /** Called when the timeouts on the bufferevent have changed.*/</div><div>    int (*adj_timeouts)(struct bufferevent *);</div><div><br/></div><div><br/></div><div>    /** Called to flush data. */</div><div>    int (*flush)(struct bufferevent *, short, enum bufferevent_flush_mode);</div><div><br/></div><div><br/></div><div>    /** Called to access miscellaneous fields. */</div><div>    int (*ctrl)(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);</div><div><br/></div><div><br/></div><div>};</div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const struct <font style="color: rgb(54, 101, 238);">bufferevent_ops</font> bufferevent_ops_socket = {</div><div>    &quot;socket&quot;,</div><div>    evutil_offsetof(struct bufferevent_private, bev),</div><div>    be_socket_enable,</div><div>    be_socket_disable,</div><div>    NULL, /* unlink */</div><div>    be_socket_destruct,</div><div>    bufferevent_generic_adj_existing_timeouts_,</div><div>    be_socket_flush,</div><div>    be_socket_ctrl,</div><div>};</div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct bufferevent *<font color="#FF0000">bufferevent_socket_new</font>(struct event_base *base, evutil_socket_t fd,</div><div>    int options)</div><div>{</div><div>    struct bufferevent_private *bufev_p;</div><div>    struct bufferevent *bufev;</div><div><br/></div><div><br/></div><div><font color="#A8A8A8">#ifdef _WIN32</font></div><div><font color="#A8A8A8">    if (base &amp;&amp; event_base_get_iocp_(base))</font></div><div><font color="#A8A8A8">        return bufferevent_async_new_(base, fd, options);</font></div><div><font color="#A8A8A8">#endif</font></div><div><br/></div><div><br/></div><div>    if ((bufev_p = mm_calloc(1, sizeof(struct bufferevent_private)))== NULL)</div><div>        return NULL;//为bufev_p分配内存</div><div><br/></div><div><br/></div><div>    if (<font color="#FF0000">bufferevent_init_common_(bufev_p, base,</font> <font color="#2D4FC9">&amp;bufferevent_ops_socket</font><font color="#FF0000">,</font></div><div><font color="#FF0000">                    options) &lt; 0) {//初始化一些公共选项</font></div><div>        mm_free(bufev_p);</div><div>        return NULL;</div><div>    }</div><div>    <font color="#FF0000">bufev = &amp;bufev_p-&gt;bev;//获取初始化的bufferevent</font></div><div><font color="#FF0000"><br/></font></div><div>    <font color="#FF0000">evbuffer_set_flags(bufev-&gt;output, EVBUFFER_FLAG_DRAINS_TO_FD);//设置输出缓冲区的标志</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">event_assign(&amp;bufev-&gt;ev_read, bufev-&gt;ev_base, fd,</font></div><div><font color="#FF0000">        EV_READ|EV_PERSIST|EV_FINALIZE, bufferevent_readcb, bufev);//注册读事件到event_base，当内核缓冲区有数据到达时，回调函数会被调用</font></div><div><font color="#FF0000">    event_assign(&amp;bufev-&gt;ev_write, bufev-&gt;ev_base, fd,</font></div><div><font color="#FF0000">        EV_WRITE|EV_PERSIST|EV_FINALIZE, bufferevent_writecb, bufev);//注册写事件到event_base,当输出缓冲区有数据时，该函数会被调用</font></div><div><br/></div><div><br/></div><div>   <font style="color: rgb(255, 0, 0);"> evbuffer_add_cb(bufev-&gt;output, bufferevent_socket_outbuf_cb, bufev);//设置输出缓冲区的回调函数</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">evbuffer_freeze(bufev-&gt;input, 0);//冻结输入缓冲区evbuffer-&gt;freeze_end = 1;</font></div><div><font color="#FF0000">    evbuffer_freeze(bufev-&gt;output, 1);//冻结输出缓冲区evbuffer-&gt;freeze_start = 1;</font></div><div><br/></div><div><br/></div><div>    return bufev;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">函数bufferevent_init_common_(bufev_p, base, &amp;bufferevent_ops_socket,options)</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int bufferevent_init_common_(struct bufferevent_private *bufev_private,</div><div>    struct event_base *base,</div><div>    const struct bufferevent_ops *ops,</div><div>    enum bufferevent_options options)</div><div>{</div><div>    <font color="#FF0000">struct bufferevent *bufev = &amp;bufev_private-&gt;bev;//取出private中的bufferevent结构</font></div><div><br/></div><div>    <font color="#FF0000">if (!bufev-&gt;input) {</font></div><div><font color="#FF0000">        if ((bufev-&gt;input = evbuffer_new()) == NULL)</font></div><div><font color="#FF0000">            goto err;</font></div><div><font color="#FF0000">    }//为输入（读）缓冲区分配内存</font></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000">    if (!bufev-&gt;output) {</font></div><div><font color="#FF0000">        if ((bufev-&gt;output = evbuffer_new()) == NULL)</font></div><div><font color="#FF0000">            goto err;</font></div><div><font color="#FF0000">    }//为输出（写）缓冲区分配内存</font></div><div><br/></div><div><br/></div><div>    bufev_private-&gt;refcnt = 1;</div><div>    <font color="#FF0000">bufev-&gt;ev_base = base;//设置其所属的event_base</font></div><div><br/></div><div><br/></div><div>    /* Disable timeouts. */</div><div><font color="#FF0000">    evutil_timerclear(&amp;bufev-&gt;timeout_read);</font></div><div><font color="#FF0000">    evutil_timerclear(&amp;bufev-&gt;timeout_write);//清空读写时间超时值，默认为0即代表disable超时</font></div><div>    </div><div>    <font color="#FF0000">bufev-&gt;be_ops = ops;  //上面的全局结构体bufferevent_ops </font>                   </div><div>    </div><div>    <font color="#FF0000">if (bufferevent_ratelim_init_(bufev_private))//设置bufferevent_private结构的一些限制的变量</font></div><div>        goto err;</div><div>    </div><div>    /*</div><div>     * Set to EV_WRITE so that using bufferevent_write is going to</div><div>     * trigger a callback.  Reading needs to be explicitly enabled</div><div>     * because otherwise no data will be available.</div><div>     */</div><div>   <font color="#FF0000"> bufev-&gt;enabled = EV_WRITE;//bufferevent默认使能读事件</font></div><div><br/></div><div><br/></div><div>#ifndef EVENT__DISABLE_THREAD_SUPPORT</div><div>   <font color="#FF0000"> if (options &amp; BEV_OPT_THREADSAFE) {//为bufferevent分配线程锁</font></div><div>        if (bufferevent_enable_locking_(bufev, NULL) &lt; 0)</div><div>            goto err;</div><div>    }</div><div>#endif</div><div>    if ((options &amp; (BEV_OPT_DEFER_CALLBACKS|BEV_OPT_UNLOCK_CALLBACKS))</div><div>        == BEV_OPT_UNLOCK_CALLBACKS) {</div><div>        event_warnx(&quot;UNLOCK_CALLBACKS requires DEFER_CALLBACKS&quot;);</div><div>        goto err;</div><div>    }</div><div> <font color="#FF0000">   if (options &amp; BEV_OPT_UNLOCK_CALLBACKS)</font></div><div><font color="#FF0000">        event_deferred_cb_init_(</font></div><div><font color="#FF0000">            &amp;bufev_private-&gt;deferred,</font></div><div><font color="#FF0000">            event_base_get_npriorities(base) / 2,</font></div><div><font color="#FF0000">            bufferevent_run_deferred_callbacks_unlocked,</font></div><div><font color="#FF0000">            bufev_private);</font></div><div><font color="#FF0000">    else</font></div><div><font color="#FF0000">        event_deferred_cb_init_(</font></div><div><font color="#FF0000">            &amp;bufev_private-&gt;deferred,</font></div><div><font color="#FF0000">            event_base_get_npriorities(base) / 2,</font></div><div><font color="#FF0000">            bufferevent_run_deferred_callbacks_locked,</font></div><div><font color="#FF0000">            bufev_private);//延迟回调的初始化</font></div><div><br/></div><div><br/></div><div>    bufev_private-&gt;options = options;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">evbuffer_set_parent_(bufev-&gt;input, bufev);</font></div><div><font color="#FF0000">    evbuffer_set_parent_(bufev-&gt;output, bufev);//关联evbuffer和其所属的bufferevent</font></div><div><br/></div><div>    return 0;</div><div><br/></div><div>err:</div><div>    if (bufev-&gt;input) {</div><div>        evbuffer_free(bufev-&gt;input);</div><div>        bufev-&gt;input = NULL;</div><div>    }</div><div>    if (bufev-&gt;output) {</div><div>        evbuffer_free(bufev-&gt;output);</div><div>        bufev-&gt;output = NULL;</div><div>    }</div><div>    return -1;</div><div>}</div></div><div><br/></div><hr/><div><span style="font-weight: bold;">设置bufferevent回调函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void    </div><div>bufferevent_setcb(struct bufferevent *bufev,</div><div>    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</div><div>    bufferevent_event_cb eventcb, void *cbarg)</div><div>{           </div><div>    BEV_LOCK(bufev);</div><div>    </div><div>   <font color="#FF0000"> bufev-&gt;readcb = readcb;</font></div><div><font color="#FF0000">    bufev-&gt;writecb = writecb;</font></div><div><font color="#FF0000">    bufev-&gt;errorcb = eventcb;//回调函数</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">bufev-&gt;cbarg = cbarg;//回调参数</font></div><div>    BEV_UNLOCK(bufev);</div><div>}</div></div><div><br/></div><hr/><div><span style="font-weight: bold;">使能bufferevent的输入和输出回调函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int bufferevent_enable(struct bufferevent *bufev, short event)</div><div>{   </div><div>    <font color="#FF0000">struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);//类似container_of宏，结构体bufferevent属于结构体bufferevent_private，根据bufferevent所在bufferevent_private的位置找到bufferevent_private的首地址</font></div><div>    short impl_events = event;</div><div>    int r = 0;</div><div>    </div><div>    <font color="#FF0000">bufferevent_incref_and_lock_(bufev);//上锁</font></div><div>    <font color="#FF0000">if (bufev_private-&gt;read_suspended)</font></div><div><font color="#FF0000">        impl_events &amp;= ~EV_READ;//如果读事件被挂起，则清除EV_READ标志</font></div><div>   <font color="#FF0000"> if (bufev_private-&gt;write_suspended)</font></div><div><font color="#FF0000">        impl_events &amp;= ~EV_WRITE;//如果写事件被挂起，则清除EV_WRITE标志</font></div><div>        </div><div>    <font color="#FF0000">bufev-&gt;enabled |= event;//设置buffer_event的使能事件标志</font></div><div>    </div><div>    if (impl_events &amp;&amp; <font color="#FF0000">bufev-&gt;be_ops-&gt;enable(bufev, impl_events)</font> &lt; 0)</div><div>        r = -1;</div><div>    if (r)</div><div>        event_debug((&quot;%s: cannot enable 0x%hx on %p&quot;, __func__, event, bufev));</div><div>        </div><div>    <font color="#FF0000">bufferevent_decref_and_unlock_(bufev);//解锁</font></div><div>    return r;</div><div>}   </div></div><div><br/></div><div><span style="font-size: 11pt; font-family: Monaco; font-weight: bold;">bufferevent-&gt;be_ops-&gt;enable函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int</div><div>be_socket_enable(struct bufferevent *bufev, short event)</div><div>{</div><div>    if (event &amp; EV_READ &amp;&amp;</div><div>        <font color="#FF0000">bufferevent_add_event_(&amp;bufev-&gt;ev_read, &amp;bufev-&gt;timeout_read) == -1)</font></div><div>            return -1;</div><div>    if (event &amp; EV_WRITE &amp;&amp;</div><div>        <font color="#FF0000">bufferevent_add_event_(&amp;bufev-&gt;ev_write, &amp;bufev-&gt;timeout_write) == -1)</font></div><div>            return -1;</div><div>    return 0;</div><div>}</div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>bufferevent_add_event_(struct event *ev, const struct timeval *tv)</div><div>{</div><div>    if (!evutil_timerisset(tv))</div><div>     <font color="#FF0000">   return event_add(ev, NULL);</font></div><div>    else</div><div>       <font color="#FF0000"> return event_add(ev, tv);//添加事件到event_base的事件链表中，如果在bufferevent设置了超时，会添加超时</font></div><div>}</div></div><div><br/></div><hr/><div><span style="font-weight: bold;">手动添加bufferevent的事件的超时值</span></div><div><span style="font-weight: bold;">在前面的bufferevent初始化中，设置的默认超时值为0，我们可以通过调用函数来设置超时值。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void</div><div>bufferevent_settimeout(struct bufferevent *bufev,</div><div>               int timeout_read, int timeout_write)</div><div>{</div><div>    struct timeval tv_read, tv_write;</div><div>    struct timeval *ptv_read = NULL, *ptv_write = NULL;</div><div><br/></div><div><br/></div><div>    memset(&amp;tv_read, 0, sizeof(tv_read));</div><div>    memset(&amp;tv_write, 0, sizeof(tv_write));</div><div><br/></div><div><br/></div><div>    if (timeout_read) {</div><div>        tv_read.tv_sec = timeout_read;</div><div>        ptv_read = &amp;tv_read;</div><div>    }</div><div>    if (timeout_write) {</div><div>        tv_write.tv_sec = timeout_write;</div><div>        ptv_write = &amp;tv_write;</div><div>    }</div><div><br/></div><div><br/></div><div>    bufferevent_set_timeouts(bufev, ptv_read, ptv_write);</div><div>}</div><div><br/></div><div>int</div><div>bufferevent_set_timeouts(struct bufferevent *bufev,</div><div>             const struct timeval *tv_read,</div><div>             const struct timeval *tv_write)</div><div>{</div><div>    int r = 0;</div><div>    BEV_LOCK(bufev);</div><div>    if (tv_read) {</div><div>        bufev-&gt;timeout_read = *tv_read;</div><div>    } else {</div><div>        evutil_timerclear(&amp;bufev-&gt;timeout_read);</div><div>    }</div><div>    if (tv_write) {</div><div>        bufev-&gt;timeout_write = *tv_write;</div><div>    } else {</div><div>        evutil_timerclear(&amp;bufev-&gt;timeout_write);</div><div>    }</div><div><br/></div><div><br/></div><div>    if (bufev-&gt;be_ops-&gt;adj_timeouts)</div><div>        r = bufev-&gt;be_ops-&gt;adj_timeouts(bufev);</div><div>    BEV_UNLOCK(bufev);</div><div><br/></div><div><br/></div><div>    return r;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">到此，bufferevent的初始化就结束了，接下来用户调用event_base_loop等函数，就可以启动监听了。</span></div><div><br/></div><hr/><div><span style="font-weight: bold;">bufferevent初始化回调函数</span><span style="font-weight: bold;">bufferevent_readcb</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void bufferevent_readcb(evutil_socket_t fd, short event, void *arg)</div><div>{</div><div>   <font color="#FF0000"> struct bufferevent *bufev = arg;//回调参数为bufferevent</font></div><div>   <font color="#FF0000"> struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);//获取private</font></div><div><font color="#FF0000">    struct evbuffer *input;</font></div><div>    int res = 0;</div><div>    short what = BEV_EVENT_READING;</div><div>    ev_ssize_t howmuch = -1, readmax=-1;</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">bufferevent_incref_and_lock_(bufev);//上锁</font></div><div><br/></div><div><br/></div><div>  <font color="#FF0000">  if (event == EV_TIMEOUT) {</font></div><div><font color="#FF0000">        /* Note that we only check for event==EV_TIMEOUT. If</font></div><div><font color="#FF0000">         * event==EV_TIMEOUT|EV_READ, we can safely ignore the</font></div><div><font color="#FF0000">         * timeout, since a read has occurred */</font></div><div><font color="#FF0000">        what |= BEV_EVENT_TIMEOUT;</font></div><div><font color="#FF0000">        goto error;</font></div><div><font color="#FF0000">    }//如果只设置了超时，回调函数不做任何事，直接返回</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">input = bufev-&gt;input;//获取bufferevent的输入缓冲区</font></div><div><br/></div><div><br/></div><div> <font color="#A8A8A8">   /*</font></div><div><font color="#A8A8A8">     * If we have a high watermark configured then we don't want to</font></div><div><font color="#A8A8A8">     * read more data than would make us reach the watermark.</font></div><div><font color="#A8A8A8">     */</font></div><div>    <font color="#FF0000">if (bufev-&gt;wm_read.high != 0) {//默认高水位为0，如果用户修改高水位不为0</font></div><div>        <font color="#FF0000">howmuch = bufev-&gt;wm_read.high - evbuffer_get_length(input);//查看缓冲区数据是否大于高水位</font></div><div>        /* we somehow lowered the watermark, stop reading */</div><div>      <font color="#FF0000">  if (howmuch &lt;= 0) {</font></div><div><font style="color: rgb(255, 0, 0);">            bufferevent_wm_suspend_read(bufev);</font></div><div><font color="#FF0000">            goto done;//如果输入缓冲区数据大于高水位，就挂起读事件</font></div><div><font color="#FF0000">        }</font></div><div>    }</div><div><font color="#FF0000">    readmax = bufferevent_get_read_max_(bufev_p);/获取private的read_max值，默认为16384（在bufferevent_socket_new中被初始化</font></div><div>    if (howmuch &lt; 0 || howmuch &gt; readmax) /* The use of -1 for &quot;unlimited&quot;</div><div>                           * uglifies this code. XXXX */</div><div>        <font color="#FF0000">howmuch = readmax;//将howmuch设置为最大容量</font></div><div>  <font color="#FF0000">  if (bufev_p-&gt;read_suspended)//挂起</font></div><div>        goto done;</div><div><br/></div><div><br/></div><div>    <font style="color: rgb(255, 0, 0);">evbuffer_unfreeze(input, 0);//&quot;解冻&quot;输入缓冲区</font></div><div>    <font color="#FF0000">res = evbuffer_read(input, fd, (int)howmuch);//从内核缓冲区将数据读入到输入缓冲区，要求一次直接读取最大容量的数据，（对于边沿触发的多路复用IO如epoll，这样是最好的</font></div><div>    <font color="#FF0000">evbuffer_freeze(input, 0);//再次冻结输入缓冲区</font></div><div><br/></div><div><br/></div><div>    if (res == -1) {</div><div>        <font color="#FF0000">int err = evutil_socket_geterror(fd);//读取出错可能是文件描述符被关闭或网络断开连接</font></div><div>        <font color="#FF0000">if (EVUTIL_ERR_RW_RETRIABLE(err))</font></div><div><font color="#FF0000">            goto reschedule;</font></div><div><font color="#FF0000">        if (EVUTIL_ERR_CONNECT_REFUSED(err)) {</font></div><div><font color="#FF0000">            bufev_p-&gt;connection_refused = 1;</font></div><div><font color="#FF0000">            goto done;//判断错误和退出</font></div><div>        }</div><div>        /* error case */</div><div>       <font color="#FF0000"> what |= BEV_EVENT_ERROR;//其他错误</font></div><div>    } <font color="#FF0000">else if (res == 0) {</font></div><div><font color="#FF0000">        /* eof case */</font></div><div>       <font color="#FF0000"> what |= BEV_EVENT_EOF;//读取完成</font></div><div>    }</div><div><br/></div><div><br/></div><div><font color="#FF0000">    if (res &lt;= 0)</font></div><div><font color="#FF0000">        goto error;//其他错误，goto error</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">bufferevent_decrement_read_buckets_(bufev_p, res);</font></div><div><br/></div><div><br/></div><div>    /* Invoke the user callback - must always be called last */</div><div>    <font color="#FF0000">bufferevent_trigger_nolock_(bufev, EV_READ, 0);//调用用户回调函数处理数据</font></div><div><br/></div><div><br/></div><div>    goto done;</div><div><br/></div><div><br/></div><div>reschedule:</div><div>    goto done;</div><div><br/></div><div><br/></div><div>error:</div><div>   <font color="#FF0000"> bufferevent_disable(bufev, EV_READ);//清除bufferevent的EV_READ标志</font></div><div>    <font color="#FF0000">bufferevent_run_eventcb_(bufev, what, 0);//调用用户的错误处理回调</font></div><div><br/></div><div><br/></div><div>done:</div><div>    bufferevent_decref_and_unlock_(bufev);</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_trigger_nolock_</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static inline void</div><div>bufferevent_trigger_nolock_(struct bufferevent *bufev, short iotype, int options)</div><div>{   </div><div>    if ((iotype &amp; EV_READ) &amp;&amp; ((options &amp; BEV_TRIG_IGNORE_WATERMARKS) ||</div><div>        evbuffer_get_length(bufev-&gt;input) &gt;= bufev-&gt;wm_read.low))</div><div>       <font color="#FF0000"> bufferevent_run_readcb_(bufev, options);</font></div><div>    if ((iotype &amp; EV_WRITE) &amp;&amp; ((options &amp; BEV_TRIG_IGNORE_WATERMARKS) ||</div><div>        evbuffer_get_length(bufev-&gt;output) &lt;= bufev-&gt;wm_write.low))</div><div>        bufferevent_run_writecb_(bufev, options);</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_ratelim_init_</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>bufferevent_ratelim_init_(struct bufferevent_private *bev)</div><div>{       </div><div>    bev-&gt;rate_limiting = NULL;</div><div>    bev-&gt;max_single_read = MAX_SINGLE_READ_DEFAULT;</div><div>    bev-&gt;max_single_write = MAX_SINGLE_WRITE_DEFAULT;</div><div><br/></div><div><br/></div><div>    return 0;</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void</div><div>bufferevent_run_readcb_(struct bufferevent *bufev, int options)</div><div>{   </div><div>    /* Requires that we hold the lock and a reference */</div><div>    struct bufferevent_private *p = BEV_UPCAST(bufev);</div><div>    if (bufev-&gt;readcb == NULL)</div><div>        return;</div><div>    if ((p-&gt;options|options) &amp; BEV_OPT_DEFER_CALLBACKS) {</div><div>        p-&gt;readcb_pending = 1;</div><div>        SCHEDULE_DEFERRED(p);</div><div>    } else {</div><div>    <font color="#FF0000">    bufev-&gt;readcb(bufev, bufev-&gt;cbarg);//调用用户回调函数</font></div><div>        bufferevent_inbuf_wm_check(bufev);</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_wm_suspend_read</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define bufferevent_wm_suspend_read(b) \</div><div>    bufferevent_suspend_read_((b), BEV_SUSPEND_WM)</div><div>#define bufferevent_wm_unsuspend_read(b) \</div><div>    bufferevent_unsuspend_read_((b), BEV_SUSPEND_WM)</div><div><br/></div><div>void</div><div>bufferevent_suspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags what)</div><div>{</div><div>    struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);</div><div>    BEV_LOCK(bufev);</div><div>    if (!bufev_private-&gt;read_suspended)</div><div>        <font color="#FF0000">bufev-&gt;be_ops-&gt;disable(bufev, EV_READ);</font></div><div>    <font color="#FF0000">bufev_private-&gt;read_suspended |= what;//设置挂起成员变量值</font></div><div>    BEV_UNLOCK(bufev);</div><div>}  </div><div><br/></div><div>void</div><div>bufferevent_unsuspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags what)</div><div>{</div><div>    struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);</div><div>    BEV_LOCK(bufev);</div><div>    bufev_private-&gt;read_suspended &amp;= ~what;</div><div>   <font color="#FF0000"> if (!bufev_private-&gt;read_suspended &amp;&amp; (bufev-&gt;enabled &amp; EV_READ))</font></div><div><font color="#FF0000">        bufev-&gt;be_ops-&gt;enable(bufev, EV_READ);</font></div><div>    BEV_UNLOCK(bufev);</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int</div><div>be_socket_disable(struct bufferevent *bufev, short event)</div><div>{</div><div>    struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);</div><div><font color="#FF0000">    if (event &amp; EV_READ) {</font></div><div><font color="#FF0000">        if (event_del(&amp;bufev-&gt;ev_read) == -1)</font></div><div><font color="#FF0000">            return -1;</font></div><div><font color="#FF0000">    }//直接使bufferevent的事件ev_read变为非未决状态</font></div><div>    /* Don't actually disable the write if we are trying to connect. */</div><div>    if ((event &amp; EV_WRITE) &amp;&amp; ! bufev_p-&gt;connecting) {</div><div>        if (event_del(&amp;bufev-&gt;ev_write) == -1)</div><div>            return -1;</div><div>    }</div><div>    return 0;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_disable</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>bufferevent_disable(struct bufferevent *bufev, short event)</div><div>{   </div><div>    int r = 0;</div><div>    BEV_LOCK(bufev);</div><div>   <font color="#FF0000"> bufev-&gt;enabled &amp;= ~event;//清除EV_READ标志</font></div><div>    </div><div><font color="#FF0000">    if (bufev-&gt;be_ops-&gt;disable(bufev, event) &lt; 0)</font></div><div>        r = -1;</div><div>    if (r)</div><div>        event_debug((&quot;%s: cannot disable 0x%hx on %p&quot;, __func__, event, bufev));</div><div>    </div><div>    BEV_UNLOCK(bufev);</div><div>    return r;</div><div>}   </div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_run_eventcb_</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void</div><div>bufferevent_run_eventcb_(struct bufferevent *bufev, short what, int options)</div><div>{   </div><div>    /* Requires that we hold the lock and a reference */</div><div>    struct bufferevent_private *p = BEV_UPCAST(bufev);</div><div>    if (bufev-&gt;errorcb == NULL)</div><div>        return;</div><div>    if ((p-&gt;options|options) &amp; BEV_OPT_DEFER_CALLBACKS) {</div><div>        p-&gt;eventcb_pending |= what;</div><div>        p-&gt;errno_pending = EVUTIL_SOCKET_ERROR();</div><div>        SCHEDULE_DEFERRED(p);</div><div>    } else {</div><div>        <font color="#FF0000">bufev-&gt;errorcb(bufev, what, bufev-&gt;cbarg);</font></div><div>    }</div><div>}  </div></div><div><span style="font-weight: bold;">总结函数</span><span style="font-weight: bold;">bufferevent_readcb：</span></div><div><span style="font-weight: bold;">如果该回调的event只有EV_TIMEOUT，即默认，就算被触发，也什么也不做，直接返回。</span></div><div><span style="font-weight: bold;">如果设置了高水位，判断输入缓冲区的数据量是否大于高水位，如果大于了，就进入挂起状态并退出回调，该状态会使事件ev_read变为非未决状态。</span></div><div><span style="font-weight: bold;">否则就直接将内核收到的数据写入到输入缓冲区，最后调用用户的read回调函数处理数据。</span></div><div><br/></div><div><span style="font-weight: bold;">现在，只有一点，用户设置高水位，当数据量过大时，变为挂起，如何退出挂起状态并恢复ev_read回调函数？</span></div><div><br/></div><div><span style="font-weight: bold;">函数bufferevent_setwatermark</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void</div><div>bufferevent_setwatermark(struct bufferevent *bufev, short events,</div><div>    size_t lowmark, size_t highmark)</div><div>{</div><div>    struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">BEV_LOCK(bufev);//上锁</font></div><div>    <font color="#FF0000">if (events &amp; EV_WRITE) {</font></div><div><font color="#FF0000">        bufev-&gt;wm_write.low = lowmark;</font></div><div><font color="#FF0000">        bufev-&gt;wm_write.high = highmark;</font></div><div><font color="#FF0000">    }</font></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000">    if (events &amp; EV_READ) {</font></div><div><font color="#FF0000">        bufev-&gt;wm_read.low = lowmark;</font></div><div><font color="#FF0000">        bufev-&gt;wm_read.high = highmark;//设置水位</font></div><div><br/></div><div><br/></div><div>        <font color="#FF0000">if (highmark) {//如果高水位不为0</font></div><div><font color="#A8A8A8">            /* There is now a new high-water mark for read.</font></div><div><font color="#A8A8A8">               enable the callback if needed, and see if we should</font></div><div><font color="#A8A8A8">               suspend/bufferevent_wm_unsuspend. */</font></div><div><br/></div><div><br/></div><div>           <font color="#FF0000"> if (bufev_private-&gt;read_watermarks_cb == NULL) {//如果该回调不存在</font></div><div><font color="#FF0000">                bufev_private-&gt;read_watermarks_cb =</font></div><div><font color="#FF0000">                    evbuffer_add_cb(bufev-&gt;input,</font></div><div><font color="#FF0000">                            bufferevent_inbuf_wm_cb,</font></div><div><font color="#FF0000">                            bufev);//设置输入缓冲区的回调函数</font></div><div>            }</div><div>         <font color="#FF0000">   evbuffer_cb_set_flags(bufev-&gt;input,</font></div><div><font color="#FF0000">                      bufev_private-&gt;read_watermarks_cb,</font></div><div><font color="#FF0000">                      EVBUFFER_CB_ENABLED|EVBUFFER_CB_NODEFER);//设置标志</font></div><div><br/></div><div><br/></div><div>           <font color="#FF0000"> if (evbuffer_get_length(bufev-&gt;input) &gt;= highmark)</font></div><div><font color="#FF0000">                bufferevent_wm_suspend_read(bufev);</font></div><div><font color="#FF0000">            else if (evbuffer_get_length(bufev-&gt;input) &lt; highmark)</font></div><div><font color="#FF0000">                bufferevent_wm_unsuspend_read(bufev);//由于水位设置可能在运行过程中，过程中缓冲区也可能高于高水位，也可能由于水位的设置使其低于高水位，因此调用相应的挂起和恢复操作</font></div><div>        } else {</div><div>            /* There is now no high-water mark for read. */</div><div>            if (bufev_private-&gt;read_watermarks_cb)</div><div>                evbuffer_cb_clear_flags(bufev-&gt;input,</div><div>                    bufev_private-&gt;read_watermarks_cb,</div><div>                    EVBUFFER_CB_ENABLED);</div><div>            bufferevent_wm_unsuspend_read(bufev);</div><div>        }</div><div>    }</div><div>    <font color="#FF0000">BEV_UNLOCK(bufev);//释放锁</font></div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">evbuffer_add_cb</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct evbuffer_cb_entry *</div><div>evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)</div><div>{                   </div><div>    struct evbuffer_cb_entry *e;</div><div>    if (! (e = mm_calloc(1, sizeof(struct evbuffer_cb_entry))))</div><div>        return NULL;</div><div>    EVBUFFER_LOCK(buffer);</div><div>    e-&gt;cb.cb_func = cb;</div><div>    e-&gt;cbarg = cbarg;</div><div>    e-&gt;flags = EVBUFFER_CB_ENABLED;</div><div>    LIST_INSERT_HEAD(&amp;buffer-&gt;callbacks, e, next);</div><div>    EVBUFFER_UNLOCK(buffer);</div><div>    return e;</div><div>}   </div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_inbuf_wm_cb</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void</div><div>bufferevent_inbuf_wm_cb(struct evbuffer *buf,</div><div>    const struct evbuffer_cb_info *cbinfo,</div><div>    void *arg)</div><div>{</div><div>    struct bufferevent *bufev = arg;</div><div>    size_t size;</div><div><br/></div><div>    size = evbuffer_get_length(buf);</div><div><br/></div><div><font color="#FF0000">    if (size &gt;= bufev-&gt;wm_read.high)</font></div><div><font color="#FF0000">        bufferevent_wm_suspend_read(bufev);</font></div><div><font color="#FF0000">    else</font></div><div><font color="#FF0000">        bufferevent_wm_unsuspend_read(bufev);</font></div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">针对此处的情况，只有设置了高水位的情况下，事件才会被挂起。</span></div><div><span style="font-weight: bold;">高水位的设置，回向输入缓冲区结构添加一个回调函数，该函数在缓冲区中数据量发生变化时，会被调用，如果数据超过高水位值，则事件被挂起，只有再到数据小于高水位值时，ev_read事件才会再次被添加到event_base上运行。</span></div><hr/><div><br/></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_writecb</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void</div><div>bufferevent_writecb(evutil_socket_t fd, short event, void *arg)</div><div>{</div><div><font color="#FF0000">    struct bufferevent *bufev = arg;</font></div><div><font color="#FF0000">    struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);</font></div><div>    int res = 0;</div><div>    short what = BEV_EVENT_WRITING;</div><div>    int connected = 0;</div><div>    ev_ssize_t atmost = -1;</div><div><br/></div><div><br/></div><div><font color="#FF0000">    bufferevent_incref_and_lock_(bufev);</font></div><div><br/></div><div><br/></div><div>    if (event == EV_TIMEOUT) {</div><div>        /* Note that we only check for event==EV_TIMEOUT. If</div><div>         * event==EV_TIMEOUT|EV_WRITE, we can safely ignore the</div><div>         * timeout, since a read has occurred */</div><div>        what |= BEV_EVENT_TIMEOUT;</div><div>        goto error;</div><div>    }</div><div>   <font color="#FF0000"> if (bufev_p-&gt;connecting) {</font></div><div><font color="#FF0000">        int c = evutil_socket_finished_connecting_(fd);//c为0，说明未连接上，c为1，说明连接成功，c为-1说明连接出错或断开</font></div><div><font color="#FF0000">        /* we need to fake the error if the connection was refused</font></div><div><font color="#FF0000">         * immediately - usually connection to localhost on BSD */</font></div><div><font color="#FF0000">        if (bufev_p-&gt;connection_refused) {</font></div><div><font color="#FF0000">            bufev_p-&gt;connection_refused = 0;</font></div><div><font color="#FF0000">            c = -1;//拒绝连接</font></div><div><font color="#FF0000">        }</font></div><div><br/></div><div><br/></div><div>   <font color="#FF4635">     if (c == 0)</font></div><div><font color="#FF4635">            goto done;//未连接上，继续连接</font></div><div><br/></div><div><br/></div><div>        bufev_p-&gt;connecting = 0;</div><div>        <font color="#FF0000">if (c &lt; 0) {</font></div><div><font color="#FF0000">            event_del(&amp;bufev-&gt;ev_write);</font></div><div><font color="#FF0000">            event_del(&amp;bufev-&gt;ev_read);</font></div><div><font color="#FF0000">            bufferevent_run_eventcb_(bufev, BEV_EVENT_ERROR, 0);</font></div><div><font color="#FF0000">            goto done;//连接出错移除事件并调用错误处理回调</font></div><div>        } else {</div><div>            <font color="#FF0000">connected = 1;</font></div><div><font color="#FF0000">            bufferevent_socket_set_conn_address_fd_(bufev, fd);</font></div><div>#ifdef _WIN32</div><div>            if (BEV_IS_ASYNC(bufev)) {</div><div>                event_del(&amp;bufev-&gt;ev_write);</div><div>                bufferevent_async_set_connected_(bufev);</div><div>                bufferevent_run_eventcb_(bufev,</div><div>                        BEV_EVENT_CONNECTED, 0);</div><div>                goto done;</div><div>            }</div><div>#endif</div><div>            <font color="#FF0000">bufferevent_run_eventcb_(bufev,</font></div><div><font color="#FF0000">                    BEV_EVENT_CONNECTED, 0);</font></div><div><font color="#FF0000">            if (!(bufev-&gt;enabled &amp; EV_WRITE) ||</font></div><div><font color="#FF0000">                bufev_p-&gt;write_suspended) {</font></div><div><font color="#FF0000">                event_del(&amp;bufev-&gt;ev_write);</font></div><div><font color="#FF0000">                goto done;//连接成功，也会调用错误处理函数，如果事件处于挂起状态，撤下事件</font></div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> atmost = bufferevent_get_write_max_(bufev_p);//获取最大容量</font></div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> if (bufev_p-&gt;write_suspended)</font></div><div><font color="#FF0000">        goto done;//处于挂起状态goto done</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if (evbuffer_get_length(bufev-&gt;output)) {//输出缓冲区不为空</font></div><div>       <font color="#FF0000"> evbuffer_unfreeze(bufev-&gt;output, 1);//解冻</font></div><div><font color="#FF0000">        res = evbuffer_write_atmost(bufev-&gt;output, fd, atmost);//尽可能写入数据到socket</font></div><div><font color="#FF0000">        evbuffer_freeze(bufev-&gt;output, 1);//冻结</font></div><div>        if (res == -1) {</div><div>            int err = evutil_socket_geterror(fd);</div><div>            if (EVUTIL_ERR_RW_RETRIABLE(err))</div><div>                goto reschedule;</div><div>            what |= BEV_EVENT_ERROR;</div><div>        } else if (res == 0) {</div><div>            /* eof case</div><div>               XXXX Actually, a 0 on write doesn't indicate</div><div>               an EOF. An ECONNRESET might be more typical.</div><div>             */</div><div>            what |= BEV_EVENT_EOF;</div><div>        }</div><div>        if (res &lt;= 0)</div><div>            goto error;</div><div>   <font color="#000000">     bufferevent_decrement_write_buckets_(bufev_p, res);</font></div><div>    }</div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> if (evbuffer_get_length(bufev-&gt;output) == 0) {</font></div><div><font color="#FF0000">        event_del(&amp;bufev-&gt;ev_write);</font></div><div><font color="#FF0000">    }//输入缓冲区为空，撤销写事件</font></div><div><br/></div><div><br/></div><div>    /*</div><div>     * Invoke the user callback if our buffer is drained or below the</div><div>     * low watermark.</div><div>     */</div><div>   <font color="#FF0000"> if (res || !connected) {</font></div><div><font color="#FF0000">        bufferevent_trigger_nolock_(bufev, EV_WRITE, 0);</font></div><div><font color="#FF0000">    }//调用用户写回调函数</font></div><div><br/></div><div><br/></div><div>    goto done;</div><div><br/></div><div><br/></div><div>reschedule:</div><div>    if (evbuffer_get_length(bufev-&gt;output) == 0) {</div><div>        event_del(&amp;bufev-&gt;ev_write);</div><div>    }</div><div>    goto done;</div><div><br/></div><div><br/></div><div>error:</div><div> <font color="#FF0000">   bufferevent_disable(bufev, EV_WRITE);//撤销写事件</font></div><div><font color="#FF0000">    bufferevent_run_eventcb_(bufev, what, 0);//调用用户的错误回调</font></div><div><br/></div><div><br/></div><div>done:</div><div>    bufferevent_decref_and_unlock_(bufev);</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">evutil_socket_finished_connecting_</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/* Check whether a socket on which we called connect() is done</div><div>   connecting. Return 1 for connected, 0 for not yet, -1 for error.  In the</div><div>   error case, set the current socket errno to the error that happened during</div><div>   the connect operation. */</div><div>int</div><div>evutil_socket_finished_connecting_(evutil_socket_t fd)</div><div>{       </div><div>    int e;</div><div>    ev_socklen_t elen = sizeof(e);</div><div>        </div><div>    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&amp;e, &amp;elen) &lt; 0)</div><div>        return -1;</div><div>        </div><div>    if (e) {</div><div>     <font color="#FF0000">   if (EVUTIL_ERR_CONNECT_RETRIABLE(e))</font></div><div><font color="#FF0000">            return 0;</font></div><div><font color="#FF0000">        EVUTIL_SET_SOCKET_ERROR(e);</font></div><div><font color="#FF0000">        return -1;</font></div><div>    }       </div><div><br/></div><div><font color="#FF0000">    return 1;</font></div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_socket_set_conn_address_fd_</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void</div><div>bufferevent_socket_set_conn_address_fd_(struct bufferevent *bev,</div><div>    evutil_socket_t fd)</div><div>{</div><div>    struct bufferevent_private *bev_p = BEV_UPCAST(bev);</div><div><br/></div><div><br/></div><div>    socklen_t len = sizeof(bev_p-&gt;conn_address);</div><div><br/></div><div><br/></div><div>    struct sockaddr *addr = (struct sockaddr *)&amp;bev_p-&gt;conn_address;</div><div>    if (addr-&gt;sa_family != AF_UNSPEC)</div><div>        getpeername(fd, addr, &amp;len);</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">读事件和写事件的触发是不一样的，读事件在内核缓冲区收到数据时，就会被触发。</span></div><div><span style="font-weight: bold;">而event_base上注册的写事件则是不断的被触发，这样会消耗大量的时间，而libevent会这样做：写事件会被不断触发，但是要向缓冲区写入数据，条件是网络已经连接，所以写事件首先判断网络是否连接，只有在连接成功的情况下，并且输出缓冲区的evbuffer中有用户添加的数据时，才会进行像socket写入数据的操作。如果还没连接上网络，则继续进行，如果连接出错，释放所有资源。而当输出缓冲区evbuffer中并不存在数据时，会进行一个操作：将写事件从event_base的循环中取消。那接下来还有一个问题，当输出缓冲区没有数据时，写事件被从event_base删除，当用户向输出缓冲区添加数据时，此时写事件如何再次被添加到event_base中继续运行呢？</span></div><div><br/></div><div><span style="font-weight: bold;">在bufferevent_socket_new进行初始化的过程中，有一个类似读事件设置高水位时为输入缓冲区添加一个回调的操作：</span><span style="font-weight: bold;">evbuffer_add_cb(bufev-&gt;output, bufferevent_socket_outbuf_cb, bufev);</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void</div><div>bufferevent_socket_outbuf_cb(struct evbuffer *buf,</div><div>    const struct evbuffer_cb_info *cbinfo,</div><div>    void *arg)</div><div>{</div><div>    struct bufferevent *bufev = arg;</div><div>    struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);</div><div><br/></div><div><br/></div><div>  <font color="#FF0000">  if (cbinfo-&gt;n_added &amp;&amp;</font></div><div><font color="#FF0000">        (bufev-&gt;enabled &amp; EV_WRITE) &amp;&amp;</font></div><div><font color="#FF0000">        !event_pending(&amp;bufev-&gt;ev_write, EV_WRITE, NULL) &amp;&amp;</font></div><div><font color="#FF0000">        !bufev_p-&gt;write_suspended) {</font></div><div>        /* Somebody added data to the buffer, and we would like to</div><div>         * write, and we were not writing.  So, start writing. */</div><div>        if (<font color="#FF0000">bufferevent_add_event_(&amp;bufev-&gt;ev_write, &amp;bufev-&gt;timeout_write)</font> == -1) {</div><div>            /* Should we log this? */</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">当输出缓冲区有数据时，并且buffevent使能了读标志，处于非挂起状态，将会添加写事件到event_base。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">bufferevent_socket_connect</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>bufferevent_socket_connect(struct bufferevent *bev,</div><div>    const struct sockaddr *sa, int socklen)</div><div>{   </div><div>    struct bufferevent_private *bufev_p = BEV_UPCAST(bev);</div><div>        </div><div>    evutil_socket_t fd;</div><div>    int r = 0;</div><div>    int result=-1;</div><div>    int ownfd = 0;</div><div>    </div><div>   <font color="#FF0000"> bufferevent_incref_and_lock_(bev);//上锁</font></div><div>    </div><div>    <font color="#FF0000">fd = bufferevent_getfd(bev);//获取传入的文件描述符</font></div><div>   <font color="#FF0000"> if (fd &lt; 0) {</font></div><div><font color="#FF0000">        if (!sa)</font></div><div><font color="#FF0000">            goto done;</font></div><div><font color="#FF0000">        fd = evutil_socket_(sa-&gt;sa_family,</font></div><div><font color="#FF0000">            SOCK_STREAM|EVUTIL_SOCK_NONBLOCK, 0);</font></div><div><font color="#FF0000">        if (fd &lt; 0)</font></div><div><font color="#FF0000">            goto freesock;</font></div><div><font color="#FF0000">        ownfd = 1;</font></div><div><font color="#FF0000">    }//如果传入的文件描述符为负，创建文件描述符，并设置非阻塞</font></div><div>    if (sa) {</div><div>#ifdef _WIN32</div><div>        if (bufferevent_async_can_connect_(bev)) {</div><div>            bufferevent_setfd(bev, fd);</div><div>            r = bufferevent_async_connect_(bev, fd, sa, socklen);</div><div>            if (r &lt; 0)</div><div>                goto freesock;</div><div>            bufev_p-&gt;connecting = 1;</div><div>            result = 0;</div><div>            goto done;</div><div>        } else</div><div>#endif</div><div> <font color="#FF0000">       r = evutil_socket_connect_(&amp;fd, sa, socklen);</font></div><div><font color="#FF0000">        if (r &lt; 0)</font></div><div><font color="#FF0000">            goto freesock;</font></div><div><font color="#FF0000">    }//建立socket连接</font></div><div>#ifdef _WIN32</div><div>    /* ConnectEx() isn't always around, even when IOCP is enabled.</div><div>     * Here, we borrow the socket object's write handler to fall back</div><div>     * on a non-blocking connect() when ConnectEx() is unavailable. */</div><div>    if (BEV_IS_ASYNC(bev)) {</div><div>        event_assign(&amp;bev-&gt;ev_write, bev-&gt;ev_base, fd,</div><div>            EV_WRITE|EV_PERSIST|EV_FINALIZE, bufferevent_writecb, bev);</div><div>    }</div><div>#endif</div><div><font color="#FF0000">    bufferevent_setfd(bev, fd);//添加文件描述符到bufferevent的两个event设置监听的fd</font></div><div>   <font color="#FF0000"> if (r == 0) {</font></div><div><font color="#FF0000">        if (! be_socket_enable(bev, EV_WRITE)) {</font></div><div><font color="#FF0000">            bufev_p-&gt;connecting = 1;</font></div><div><font color="#FF0000">            result = 0;</font></div><div><font color="#FF0000">            goto done;</font></div><div><font color="#FF0000">        }//未连接上，添加可写事件到event_base</font></div><div>    } else if (r == 1) {</div><div>      <font color="#FF0000">  /* The connect succeeded already. How very BSD of it. */</font></div><div><font color="#FF0000">        result = 0;</font></div><div><font color="#FF0000">        bufev_p-&gt;connecting = 1;</font></div><div><font color="#FF0000">        bufferevent_trigger_nolock_(bev, EV_WRITE, BEV_OPT_DEFER_CALLBACKS);//连接成功，手动激活写事件</font></div><div>    } else {</div><div> <font color="#FF0000">       /* The connect failed already.  How very BSD of it. */</font></div><div><font color="#FF0000">        result = 0;</font></div><div><font color="#FF0000">        bufferevent_run_eventcb_(bev, BEV_EVENT_ERROR, BEV_OPT_DEFER_CALLBACKS);</font></div><div><font color="#FF0000">        bufferevent_disable(bev, EV_WRITE|EV_READ);//连接出错，调用错误处理回调，并禁用读写事件</font></div><div>    }</div><div><br/></div><div><br/></div><div>    goto done;</div><div><br/></div><div><br/></div><div>freesock:</div><div>    if (ownfd)</div><div>        evutil_closesocket(fd);</div><div>done:</div><div>    bufferevent_decref_and_unlock_(bev);</div><div>    return result;</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 