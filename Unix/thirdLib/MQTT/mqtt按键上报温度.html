<html>
<head>
  <title>mqtt按键上报温度</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="526"/>
<h1>mqtt按键上报温度</h1>

<div>
<span><div>subscribe端运行在PC上，通过订阅获取开发板温度等消息。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;stdbool.h&gt;</div><div>#include &lt;stdint.h&gt;</div><div>#include &lt;stdio.h&gt;</div><div>#include &lt;sys/time.h&gt;</div><div>#include &lt;unistd.h&gt;</div><div>#include &lt;mosquitto.h&gt;</div><div>#include &lt;msgsps_common.h&gt;</div><div><br/></div><div>#define HOST &quot;服务器ip&quot;</div><div>#define PORT 1883</div><div>#define KEEPALIVE 60</div><div>#define TOPIC &quot;temp&quot;</div><div><br/></div><div><br/></div><div>void my_connect_callback(struct mosquitto *mosq, void *userdata, int result)</div><div>{</div><div>    printf(&quot;connected\n&quot;);</div><div>/*    if(!result)</div><div>    {</div><div>        mosquitto_subscribe(mosq,NULL,TOPIC,0);</div><div>    }*/</div><div>}</div><div><br/></div><div><br/></div><div>void my_disconnect_callback(struct mosquitto *mosq, void *userdata, int result)</div><div>{</div><div>    printf(&quot;disconnected\n&quot;);</div><div>}</div><div><br/></div><div><br/></div><div>void my_message_callback(struct mosquitto *mosq, void *userdata, const struct mosquitto_message *message)</div><div>{</div><div>    if(message-&gt;payloadlen)</div><div>    {</div><div>        printf(&quot;revieve topic message [%s]\n&quot;,(char *)message-&gt;payload);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>int main()</div><div>{</div><div>    struct mosquitto *mosq;</div><div>    mosquitto_lib_init();</div><div>    mosq = mosquitto_new(NULL, true, NULL);</div><div>    mosquitto_connect_callback_set(mosq,my_connect_callback);</div><div>    mosquitto_disconnect_callback_set(mosq,my_disconnect_callback);</div><div>    mosquitto_message_callback_set(mosq,my_message_callback);</div><div><br/></div><div><br/></div><div>    if(mosquitto_connect(mosq,HOST,PORT,KEEPALIVE))</div><div>    {</div><div>        printf(&quot;mosquitto_connect failure\n&quot;);</div><div>        return -1;</div><div>    }</div><div><br/></div><div><br/></div><div>    mosquitto_subscribe(mosq,NULL,TOPIC,0);</div><div>    mosquitto_loop_forever(mosq,-1,1);</div><div><br/></div><div><br/></div><div>    mosquitto_destroy(mosq);</div><div>    mosquitto_lib_cleanup();</div><div>    return 0;</div><div><br/></div><div>}</div></div><div><br/></div><div>publish端，运行在开发板上，读取开发板上ds18b20温度传感器上的温度，并每30秒进行一次温度的读取发布，同时使能linux内核自带的input子系统的按键驱动，并设置线程监听开发板按键，按键按下给出按下按键的标志并进行一次温度的读取和发布。使用mqtt通信，将broker运行在另一主机上，订阅和发布都连接到这台服务器的1883号端口，因此开发板还需要连接到网络，使用自带有线网卡或USB无线网卡都可以实现网络连接。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;stdbool.h&gt;</div><div>#include &lt;stdint.h&gt;</div><div>#include &lt;stdio.h&gt;</div><div>#include &lt;sys/time.h&gt;</div><div>#include &lt;unistd.h&gt;</div><div>#include &lt;mosquitto.h&gt;</div><div>#include &lt;string.h&gt;</div><div>#include &lt;stdlib.h&gt;</div><div>#include &lt;linux/input.h&gt;</div><div>#include &lt;sys/types.h&gt;</div><div>#include &lt;sys/stat.h&gt;</div><div>#include &lt;fcntl.h&gt;</div><div>#include &lt;msgsps_common.h&gt;</div><div>#include &lt;dirent.h&gt;</div><div>#include &lt;pthread.h&gt;</div><div>#include &lt;errno.h&gt;</div><div><br/></div><div><br/></div><div>#define HOST &quot;服务器ip&quot;</div><div>#define PORT 1883</div><div>#define KEEPALIVE 60</div><div>#define TOPIC &quot;temp&quot;</div><div>#define EV_PRESS 1</div><div>#define PATH_1 &quot;/dev/input/event0&quot;</div><div>#define PATH_2 &quot;/sys/devices/w1 bus master/&quot;</div><div><br/></div><div><br/></div><div>int get_temperature(char ch_temp[16])</div><div>{</div><div>    int fd_temp;</div><div>    int result=0;</div><div>    float temp;</div><div>    DIR *dirp=NULL;</div><div>    char *ptr=NULL;</div><div>    struct dirent *direntp;</div><div>    char path[128]=PATH_2;</div><div>    char data[128]={0};</div><div>    if((dirp=opendir(PATH_2))==NULL)</div><div>    {</div><div>        printf(&quot;open %s failure\n&quot;,PATH_2);</div><div>        return -1;</div><div>    }</div><div>    while((direntp=readdir(dirp))!=NULL)</div><div>    {</div><div>        if(strstr(direntp-&gt;d_name,&quot;28-&quot;))</div><div>        {</div><div>            strncat(path,direntp-&gt;d_name,sizeof(path));</div><div>            result=1;</div><div>        }</div><div>    }</div><div>    if(!result)</div><div>    {</div><div>        printf(&quot;can not find ds18b20 in %s \n&quot;,PATH_2);</div><div>        return -1;</div><div>    }</div><div>    strncat(path,&quot;/w1_slave&quot;,sizeof(path));</div><div>    if((fd_temp=open(path,O_RDONLY))&lt;0)</div><div>    {</div><div>        printf(&quot;open %s failure\n&quot;,path);</div><div>        return -1;</div><div>    }</div><div>    if(read(fd_temp,data,sizeof(data))&lt;0)</div><div>    {</div><div>        printf(&quot;read %s failure\n&quot;,path);</div><div>        return -1;</div><div>    }</div><div>    if((ptr=strstr(data,&quot;t=&quot;))!=NULL)</div><div>    {</div><div>        ptr+=2;</div><div>        if(!ptr)</div><div>        {</div><div>            printf(&quot;read temperature failure\n&quot;);</div><div>            return -1;</div><div>        }</div><div>        temp=atof(ptr)/1000;</div><div>        snprintf(ch_temp,16,&quot;%f&quot;,temp);</div><div>    }</div><div>    return 0;</div><div>}</div><div><br/></div><div><br/></div><div>void my_connect_callback(struct mosquitto *mosq, void *obj, int rc)</div><div>{</div><div>        printf(&quot;connected\n&quot;);</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>void my_disconnect_callback(struct mosquitto *mosq, void *obj, int result)</div><div>{</div><div>        printf(&quot;disconnect\n&quot;);</div><div>}</div><div><br/></div><div><br/></div><div>void *button_worker(void *args)</div><div>{</div><div>    int loop;</div><div>    struct mosquitto *mosq;</div><div>//    struct mosquitto *arg=(struct mosquitto*)args;</div><div>    mosquitto_lib_init();</div><div>    mosq = mosquitto_new(NULL, true, NULL);</div><div>    mosquitto_connect_callback_set(mosq,my_connect_callback);</div><div>    mosquitto_disconnect_callback_set(mosq,my_disconnect_callback);</div><div>    mosquitto_connect(mosq,HOST,PORT,KEEPALIVE);</div><div>    loop=mosquitto_loop_start(mosq);</div><div>    if(loop!=MOSQ_ERR_SUCCESS)</div><div>    {</div><div>        printf(&quot;mosquitto_loop_start failure\n&quot;);</div><div>        pthread_exit(NULL);</div><div>    }</div><div>    int fd;</div><div>    struct input_event ev_key;</div><div>    char temp[16]={0};</div><div>    fd=open(PATH_1,666);</div><div>    if(fd&lt;0)</div><div>    {</div><div>        printf(&quot;open %s failure\n&quot;,PATH_1);</div><div>        pthread_exit(NULL);</div><div>    }</div><div>    while(1)</div><div>    {</div><div>        read(fd,&amp;ev_key,sizeof(struct input_event));</div><div>        if(ev_key.type==EV_KEY &amp;&amp; ev_key.value==EV_PRESS)</div><div>        {</div><div>            if(!get_temperature(temp))</div><div>            {</div><div>                pthread_exit(NULL);</div><div>            }</div><div>            int i=mosquitto_publish(mosq,NULL,TOPIC,16,&amp;temp,0,0);</div><div>            if(i!=0)</div><div>            {</div><div>                printf(&quot;thread mosquitto_publish failure\n&quot;);</div><div>                pthread_exit(NULL);</div><div>            }</div><div>            printf(&quot;key %d pressed,topic [%s] message [%s] publish successfully\n&quot;,ev_key.code,TOPIC,temp);</div><div>        }</div><div>    }</div><div>    close(fd);</div><div>    return NULL;</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>int main(void)</div><div>{</div><div>    struct mosquitto *mosq;</div><div>    int loop=0;</div><div>    int fd_key;</div><div>    int fd_temp;</div><div>    struct input_event ev_key;</div><div>    char temp[16]={0};</div><div>    pthread_t tid;</div><div>    pthread_attr_t attr;</div><div>    if(pthread_attr_init(&amp;attr)&lt;0)</div><div>    {</div><div>        printf(&quot;pthread_attr_init error\n&quot;);</div><div>        return -1;</div><div>    }</div><div>    if(pthread_attr_setstacksize(&amp;attr,120*1024)&lt;0)</div><div>    {</div><div>        printf(&quot;pthread_attr_setstacksize error\n&quot;);</div><div>        return -1;</div><div>    }</div><div>    if(pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED)&lt;0)</div><div>    {</div><div>        printf(&quot;pthread_attr_setstackstate error\n&quot;);</div><div>        return -1;</div><div>    }</div><div><br/></div><div><br/></div><div>    mosquitto_lib_init();</div><div>    mosq = mosquitto_new(NULL, true, NULL);</div><div>    mosquitto_connect_callback_set(mosq,my_connect_callback);</div><div>    mosquitto_disconnect_callback_set(mosq,my_disconnect_callback);</div><div>    mosquitto_connect(mosq,HOST,PORT,KEEPALIVE);</div><div><br/></div><div><br/></div><div>    loop=mosquitto_loop_start(mosq);</div><div>    if(loop!=MOSQ_ERR_SUCCESS)</div><div>    {</div><div>        printf(&quot;mosquitto_loop_start failure\n&quot;);</div><div>        return -1;</div><div>    }</div><div>    sleep(1);</div><div>    pthread_create(&amp;tid,&amp;attr,button_worker,NULL);</div><div>    printf(&quot;Thread %ld create successfully\n&quot;,(long)tid);</div><div>    while(1)</div><div>    {</div><div>        if(!get_temperature(temp))</div><div>        {</div><div>            return -1;</div><div>        }</div><div>        int i=mosquitto_publish(mosq,NULL,TOPIC,16,&amp;temp,0,0);</div><div>        if(i!=0)</div><div>        {</div><div>            printf(&quot;mosquitto_publish failure:%s\n&quot;,strerror(errno));</div><div>            return -1;</div><div>        }</div><div>        printf(&quot;topic [%s] message [%s] publish successfully\n&quot;,TOPIC,temp);</div><div>        sleep(30);</div><div><br/></div><div><br/></div><div>    }</div><div>    mosquitto_destroy(mosq);</div><div>    mosquitto_lib_cleanup();</div><div>    return 0;</div><div>}</div></div><div><span style="font-size: 12pt;">如果需要密码登陆可修改mosquitto.conf配置文件，当然，如果想要加密，mqtt本来自带加密，也可以使用openssl库的加密算法去进行加密。</span></div></span>
</div></body></html> 