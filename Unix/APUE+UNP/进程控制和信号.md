# 进程控制和信号

## assert

断言 assert函数:

```cpp
#include "assert.h"
void assert( int expression );
```

assert 的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向 stderr 打印一条出错信息,然后通过调用 abort 来终止程序运行。
在调试时使用，可以通过在包含 #include 的语句之前插入 #define NDEBUG 来禁用 assert 调用：

```cpp
#define NDDEBUG
#include <assert.h>
```

## 进程控制

`pstree`命令可直接输出系统总体的进程树状图
`pstree -p`输出树状图中会加上对应进程的pid



`ps -xj`输出进程控制打印：

```shell
zh@zh-virtual-machine:~$ ps -xj
PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
3243  3244  3244  3244 pts/0     3413 Ss    1000   0:00 -bash
3188  3314  3188  3188 ?           -1 S     1000   0:00 sshd: zh@notty
3314  3315  3315  3315 ?           -1 Ss    1000   0:00 /usr/lib/openssh/sftp-server
3244  3413  3413  3244 pts/0     3413 R+    1000   0:00 ps -xj
```

PPID:父进程pid
PID；当前进程pid
PGID：进程组组id
SID：会话ID，当开启一个会话后，此会话中所有进程拥有相同的会话ID ，此会话ID中的进程根据进程组分为1个前台进程组和若干个后台进程组
TTY:
使用tty命令查看当前使用的dev下的设备：
本地直连（主机下输入ctrl +alt + f[1-6]）:dev/tty[1-6]，（ctrl + alt + f7重新进入GUI）
网络登录（如sshd,telnet）：/dev/pts/n

TGPID：控制终端ID,为-1代表此进程没有控制终端，非0时代表有一个进程此时占领控制终端，此时控制终端ID为此进程的pid

在bash下直接运行的程序，一般都拥有自己的进程pid和进程组id。
当bash下的程序调用fork时，子进程和父进程有相同组ID。
当在bash在使用管道命令时，管道连接的两个进程都是bash的子进程，拥有相同的组ID：

```shell
  PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
  4054  4166  4166  4054 pts/12    4166 R+    1000   0:00 ps -xj
4054  4167  4166  4054 pts/12    4166 S+    1000   0:00 cat
```

后台作业被放在后台进程组，如果后台作业试图读控制终端，则会产生信号SIGTTIN，默认停止此进程的运行。（一般如果后台进程写控制终端，也可能收到SIGTTOU信号，通常编写大型程序，会屏蔽SIGTIN，SIGTTOU和SIGPIPE）
此时执行fg命令（发送信号SIGCONT到此进程）可以将进程切换到前台，使进程正常运行。
孤儿进程是父进程fork出来子进程后，如果父进程先退出，子进程继续运行，子进程将变成孤儿进程。
孤儿进程拥有和父进程一样的进程组，当被init进程收养后，孤儿进程的父进程pid变为1，但是进程组id不会改变

```shell
4054  4508  4508  4054 pts/12    4508 S+    1000   0:00 ./test_fork
4508  4509  4508  4054 pts/12    4508 R+    1000   0:03 ./test_fork
after parent process exit:
1  4509  4508  4054 pts/12    4054 R     1000   0:17 ./test_fork
```

`CTRL+C(SIGINT)   CTRL+\(SIGQUIT) CTRL+Z(SIGTSTP)`信号会发送到前台进程组中所有进程
当一个会话结束关闭时，会将SIGHUP信号送至控制进程（即会话期首进程，通常是bash（ps -xj查看到的会话ID和进程pid相同的进程））,
控制进程将发送SIGHUP信号到所有会话ID为控制进程的进程组。（当进程的父进程是init时，不会发送SIGHUP到此进程组（ubuntu14.04））
通知此会话下的所有进程退出，然后发送SIGHUP信号给自己，bash退出。

nohup命令+可执行程序，可以让执行程序屏蔽SIGHUP信号，当控制终端被关闭是，此进程不会被杀死，而成为init进程的子进程
使用strace命令跟踪信号：
`strace -e trace=signal -p pid`
jobs查看后台运行进程或停止运行进程和其[jobid]，fg + [jobid]可以将后台进程切换到前台运行
fork + setsid可以使子进程成为新会话首进程。在操作的会话被关闭时，此进程不会被杀死，而是成为init进程的子进程，当然其TGPID将是-1因为其没有控制终端
kill(1)命令和kill( 2 )函数只是将一个信号送给一个进程或进程组。



## 信号

```cpp
zh@zh-virtual-machine:~$ kill -l
1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。

1) SIGHUP
本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。

登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也能继续下载。

此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。

2) SIGINT
程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。

3) SIGQUIT
和SIGINT类似, 但由QUIT字符(通常是Ctrl-/)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。

4) SIGILL
执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。

5) SIGTRAP
由断点指令或其它trap指令产生. 由debugger使用。

6) SIGABRT
调用abort函数生成的信号。

7) SIGBUS
非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。

8) SIGFPE
在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。

9) SIGKILL
用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。

10) SIGUSR1
留给用户使用

11) SIGSEGV
试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.

12) SIGUSR2
留给用户使用

13) SIGPIPE
管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。

14) SIGALRM
时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.

15) SIGTERM
程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。

17) SIGCHLD
子进程结束时, 父进程会收到这个信号。

如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。

18) SIGCONT
让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符

19) SIGSTOP
停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.

20) SIGTSTP
停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号

21) SIGTTIN
当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.

22) SIGTTOU
类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.

23) SIGURG
有"紧急"数据或out-of-band数据到达socket时产生.

24) SIGXCPU
超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。

25) SIGXFSZ
当进程企图扩大文件以至于超过文件大小资源限制。

26) SIGVTALRM
虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.

27) SIGPROF
类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.

28) SIGWINCH
窗口大小改变时发出.

29) SIGIO
文件描述符准备就绪, 可以开始进行输入/输出操作.

30) SIGPWR
Power failure

31) SIGSYS
非法的系统调用。

在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP
不能恢复至默认动作的信号有：SIGILL,SIGTRAP
默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ
默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM
默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU
默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH
SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞。



### signal函数

```cpp
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

第二个参数为信号处理函数，但是可以取以下宏：

```cpp
#define SIG_ERR (void (*)())-1
#define SIG_DFL (void (*)())0
#define SIG_IGN (void (*)())1
```

SIG_ERR为出错返回值，后两者可作为参数，将作为参数时，signal执行成功返回值也是参数值

调用exec函数将把所有信号都置为默认动作。
fork出的子进程继承父进程的信号处理方式。

信号会中断慢速的系统调用如读取不到数据的read，pause，wait，ioctl ，IPC系列函数等等。被中断的系统调用会设置errno为EINTR。

可重入函数也必须在信号发生，处理，返回后保持一致。（调用malloc，静态数据结构的函数，就不可重入）。

### kill函数

```cpp
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int signo) ;
```

pid>0将信号发送给pid进程
pid<0信号发送给pid绝对值对应的进程组，而且发送进程有许可权向其发送信号的所有进程（推测发送给init进程的直接子进程不可以）
pid ==0 发送给进程组id等于当前进程的进程组，而且发送进程有许可权向其发送信号的所有进程。
pid == -1未定义

kill命令：
kill pid 发送SIGTERM信号到pid进程
kill -signo pid 发送signo信号到pid进程，signo为数字

### alarm函数

```cpp
#include <unistd.h>
unsigned int alarm(unsigned seconds) ;
```

定时器函数，函数调用后seconds秒后发送SIGALRM信号到此进程，默认终止进程。
每个进程只有一个定时器，在前一个alarm未超时时再次调用alarm会更新定制器时间，并返回前一次剩余时间。
alarm(0)返回上一次alarm操作的剩余时间，除此之外不做任何事。

### pause函数

使进程挂起，期间不做任何事，直到捕捉到一个信号。信号处理程序返回后，pause返回-1, errno = EINTR



### 信号集系列函数

```cpp
#include <signal.h>
int sigemptyset(sigset_t set*);  //初始化由set指向的信号集，使排除其中所有信号
int sigfillset(sigset_t set* );  //初始化由set指向的信号集，使其包括所有信号
int sigaddset(sigset_t set*, int signo); //将一个信号添加到现存集中
int sigdelset(sigset_t set*,int signo);//从信号集中删除一个信号
```


四个函数返回：若成功则为0，若出错则为-1

```cpp
int sigismember(const sigset_t set*, int signo); 测试一指定位
```


返回：若真则为1，若假则为0

```cpp
#include <signal.h>
int sigprocmask(int how, const sigset_t set*, sigset_t *oset) ;
```


返回：若成功则为0，若出错则为-1
oset是非空指针，进程的当前信号屏蔽字通过oset返回,其次若set是一个非空指针，则参数how指示如何修改当前信号屏蔽字:
如果set是个空指针，则不改变该进程的信号屏蔽字， how的值也无意义。
SIG_BLOCK是或操作，而SIG_SETMASK则是赋值操作。
SIG_BLOCK (0)该进程新的信号屏蔽字是其当前信号屏蔽字和set指向信号集的并集。set包含了我们希望阻塞的附加信号
SIG_UNBLOCK (1)该进程新的信号屏蔽字是其当前信号屏蔽字和set所指向信号集的交集。set包含了我们希望解除阻塞的信号
SIG_SETMASK (2)该进程新的信号屏蔽是set指向的值

```cpp
#include <signal.h>
int sigpending(sigset_t  set*) ;
```


返回：若成功则为0，若出错则为-1
sigpending返回对于调用进程被阻塞不能递送和当前未决的信号集。该信号集通过set参数返回。



```cpp
#include <signal.h>
#include <stdio.h>
static void sig_quit(int sig_no)
{
    printf("caught SIGQUIT\n");
    if(sig_no == SIGQUIT)
    {
        if(signal(SIGQUIT, SIG_DFL) == SIG_ERR)//设置为默认动作
        {
            perror("signal\n");
        }
    }
    return ;
}
int main()
{
    sigset_t newmask, oldmask, pendmask;

    if(signal(SIGQUIT, sig_quit) == SIG_ERR)//对SIGQUIT安装信号处理程序
    {
        perror("signal\n");
        return 0;
    }
    sigemptyset(&newmask);//清空信号集
    sigaddset(&newmask, SIGQUIT);//向空的信号集添加信号SIGQUIT

    if(sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)//阻塞SIGQUIT并上原来的信号集,保存原来的信号集到oldmask
    {
        perror("sigprocmaks\n");
        return 0;
    }

    sleep(5);//睡眠期间产生SIGQUIT (ctrl + \)

    if(sigpending(&pendmask) < 0)//返回被阻塞的信号集
    {
        perror("sigpending\n");
        return 0;
    }

    if(sigismember(&pendmask, SIGQUIT))//检查被阻塞的信号集中是否有SIGQUIT
    {
        printf("SIGQUIT pending\n");
    }

    if(sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)//恢复原来的信号集
    {
        perror("sigprocmask\n");
        return 0;
    }

    printf("SIGQUIT unblocked\n");//此时SIGQUIT不再被阻塞

    sleep(5);//

    return 0;
}
```

```shell
zh@zh-virtual-machine:~/fork_test$ ./a.out
^\^\^\SIGQUIT pending (在sleep(5)内多次产生SIGQUIT,此时SIGQUIT被阻塞,sleep(5)后，sigpending返回进程当前被阻塞的所有信号集，并检查是否存在SIGQUIT)
caught SIGQUIT  (在解除阻塞后，信号处理优先接触阻塞后的打印先执行,在被阻塞期间，触发了多次信号，但是信号处理程序只返回一次，说明信号并未排队)
SIGQUIT unblocked （信号处理程序将SIGQUIT信号动作修改为默认后返回，再执行此打印）
^\Quit (core dumped) （再次进入sleep(5)，此时SIGQUIT不再被阻塞，CTRL+\直接导致进程终止，并产生coredump
```

### sigaction函数

```cpp
#include <signal.h>
int sigaction(int signo, const struct sigaction *act, struct sigaction *oact) ;
```


返回：若成功则为0，若出错则为- 1

signo为信号，
若act指针非空，则要修改其动作。
如果oact指针非空，则系统返回该信号的原先动作

```cpp
struct sigaction {
void (*sa_handler)(); /* addr of signal handler,or SIG_IGN, or SIG_DFL */
sigset_t sa_mask; /* additional signals to block */
int sa_flags; /* signal options, Table 10-5 */
};
```



当更改信号动作时，如果sahandler指向一个信号捕捉函数(不是常数SIGIGN或SIGDFL)，则samask字段说明了一个信号集，在调用信号捕捉函数之前，该信号集要加到进程的信号屏
蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字恢复为原先值。这样，在调用信号处理程序时就能阻塞某些信号。在信号处理程序被调用时，系统建立的新信号屏蔽字会自动包
括正被递送的信号。因此保证了在处理一个给定的信号时，如果这种信号再次发生，那么它会被阻塞到对前一个信号的处理结束为止。

saflags字段包含对信号处理的选项，其中可能用的是：SA_RESTART重启被此信号中断的系统调用

使用sigaction函数实现signal函数：

```cpp
#include <signal.h>
#include <stdio.h>
typedef void (*sighandler_t)(int);

sighandler_t signal_r(int signo, sighandler_t handler)
{
    struct sigaction act, oact;
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if(sigaction(signo, &act, &oact) < 0)
    {
        return SIG_ERR;
    }
    return (oact.sa_handler);
}
```

```cpp
#include <signal.h>
int sigsuspend(const sigset_t *sigmask) ;
```

返回：-1, errno设置为EINTR

函数sigsuspend实现原子操作：恢复信号屏蔽字同时使进程睡眠(pause)，避免在恢复信号屏蔽字和睡眠之间信号被递送导致睡眠无法被唤醒。
此函数只会返回-1，因为此函数会导致休眠，而此休眠只能被信号唤醒，同时errno被置为EINTR。

进程的信号屏蔽字设置为由sigmask指向的值。在捕捉到一个信号或发生了一个会终止该进程的信号之前，该进程也被挂起。如果捕捉到一个信号而且从该信号处理程序返回，则
sigsuspend返回，并且该进程的信号屏蔽字设置为调用sigsuspend之前的值。

```cpp

#include <signal.h>
#include <stdio.h>
#include <string.h>//strerror
#include <errno.h>//errno
#include <stdlib.h>//exit
#define err_exit(a) do{ printf("[%s][%s][%d] %s error:%s\n ", __FILE__ , __FUNCTION__, __LINE__, a,strerror(errno)); exit(0); }while(0)

void print_mask(const char *str)
{
    if(!str)
        err_exit("!str");

    sigset_t mask;
    if(sigprocmask(SIG_BLOCK, NULL, &mask) < 0)//获取进程当前的信号屏蔽字
        err_exit("sigprocmask");

    printf("%s ", str);
    if(sigismember(&mask, SIGINT))//查看某个信号是否在屏蔽字中
        printf("SIGINT ");
    if(sigismember(&mask, SIGQUIT))
        printf("SIGQUIT ");
    if(sigismember(&mask, SIGALRM))
        printf("SIGALRM ");
    if(sigismember(&mask, SIGTSTP))
        printf("SIGTSTP ");
    putchar('\n');
}
void sig_int(int signo)
{
    if(signo == SIGINT)
        printf("caught SIGINT\n");
    return ;
}
void sig_tstp(int signo)
{
    if(signo == SIGTSTP)
        printf("caught SIGTSTP\n");
    return ;
}
int main()
{
    sigset_t  newmask, zeromask, oldmask;
    if(signal(SIGINT, sig_int) == SIG_ERR)
        err_exit("signal");

    if(signal(SIGTSTP, sig_tstp) == SIG_ERR)
        err_exit("signal");
    sigemptyset(&zeromask);
    sigemptyset(&newmask);

    sigaddset(&newmask, SIGINT);
    sigaddset(&newmask, SIGTSTP);
    if(sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)//阻塞SIGINT和SIGTSTP，防止信号提前被递送，先阻塞信号，阻塞后递送的信号会被传给sigsuspend函数
        err_exit("sigprocmask");

    print_mask("in critical region: ");

    if(sigsuspend(&zeromask) != -1)//函数睡眠，同时将进程屏蔽字设置为zeromask，此函数中为0即不屏蔽任何信号
        err_exit("sigsuspend");

    print_mask("after return from sigsuspend: ");

    if(sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)//恢复信号屏蔽字
        err_exit("sigprocmask");

    return 0;
}
```

```shell
zh@zh-virtual-machine:~/fork_test$ ./a.out
in critical region:  SIGINT SIGTSTP
^Ccaught SIGINT
after return from sigsuspend:  SIGINT SIGTSTP
zh@zh-virtual-machine:~/fork_test$ ./a.out
in critical region:  SIGINT SIGTSTP
^Zcaught SIGTSTP
after return from sigsuspend:  SIGINT SIGTSTP
```

信号可用于父子进程间同步。通过kilL函数向进程发送信号。

### abort函数

```cpp
#include <stdlib.h>
void abort(void);
```

此函数不返回
abort函数产生SIGABRT信号，此信号被捕捉后，信号处理程序返回后仍然不会返回到其调用者，除非调用exit,longjmp,siglongjmp,_exit等函数，
一般此信号产生后，应该在信号处理程序中执行清除操作，随后进程退出。

#### posix.1的abort的实现

```cpp
#include <sys/signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void abort_s(void)
{
    sigset_t mask;
    struct sigaction action;

    sigaction(SIGABRT, NULL, &action);//获取当前为SIGABRT安装的信号处理函数

    if(action.sa_handler == SIG_IGN)
    {
        action.sa_handler = SIG_DFL;//如果系统忽略此信号，则将此信号行为改为默认值
        sigaction(SIGABRT, &action, NULL);//安装信号处理函数
    }
    if(action.sa_handler == SIG_DFL)
        fflush(NULL);//刷新缓冲区

    sigfillset(&mask);
    sigdelset(&mask, SIGABRT);
    sigprocmask(SIG_SETMASK, &mask, NULL);//阻塞所有信号除了SIGABRT
    kill(getpid(), SIGABRT);//向本进程发送SIGABRT

    //到这里，进程已经捕捉信号执行处理程序并返回
    fflush(NULL);//执行刷新缓冲区操作
    action.sa_handler = SIG_DFL;//强制修改SIGABRT的信号为默认处理方式，即退出+coredump
    sigaction(SIGABRT, &action, NULL);//安装
    sigprocmask(SIG_SETMASK, &mask, NULL);//阻塞其他信号
    kill(getpid(), SIGABRT);//向本进程发送SIGABRT，此时信号采用默认处理方式，进程直接退出并产生coredump

    exit(1);
}
```

bash进程会忽略大部分系统信号如ctrl+c ctrl+\ ...

#### posix.2实现的system函数

```cpp
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#define err_exit(a) do{ printf("[%s] [%s] [%d] %s error: %s\n",__FILE__, __FUNCTION__, __LINE__, a, strerror(errno)); exit(0); }while(0)
int system_s(const char *cmd)
{
    pid_t pid;
    int status;
    struct sigaction ignore, saveintr, savequit;
    sigset_t chldmask, savemask;

    if(cmd == NULL)
    {
        err_exit("cmd == NULL");
    }

    ignore.sa_handler = SIG_IGN;
    sigemptyset(&ignore.sa_mask);
    ignore.sa_flags = 0;

    if(sigaction(SIGINT, &ignore, &saveintr) < 0)//忽略SIGINT
        err_exit("sigaction");
    if(sigaction(SIGQUIT, &ignore, &savequit) < 0)//忽略SIGQUIT
        err_exit("sigaction");

    sigemptyset(&chldmask);
    sigaddset(&chldmask, SIGCHLD);
    if(sigprocmask(SIG_BLOCK, &chldmask, &savemask) < 0)//阻塞SIGCHLD，SIGCHLD默认处理方式一般是忽略，也可以根据这个信号去注册信号处理函数调用wait/waitpid异步的回收子进程资源，
                                                        //这里阻塞SIGCHLD的原因是，如果system函数的调用者进程捕捉SIGCHLD信号，并早信号处理函数中调用waitpid/wait处理子进程，则在下面的pid>0处理中的
                                                        //waitpid返回-1,并将status置为-1,影响到system的返回值。而阻塞掉SIGCHLD，system函数中父进程调用waitpid处理完子进程后，解除对SIGCHLD的阻塞信号
                                                        //会向上传给system的调用者，而此时即使调用者捕捉了SIGCHLD，在信号处理程序中调用了wait/waitpid处理原来在system中已经处理的子进程，也不会影响什么。
                                                        //APUE中也明确说明了这一点
        err_exit("sigprocmask");

    pid =fork();

    if(pid < 0)
        err_exit("fork");

    if(pid == 0)
    {
        sigaction(SIGINT, &saveintr, NULL);
        sigaction(SIGQUIT, &savequit, NULL);
        sigprocmask(SIG_SETMASK, &savemask, NULL);
        execl("/bin/sh", "sh", "-c", cmd, (char*)0);
        _exit(127);
    }
    else if(pid > 0)
    {
        while(waitpid(pid, &status, 0) < 0)
        {
            if(errno != EINTR)
            {
                status = -1;
                break;
            }
        }
    }

    sigaction(SIGINT, &saveintr, NULL);
    sigaction(SIGQUIT, &savequit, NULL);
    sigprocmask(SIG_SETMASK, &savemask, NULL);
    return status;
}
```

system系统调用的返回值是shell的终止状态，一般简单命令如ls,

echo $?查看上一次执行的程序返回给Shell的返回值

在shell下执行的程序被信号杀死时，打印程序返回值，其结果为128 + 信号编号

### sleep函数使进程睡眠指定时间

```cpp
#include <unistd.h>
unsigned int sleep(unsigned int seconds);
```

返回值为0（正常返回）或未休眠完的秒数（被信号中断）

#### posix.1的sleep函数实现

```cpp
#include <signal.h>
#include <stdio.h>
//#include <unistd.h>
void sig_alrm(int signo)
{
    ;
}
unsigned int sleep_s(unsigned int seconds)
{
    struct sigaction newact, oldact;
    sigset_t newmask, oldmask, suspmask;
    unsigned int unslept;

    newact.sa_handler = sig_alrm;
    sigemptyset(&newact.sa_mask);
    newact.sa_flags = 0;
    sigaction(SIGALRM, &newact, &oldact);//设置SIGALRM信号处理函数，函数什么也不做直接返回

    sigemptyset(&newmask);
    sigaddset(&newmask, SIGALRM);
    sigprocmask(SIG_BLOCK, &newmask, &oldmask);//阻塞SIGALRM信号，随后调用alarm

    alarm(seconds);
    suspmask = oldmask;

    sigdelset(&suspmask, SIGALRM);//确保sigsuspend被阻塞的信号中没有SIGALRM

    sigsuspend(&suspmask);//alarm激活suspend的睡眠


    unslept = alarm(0);

    sigaction(SIGALRM, &oldact, NULL);
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
    return unslept;
}
```

nanosleep函数提供纳秒级的精度
#include <time.h>
int nanosleep(const struct timespec *reqtp, struct timespec *remtp);
正常休眠到要求的时间返回0，出错返回-1，第一个参数指定休眠时间，第二个参数返回未休眠完的时间
信号排队：sigqueue函数

作业控制信号:
SIGCHLD 子进程已停止或终止。
SIGCONT 如果进程已停止，则使其继续运行。
SIGTSTP 停止信号（不能被捕捉或忽略）。
SIGSTOP 交互停止信号。
SIGTTIN 后台进程组的成员读控制终端。
SIGTTOU 后台进程组的成员写控制终端。