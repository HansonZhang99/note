# 设备树解析

## start_kernel->setup_arch

内核在经过一系列汇编后最后会调用第一个c函数:start_kernel，这个函数中会调用setup_arch:

```cpp
asmlinkage __visible void __init start_kernel(void)
{
    char *command_line;
	//...
    setup_arch(&command_line);
    //...
}
```

## 根据设备树找到machine_desc

linux/arch/arm/kernel/head.S文件定义了bootloader和kernel的参数传递要求：

```shell
MMU = off, D-cache = off, I-cache = dont care, r0 = 0, r1 = machine nr, r2 = atags or dtb pointer.
```

目前的kernel支持旧的tag list的方式，同时也支持device tree的方式。`r2可能是device tree binary file的指针（bootloader要传递给内核之前要copy到memory中），也可以能是tag list的指针`。在ARM的汇编部分的启动代码中（主要是head.S和head-common.S），machine type ID和指向DTB或者atags的指针被保存在变量`__machine_arch_type`和`__atags_pointer`中，这么做是为了后续c

代码进行处理。

```cpp
void __init setup_arch(char **cmdline_p)
{
	const struct machine_desc *mdesc;

	setup_processor();
	mdesc = setup_machine_fdt(__atags_pointer);
	if (!mdesc)
		mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);
	machine_desc = mdesc;
    //...
}
```

对于找到machine_desc：

### 旧方法

旧方法是定义一系列的machine描述符（struct machine_desc ），在启动过程中，通过machine type ID作为索引，在这些静态定义的machine描述符中扫描，找到那个ID匹配的描述符。这会走上面代码的`setup_machine_tags(__atags_pointer, __machine_arch_type);`部分	![image-20230612191348773](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612191348773.png)

```cpp
mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);
```

![image-20230612193710723](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612193710723.png)

### 新方法

新方法是在新的内核中，首先使用setup_machine_fdt找到machine描述符。

![image-20230612194909465](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612194909465.png)

![image-20230612195108917](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612195108917.png)

## early_param

setup_arch->parse_early_param

![image-20230612201047501](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612201047501.png)

## 内核对设备树的处理

### 设备树cpu部分处理

setup_arch->arm_dt_init_cpu_maps

### 设备树memory部分处理

setup_arch->setup_machine_fdt->early_init_dt_scan->early_init_dt_scan_memory

### 设备树interrupt-controller处理

start_kernel->init_IRQ->machine_desc->init_irq()（静态定义）

或者IRQCHIP_DECLARE宏指定的处理方式（涉及到设备树）

### 设备树GPIO controller的处理

### 设备树转换为platform_device

start_kernel->rest_init->kernel_init->kernel_init_freeable->do_basic_setup->do_initcalls



内核提供xxx_initcall注册一个回调函数，包括module_init也是使用的initcall,系统启动后do_initcalls函数会根据注册优先级依次调用这些initcall的回调函数

![image-20230612205338737](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612205338737.png)



do_initcalls会遍历来自各种initcall注册到__initcall_start段的结构，并调用其fn函数

![image-20230612205914741](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612205914741.png)

initcall会调用到customize_machine函数，这个函数会调用板级的machine_desc->init_machine,machine_desc在setup_arch中setup_machine_fdt函数被匹配

![image-20230612220429811](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230612220429811.png)

![image-20230613002313604](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230613002313604.png)

### 设备树处理中断

of_device_alloc->of_irq_to_resource_table

![image-20230615024025374](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230615024025374.png)

of_irq_to_resource_table每解析完一个中断，都会调用of_create_of_mapping函数，这个函数是中断映射的核心函数

![image-20230614000718167](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230614000718167.png)

![image-20230614002459910](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230614002459910.png)

![image-20230614003645205](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230614003645205.png)

对于设备树中的节点，除了一些特殊节点外，其他节点都会被解析成一个platform_device在解析过程中对中断的处理如下：

1. of_device_alloc是最外层接口

2. of_device_alloc调用of_irq_to_resource_table函数:

   ```cpp
   of_irq_to_resource_table(np, res, num_irq)
   ```

   根据设备树节点np解析num_irq个中断并放入res(struct resource*)中

3. of_irq_to_resource_table对每个中断都调用of_irq_to_resource进行处理

4. of_irq_to_resource调用of_irq_to_resource处理每个中断

5. of_irq_to_resource调用of_irq_parse_one在设备树中解析一个中断：

   ```cpp
   of_irq_parse_one(dev, index, &oirq)
   ```

   解析dev设备节点中的第index个中断，保存在oirq中

6. of_irq_to_resource再调用irq_create_of_mapping处理这个解析完成的中断

7. irq_create_of_mapping首先调用irq_create_of_mapping:

   ```cpp
   of_phandle_args_to_fwspec(irq_data, &fwspec);
   ```

   将原来的解析结果irq_data转换并填充到fwspec中

8. irq_create_of_mapping随后调用irq_create_fwspec_mapping:

   1. 调用irq_find_matching_fwspec函数根据保存在fwspec中的设备树信息(interrupt-parent)，找到对应的domian(内核对每个中断控制器都会分配一个domain,domain根据设备树形成父子关系)

      ```cpp
      domain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);
      ```

   2. 调用irq_domain_translate，这个函数会调用domain->ops->translate（gic和gpc是translate,对gpio是xlate）函数：

      ```cpp
      irq_domain_translate(domain, fwspec, &hwirq, &type)
      ```

      根据设备树解析出申请的硬件中断号和中断类型，不同的domain这个中断号和类型可能不同

   3. 调用irq_find_mapping:

      ```cpp
      virq = irq_find_mapping(domain, hwirq);
      ```

      根据硬件中断号，在domain的映射表中肇东是否存在匹配的虚拟中断号（domain有两种建立hwirq和virq关系的方法，一种是线性表，一种是radixtree，这两种映射表都可以根据hwirq找到virq)，如果能找到说明映射已经建立，对触发类型做处理后直接返回虚拟中断号，用户使用中断时使用的都是虚拟中断号(platform_get_resource获取的中断，request_irq申请使用的中断号都是虚拟中断)

   4. 如果没找到映射关系就根据domain->flags & IRQ_DOMAIN_FLAG_HIERARCHY执行不同的映射：

      1. 如果flag存在，则调用irq_domain_alloc_irqs：（gic,gpc都走这个）

         ```cpp
         virq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);
         ```

         fwspec包含设备树节点，硬件中断号，中断类型信息。

         这个函数最后调用irq_domain_alloc_descs函数：

         ```cpp
         virq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,
         					      affinity);
         ```

         irq_domain_alloc_descs会调用__irq_alloc_descs：

         这个函数根据allocated_irqs这个bitmap找到第一个没有使用的位，这个位作为虚拟中断号virq，如果这个值超过阈值会尝试扩大，太大会报错。

         得到虚拟中断号virq后，会调用alloc_descs为虚拟中断号创建一个irq_desc结构，。根据irq_desc初始化有静态数组和radixtree两种方式，alloc_descs分配方式有所不同，但是最终会为virq分配一个irq_desc，可以根据virq找到这个irq_desc。

         在得到virq后会调用irq_domain_alloc_irq_data函数，这个函数根据virq对应的irq_desc中的irq_data成员以及domain直接的父子关系，创建一个irq_data链表：

         ```cpp
         for (parent = domain->parent; parent; parent = parent->parent) {//为domain上的所有parent都创建irq_data
         			irq_data = irq_domain_insert_irq_data(parent, irq_data);
         			if (!irq_data) {
         				irq_domain_free_irq_data(virq, i + 1);
         				return -ENOMEM;
         			}
         		}
         
         static struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,
         						   struct irq_data *child)
         {
         	struct irq_data *irq_data;
         
         	irq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,
         				irq_data_get_node(child));
         	if (irq_data) {
         		child->parent_data = irq_data;
         		irq_data->irq = child->irq;//所有irq_data的irq都是同一个virq
         		irq_data->common = child->common;
         		irq_data->domain = domain;
         	}
         
         	return irq_data;
         }
         ```

         ![image-20230618030152658](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230618030152658.png)

         调用irq_domain_alloc_irqs_recursive函数建立hwirq和virq的映射：

         这个函数会根据domain->parent递归调用，如对于gpio控制器，会依次调用gpc domain的ops->alloc和gic domain的ops->alloc

         alloc函数会设置对应的irq_data(上个步骤根据domain->parent分配了多个irq_data，递归调用会设置domain对应的irq_data。irq_data里面有domain，hwirq，irqchip...(这个hwirq是对应中断控制器的hwirq，如gic、gpc这个值是不一样的，目的是用来在中断发生时屏蔽中断控制器的对应中断，每个中断控制器对硬件中断的编号都是不一样的）等信息)，对于gic的alloc函数，还会设置irq_desc->handle为handle_fasteoi_irq(对arm来说)

         最后调用irq_domain_insert_irq根据irq_data的父子关系，在irq_domain链表中的每个domain中添加hwirq和virq的映射

      2. 如果flag存在，则调用irq_create_mapping：（gpio走这个，只是做个简单的映射）

         ```cpp
         unsigned int irq_create_mapping(struct irq_domain *domain,
         				irq_hw_number_t hwirq)
         {
         	struct device_node *of_node;
         	int virq;
         
         	//...
         
         	of_node = irq_domain_get_of_node(domain);
         
         	/* Check if mapping already exists */
         	virq = irq_find_mapping(domain, hwirq);//在domain中查找是否已经有映射
         	if (virq) {
         		pr_debug("-> existing mapping on virq %d\n", virq);
         		return virq;
         	}
         
         	/* Allocate a virtual interrupt number */
         	virq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), NULL);//分配virq和irq_desc，建立virq和irq_desc映射，返回virq
         	if (virq <= 0) {
         		pr_debug("-> virq allocation failed\n");
         		return 0;
         	}
         
         	if (irq_domain_associate(domain, virq, hwirq)) {
         		irq_free_desc(virq);
         		return 0;
         	}
         
         	//...
         
         	return virq;
         }
         
         //在domain中建立hwirq和virq的映射
         int irq_domain_associate(struct irq_domain *domain, unsigned int virq,
         			 irq_hw_number_t hwirq)
         {
         	struct irq_data *irq_data = irq_get_irq_data(virq);
         	int ret;
         
         	//...
         	irq_data->hwirq = hwirq;
         	irq_data->domain = domain;
         	//...
         
         	if (hwirq < domain->revmap_size) {
         		domain->linear_revmap[hwirq] = virq;
         	} else {
         		mutex_lock(&revmap_trees_mutex);
         		radix_tree_insert(&domain->revmap_tree, hwirq, irq_data);
         		mutex_unlock(&revmap_trees_mutex);
         	}
         	mutex_unlock(&irq_domain_mutex);
         
         	irq_clear_status_flags(virq, IRQ_NOREQUEST);
         
         	return 0;
         }
         EXPORT_SYMBOL_GPL(irq_domain_associate);
         ```



