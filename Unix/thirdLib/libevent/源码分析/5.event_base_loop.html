<html>
<head>
  <title>5.event_base_loop</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="587"/>
<h1>5.event_base_loop</h1>

<div>
<span><div><span style="font-weight: bold;">暂时不分析超时</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>int</div><div>event_base_loop(struct event_base *base, int flags)</div><div>{</div><div>    const struct eventop *evsel = base-&gt;evsel;</div><div>    struct timeval tv;</div><div>    struct timeval *tv_p;</div><div>    int res, done, retval = 0;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    /* Grab the lock.  We will release it inside evsel.dispatch, and again</div><div>     * as we invoke user callbacks. */</div><div>    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (base-&gt;running_loop) {</div><div>        event_warnx(&quot;%s: reentrant invocation.  Only one event_base_loop&quot;</div><div>            &quot; can run on each event_base at once.&quot;, __func__);</div><div>        EVBASE_RELEASE_LOCK(base, th_base_lock);</div><div>        return -1;</div><div>    }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    base-&gt;running_loop = 1;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    <span style="color: #ff0000;">clear_time_cache(base);//base-&gt;tv_cache.tv_sec = 0;</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (base-&gt;sig.ev_signal_added &amp;&amp; base-&gt;sig.ev_n_signals_added)</div><div>        evsig_set_base_(base);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    done = 0;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>#ifndef EVENT__DISABLE_THREAD_SUPPORT</div><div>    base-&gt;th_owner_id = EVTHREAD_GET_ID();</div><div>#endif</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    base-&gt;event_gotterm = base-&gt;event_break = 0;</div><div>    while (!done) {</div><div>        base-&gt;event_continue = 0;</div><div>        base-&gt;n_deferreds_queued = 0;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        /* Terminate the loop if we have been asked to */</div><div>        if (base-&gt;event_gotterm) {</div><div>            break;</div><div>        }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        if (base-&gt;event_break) {</div><div>            break;</div><div>        }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>       <span style="color: #ff0000;"> tv_p = &amp;tv;</span></div><div>        if (!N_ACTIVE_CALLBACKS(base) &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) {</div><div>            timeout_next(base, &amp;tv_p);</div><div>        } else {</div><div>            /*</div><div>             * if we have active events, we just poll new events</div><div>             * without waiting.</div><div>             */</div><div>            evutil_timerclear(&amp;tv);</div><div>        }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        /* If we have no events, we just exit */</div><div>        if (0==(flags&amp;EVLOOP_NO_EXIT_ON_EMPTY) &amp;&amp;</div><div>            !event_haveevents(base) &amp;&amp; !N_ACTIVE_CALLBACKS(base)) {</div><div>            event_debug((&quot;%s: no events registered.&quot;, __func__));</div><div>            retval = 1;</div><div>            goto done;</div><div>        }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        event_queue_make_later_events_active(base);</div><div>        clear_time_cache(base);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>      <span style="color: #ff0000;">  res = evsel-&gt;dispatch(base, tv_p);</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>        if (res == -1) {</div><div>            event_debug((&quot;%s: dispatch returned unsuccessfully.&quot;,</div><div>                __func__));</div><div>            retval = -1;</div><div>            goto done;</div><div>        }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        update_time_cache(base);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        timeout_process(base);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>       <span style="color: #ff0000;"> if (N_ACTIVE_CALLBACKS(base)) {//if (((base)-&gt;event_count_active))</span></div><div>           <span style="color: #ff0000;"> int n = event_process_active(base);</span></div><div>            if ((flags &amp; EVLOOP_ONCE)</div><div>                &amp;&amp; N_ACTIVE_CALLBACKS(base) == 0</div><div>                &amp;&amp; n != 0)</div><div>                done = 1;</div><div>        } else if (flags &amp; EVLOOP_NONBLOCK)</div><div>            done = 1;</div><div>    }</div><div>    event_debug((&quot;%s: asked to terminate loop.&quot;, __func__));</div><div><br clear="none"/></div><div><br clear="none"/></div><div>done:</div><div>    clear_time_cache(base);</div><div>    base-&gt;running_loop = 0;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    EVBASE_RELEASE_LOCK(base, th_base_lock);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    return (retval);</div><div>}</div></div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="font-weight: bold;">接下来看看select的dispatch函数</span></div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>static int</div><div>select_dispatch(struct event_base *base, struct timeval *tv)</div><div>{</div><div>    int res=0, i, j, nfds;</div><div><span style="color: #ff0000;">    struct selectop *sop = base-&gt;evbase;//获取select复用对应结构体,evbase中保存了所有注册到该event_base的文件描述符</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>    check_selectop(sop);</div><div>    <span style="color: #ff0000;">if (sop-&gt;resize_out_sets) {</span></div><div><span style="color: #ff0000;">        fd_set *readset_out=NULL, *writeset_out=NULL;</span></div><div><span style="color: #ff0000;">        size_t sz = sop-&gt;event_fdsz;</span></div><div><span style="color: #ff0000;">        if (!(readset_out = mm_realloc(sop-&gt;event_readset_out, sz)))</span></div><div><span style="color: #ff0000;">            return (-1);</span></div><div><span style="color: #ff0000;">        sop-&gt;event_readset_out = readset_out;</span></div><div><span style="color: #ff0000;">        if (!(writeset_out = mm_realloc(sop-&gt;event_writeset_out, sz))) {</span></div><div><span style="color: #ff0000;">            /* We don't free readset_out here, since it was</span></div><div><span style="color: #ff0000;">             * already successfully reallocated. The next time</span></div><div><span style="color: #ff0000;">             * we call select_dispatch, the realloc will be a</span></div><div><span style="color: #ff0000;">             * no-op. */</span></div><div><span style="color: #ff0000;">            return (-1);</span></div><div><span style="color: #ff0000;">        }</span></div><div><span style="color: #ff0000;">        sop-&gt;event_writeset_out = writeset_out;</span></div><div><span style="color: #ff0000;">        sop-&gt;resize_out_sets = 0;</span></div><div><span style="color: #ff0000;">    }//内存分配</span></div><div><br clear="none"/></div><div><span style="color: #ff0000;"><br clear="none"/></span></div><div><span style="color: #ff0000;">    memcpy(sop-&gt;event_readset_out, sop-&gt;event_readset_in,</span></div><div><span style="color: #ff0000;">           sop-&gt;event_fdsz);</span></div><div><span style="color: #ff0000;">    memcpy(sop-&gt;event_writeset_out, sop-&gt;event_writeset_in,</span></div><div><span style="color: #ff0000;">           sop-&gt;event_fdsz);//加入文件描述符到对应out数组</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>   <span style="color: #ff0000;"> nfds = sop-&gt;event_fds+1;</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>    EVBASE_RELEASE_LOCK(base, th_base_lock);</div><div>   <span style="color: #ff0000;"> res = select(nfds, sop-&gt;event_readset_out,</span></div><div><span style="color: #ff0000;">        sop-&gt;event_writeset_out, NULL, tv);//select调用将阻塞在这里</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    check_selectop(sop);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (res == -1) {</div><div>        if (errno != EINTR) {</div><div>            event_warn(&quot;select&quot;);</div><div>            return (-1);</div><div>        }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        return (0);</div><div>    }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    event_debug((&quot;%s: select reports %d&quot;, __func__, res));</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    check_selectop(sop);</div><div>    i = evutil_weakrand_range_(&amp;base-&gt;weakrand_seed, nfds);</div><div>   <span style="color: #ff0000;"> for (j = 0; j &lt; nfds; ++j) {//当阻塞返回时，位数组event_readset_out和event_writest_out的非0位对应的位置即发生响应的文件描述符的值</span></div><div><span style="color: #ff0000;">        if (++i &gt;= nfds)</span></div><div><span style="color: #ff0000;">            i = 0;</span></div><div><span style="color: #ff0000;">        res = 0;</span></div><div><span style="color: #ff0000;">        if (FD_ISSET(i, sop-&gt;event_readset_out))</span></div><div><span style="color: #ff0000;">            res |= EV_READ;</span></div><div><span style="color: #ff0000;">        if (FD_ISSET(i, sop-&gt;event_writeset_out))</span></div><div><span style="color: #ff0000;">            res |= EV_WRITE;</span></div><div><span style="color: #ff0000;"><br clear="none"/></span></div><div><span style="color: #ff0000;"><br clear="none"/></span></div><div><span style="color: #ff0000;">        if (res == 0)</span></div><div><span style="color: #ff0000;">            continue;</span></div><div><span style="color: #ff0000;"><br clear="none"/></span></div><div><span style="color: #ff0000;"><br clear="none"/></span></div><div><span style="color: #ff0000;">        evmap_io_active_(base, i, res);</span></div><div>    }</div><div>    check_selectop(sop);</div><div>  return (0);</div><div>}</div></div><div><br clear="none"/></div><div><span style="font-weight: bold;">函数evmap_io_active:</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>void</div><div>evmap_io_active_(struct event_base *base, evutil_socket_t fd, short events)</div><div>{       </div><div>    struct event_io_map *io = &amp;base-&gt;io;</div><div>    struct evmap_io *ctx;</div><div>    struct event *ev;</div><div>            </div><div>#ifndef EVMAP_USE_HT</div><div>    if (fd &lt; 0 || fd &gt;= io-&gt;nentries)</div><div>        return;</div><div>#endif</div><div>    <span style="color: #ff0000;">GET_IO_SLOT(ctx, io, fd, evmap_io);//(ctx) = (struct evmap_io *)((io)-&gt;entries[fd]);</span></div><div>   </div><div>    if (NULL == ctx)</div><div>        return;</div><div>   <span style="color: #ff0000;"> LIST_FOREACH(ev, &amp;ctx-&gt;events, ev_io_next) {//遍历此fd的eventlist链表，通过events的值执行相应的回调函数</span></div><div><span style="color: #ff0000;">        if (ev-&gt;ev_events &amp; events)</span></div><div><span style="color: #ff0000;">            event_active_nolock_(ev, ev-&gt;ev_events &amp; events, 1);</span></div><div>    }</div><div>}</div></div><div><br clear="none"/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">event_active_nolock_</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>void</div><div>event_active_nolock_(struct event *ev, int res, short ncalls)</div><div>{</div><div>    struct event_base *base;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    event_debug((&quot;event_active: %p (fd &quot;EV_SOCK_FMT&quot;), res %d, callback %p&quot;,</div><div>        ev, EV_SOCK_ARG(ev-&gt;ev_fd), (int)res, ev-&gt;ev_callback));</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    base = ev-&gt;ev_base;</div><div>    EVENT_BASE_ASSERT_LOCKED(base);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (ev-&gt;ev_flags &amp; EVLIST_FINALIZING) {</div><div>        /* XXXX debug */</div><div>        return;</div><div>    }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    switch ((ev-&gt;ev_flags &amp; (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER))) {</div><div>    default:</div><div>    case EVLIST_ACTIVE|EVLIST_ACTIVE_LATER:</div><div>        EVUTIL_ASSERT(0);</div><div>        break;</div><div>    case EVLIST_ACTIVE:</div><div>        /* We get different kinds of events, add them together */</div><div>        ev-&gt;ev_res |= res;</div><div>        return;</div><div>    case EVLIST_ACTIVE_LATER:</div><div>        ev-&gt;ev_res |= res;</div><div>        break;</div><div>    case 0:</div><div>        ev-&gt;ev_res = res;</div><div>        break;</div><div>    }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (ev-&gt;ev_pri &lt; base-&gt;event_running_priority)</div><div>        base-&gt;event_continue = 1;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (ev-&gt;ev_events &amp; EV_SIGNAL) {</div><div>#ifndef EVENT__DISABLE_THREAD_SUPPORT</div><div>        if (base-&gt;current_event == event_to_event_callback(ev) &amp;&amp;</div><div>            !EVBASE_IN_THREAD(base)) {</div><div>            ++base-&gt;current_event_waiters;</div><div>            EVTHREAD_COND_WAIT(base-&gt;current_event_cond, base-&gt;th_base_lock);</div><div>        }</div><div>#endif</div><div>        <span style="color: #ff0000;">ev-&gt;ev_ncalls = ncalls;</span></div><div>        ev-&gt;ev_pncalls = NULL;</div><div>    }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>  <span style="color: #ff0000;">  event_callback_activate_nolock_(base, event_to_event_callback(ev));</span></div><div>}</div></div><div><br clear="none"/></div><div><span style="font-weight: bold;">函数event_callback_activate_nolock_</span></div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>int</div><div>event_callback_activate_nolock_(struct event_base *base,</div><div>    struct event_callback *evcb)</div><div>{</div><div>    int r = 1;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (evcb-&gt;evcb_flags &amp; EVLIST_FINALIZING)</div><div>        return 0;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    switch (evcb-&gt;evcb_flags &amp; (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER)) {</div><div>    default:</div><div>        EVUTIL_ASSERT(0);</div><div>        EVUTIL_FALLTHROUGH;</div><div>    case EVLIST_ACTIVE_LATER:</div><div>        event_queue_remove_active_later(base, evcb);</div><div>        r = 0;</div><div>        break;</div><div>    case EVLIST_ACTIVE:</div><div>        return 0;</div><div>    case 0:</div><div>        break;</div><div>    }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>   <span style="color: #ff0000;"> event_queue_insert_active(base, evcb);//</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (EVBASE_NEED_NOTIFY(base))</div><div>        evthread_notify_base(base);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    return r;</div><div>}</div></div><div><br clear="none"/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">event_queue_insert_active：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>static void</div><div>event_queue_insert_active(struct event_base *base, struct event_callback *evcb)</div><div>{</div><div>    EVENT_BASE_ASSERT_LOCKED(base);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    if (evcb-&gt;evcb_flags &amp; EVLIST_ACTIVE) {</div><div>        /* Double insertion is possible for active events */</div><div>        return;</div><div>    }</div><div><br clear="none"/></div><div>    do {</div><div>     ((base)-&gt;event_count += !((evcb-&gt;evcb_flags) &amp; 0x10));</div><div>     (base)-&gt;event_count_max = ((((base)-&gt;event_count_max)&gt;((base)-&gt;event_count))?</div><div>((base)-&gt;event_count_max):((base)-&gt;event_count));</div><div>} while (0);</div><div><br clear="none"/></div><div>    <span style="color: #ff0000;">evcb-&gt;evcb_flags |= EVLIST_ACTIVE;</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>    <span style="color: #ff0000;">base-&gt;event_count_active++;</span></div><div>    </div><div>    base-&gt;event_count_active_max = (((base-&gt;event_count_active_max)&gt;(base-&gt;event_count_active))?(base-&gt;event_count_active_max):(base-&gt;event_count_active));</div><div><br clear="none"/></div><div>    EVUTIL_ASSERT(evcb-&gt;evcb_pri &lt; base-&gt;nactivequeues);</div><div><span style="color: #ff0000;">    do</span></div><div><span style="color: #ff0000;">    {</span></div><div><span style="color: #ff0000;">         (evcb)-&gt;evcb_active_next.tqe_next = ((void *)0); </span></div><div><span style="color: #ff0000;">         (evcb)-&gt;evcb_active_next.tqe_prev</span><span style="color: #ff0000;">= (&amp;base-&gt;activequeues[evcb-&gt;evcb_pri])-&gt;tqh_last;</span></div><div><span style="color: #ff0000;">         *(&amp;base-&gt;activequeues[evcb-&gt;evcb_pri])-&gt;tqh_last = (evcb);</span></div><div><span style="color: #ff0000;">         (&amp;base-&gt;activequeues[evcb-&gt;evcb_pri])-&gt;tqh_last = &amp;(evcb)-&gt;evcb_active_next.        </span></div><div><span style="color: #ff0000;">    tqe_next;</span></div><div><span style="color: #ff0000;">    } while ( 0);//插入evcb到激活队列</span></div><div>}</div></div><div><br clear="none"/></div><div><span style="font-weight: bold;">函数event_process_active执行激活队列函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>static int</div><div>event_process_active(struct event_base *base)</div><div>{</div><div>    /* Caller must hold th_base_lock */</div><div>    struct evcallback_list *activeq = NULL;</div><div>    int i, c = 0;</div><div>    const struct timeval *endtime;</div><div>    struct timeval tv;</div><div>    const int maxcb = base-&gt;max_dispatch_callbacks;</div><div>    const int limit_after_prio = base-&gt;limit_callbacks_after_prio;</div><div>    if (base-&gt;max_dispatch_time.tv_sec &gt;= 0) {</div><div>        update_time_cache(base);</div><div>        gettime(base, &amp;tv);</div><div>        evutil_timeradd(&amp;base-&gt;max_dispatch_time, &amp;tv, &amp;tv);</div><div>        endtime = &amp;tv;</div><div>    } else {</div><div>        endtime = NULL;</div><div>    }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    for (i = 0; i &lt; base-&gt;nactivequeues; ++i) {</div><div>        if (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != NULL) {</div><div>            <span style="color: #ff0000;">base-&gt;event_running_priority = i;</span></div><div><span style="color: #ff0000;">            activeq = &amp;base-&gt;activequeues[i];//从低序号（高优先级）数组开始执行</span></div><div>            if (i &lt; limit_after_prio)</div><div>               <span style="color: #ff0000;"> c = event_process_active_single_queue(base, activeq,</span></div><div><span style="color: #ff0000;">                    INT_MAX, NULL);</span></div><div>            else</div><div>              <span style="color: #ff0000;">  c = event_process_active_single_queue(base, activeq,</span></div><div><span style="color: #ff0000;">                    maxcb, endtime);</span></div><div>            if (c &lt; 0) {</div><div>                goto done;</div><div>            } else if (c &gt; 0)</div><div>                break; /* Processed a real event; do not</div><div>                    * consider lower-priority events */</div><div>...</div></div><div><br clear="none"/></div><div><span style="font-weight: bold;">函数event_process_active_single_queue</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>static int</div><div>event_process_active_single_queue(struct event_base *base,</div><div>    struct evcallback_list *activeq,</div><div>    int max_to_process, const struct timeval *endtime)</div><div>{</div><div>    struct event_callback *evcb;</div><div>    int count = 0;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    EVUTIL_ASSERT(activeq != NULL);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    for (evcb = TAILQ_FIRST(activeq); evcb; evcb = TAILQ_FIRST(activeq)) {</div><div>        struct event *ev=NULL;</div><div>        if (<span style="color: #ff0000;">evcb-&gt;evcb_flags &amp; EVLIST_INIT)</span> {</div><div>           <span style="color: #ff0000;"> ev = event_callback_to_event(evcb);</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div>            if (<span style="color: #ff0000;">ev-&gt;ev_events &amp; EV_PERSIST |</span>| ev-&gt;ev_flags &amp; EVLIST_FINALIZING)</div><div>                <span style="color: #ff0000;">event_queue_remove_active(base, evcb);</span></div><div>            else</div><div>                <span style="color: #ff0000;">event_del_nolock_(ev, EVENT_DEL_NOBLOCK);//该函数会直接将event从对应的fd的event链表中移除，依然存在于全局链表，可以再次event_add</span></div><div>            event_debug((</div><div>                &quot;event_process_active: event: %p, %s%s%scall %p&quot;,</div><div>...</div><div>        switch (evcb-&gt;evcb_closure) {</div><div>        <span style="color: #ff0000;">case EV_CLOSURE_EVENT_SIGNAL:</span></div><div>            EVUTIL_ASSERT(ev != NULL);</div><div>            <span style="color: #ff0000;">event_signal_closure(base, ev);</span></div><div>            break;</div><div><span style="color: #ff0000;">        case EV_CLOSURE_EVENT_PERSIST:</span></div><div>            EVUTIL_ASSERT(ev != NULL);</div><div>            <span style="color: #ff0000;">event_persist_closure(base, ev);//该函数会将event再次加入到对应的fd中</span></div><div>            break;</div><div>        <span style="color: #ff0000;">case EV_CLOSURE_EVENT: {</span></div><div>            void (*evcb_callback)(evutil_socket_t, short, void *);</div><div>            short res;</div><div>            EVUTIL_ASSERT(ev != NULL);</div><div>            evcb_callback = *ev-&gt;ev_callback;</div><div>            res = ev-&gt;ev_res;</div><div>            EVBASE_RELEASE_LOCK(base, th_base_lock);</div><div>            <span style="color: #ff0000;">evcb_callback(ev-&gt;ev_fd, res, ev-&gt;ev_arg);</span></div><div>        }</div><div>        break;</div><div>        <span style="color: #ff0000;">case EV_CLOSURE_CB_SELF:</span> {</div><div>            void (*evcb_selfcb)(struct event_callback *, void *) = evcb-&gt;evcb_cb_union.  </div><div>evcb_selfcb;</div><div>            EVBASE_RELEASE_LOCK(base, th_base_lock);</div><div>            <span style="color: #ff0000;">evcb_selfcb(evcb, evcb-&gt;evcb_arg);//执行对应的回调函数</span></div><div><span style="color: #ff0000;">...</span></div></div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>static void</div><div>event_queue_remove_active(struct event_base *base, struct event_callback *evcb)</div><div>{</div><div>    EVENT_BASE_ASSERT_LOCKED(base);</div><div>    if (EVUTIL_FAILURE_CHECK(!(evcb-&gt;evcb_flags &amp; EVLIST_ACTIVE))) {</div><div>        event_errx(1, &quot;%s: %p not on queue %x&quot;, __func__,</div><div>               evcb, EVLIST_ACTIVE);</div><div>        return;</div><div>    }</div><div>    DECR_EVENT_COUNT(base, evcb-&gt;evcb_flags);</div><div>    <span style="color: #ff0000;">evcb-&gt;evcb_flags &amp;= ~EVLIST_ACTIVE;</span></div><div>   <span style="color: #ff0000;"> base-&gt;event_count_active--;</span></div><div><span style="color: #ff0000;"><br clear="none"/></span></div><div><span style="color: #ff0000;"><br clear="none"/></span></div><div><span style="color: #ff0000;">    TAILQ_REMOVE(&amp;base-&gt;activequeues[evcb-&gt;evcb_pri],</span></div><div><span style="color: #ff0000;">        evcb, evcb_active_next);</span></div><div>}<span style="color: #ff0000;">//设置EV_PRESIST标志，触发事件会将激活队列对应的event移除，但是event还存在于全局event链表和fd链表</span></div></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>static inline void</div><div>event_signal_closure(struct event_base *base, struct event *ev)</div><div>{</div><div>    short ncalls;</div><div>    int should_break;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    /* Allows deletes to work */</div><div>   <span style="color: #ff0000;"> ncalls = ev-&gt;ev_ncalls;</span></div><div><span style="color: #ff0000;">    if (ncalls != 0)</span></div><div><span style="color: #ff0000;">        ev-&gt;ev_pncalls = &amp;ncalls;</span></div><div>    EVBASE_RELEASE_LOCK(base, th_base_lock);</div><div>    while (ncalls) {</div><div>       <span style="color: #ff0000;"> ncalls--;</span></div><div><span style="color: #ff0000;">        ev-&gt;ev_ncalls = ncalls;</span></div><div><span style="color: #ff0000;">        if (ncalls == 0)</span></div><div><span style="color: #ff0000;">            ev-&gt;ev_pncalls = NULL;</span></div><div>        (*ev-&gt;ev_callback)(ev-&gt;ev_fd, ev-&gt;ev_res, ev-&gt;ev_arg);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        EVBASE_ACQUIRE_LOCK(base, th_base_lock);</div><div>        should_break = base-&gt;event_break;</div><div>        EVBASE_RELEASE_LOCK(base, th_base_lock);</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        if (should_break) {</div><div>            if (ncalls != 0)</div><div>                ev-&gt;ev_pncalls = NULL;</div><div>            return;</div><div>        }</div><div>    }</div><div>}</div></div><div><br clear="none"/></div><div><br clear="none"/></div></span>
</div></body></html> 