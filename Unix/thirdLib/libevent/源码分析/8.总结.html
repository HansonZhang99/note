<html>
<head>
  <title>8.总结</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="923"/>
<h1>8.总结</h1>

<div>
<span><div><div><span style="font-weight: bold;">在调用任何libevent库方法之前，都要先创建一个event_base（事件发生器）。</span></div><div><span style="font-weight: bold;">一般调用函数event_base_new创建一个默认配置的event_base。</span></div><div><span style="font-weight: bold;">如果想要修改一些自定义的配置，可以调用相应的函数，函数event_base_new会调用函数event_config_new函数返回一个struct config的结构体，最后会调用event_base_new_with_config函数根据配置的config结构体，对event_base结构体进行初始化。</span></div><div><span style="font-weight: bold;">修改配置：</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">不使用特定的后端</span><span style="font-weight: bold;">，调用</span><span style="color: rgb(255, 0, 0); font-weight: bold;">event_config_avoid_method(struct config* config,char *avoid_method)</span><span style="font-weight: bold;">函数将传入的不使用的特定的后端的字符串添加到config结构的双向链表中，可以调用多次去禁用多个后端。</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">指定IO复用应该满足的特性</span><span style="font-weight: bold;">，调用函数</span><span style="color: rgb(255, 0, 0); font-weight: bold;">event_config_require_features（struct config* config,int features)</span><span style="font-weight: bold;">可以设置IO复用的特性，这些特性把包括EV_FEATURE_ET允许使用边沿触发（在Linux下只有epoll支持边沿触发），EV_FEATURE_FDS允许后端监听的是文件描述符，EV_FEATURE_O1添加，删除事件的时间复杂度为O(1),select和poll是不满足的,等。并不是所有的后端都支持这些标志的位运算组合。</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">设置event_base的属性</span><span style="font-weight: bold;">，上面的</span><span style="font-weight: bold;">event_config_require_features</span><span style="font-weight: bold;">函数指定所选后端所满足的特性，而函数</span><span style="color: rgb(255, 0, 0); font-weight: bold;">event_config_set_flags（struct config* config,int flag)</span><span style="font-weight: bold;">函数设置event_base的属性，这些属性有EVENT_BASE_FLAG_NOLOCK,表示不为event_base分配线程锁等。</span></div><div><br/></div><div><span style="font-weight: bold;">除此之外，还可以修改CPU的个数等。</span></div><div><br/></div><div><span style="font-weight: bold;">现在便设置好config结构体。</span></div><div><br/></div><div><span style="font-weight: bold;">在每个后端的实现文件中，libevent会为每个后端抽象出一个struct eventop的结构体，该结构体包括了后端的名字（我们要禁用特定后端会传入此字符串），如libevent下的select.c文件是对Linux下select多路复用的一个抽象，文件中定义了一个event_op结构体：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct selectop {</div><div>    int event_fds;      /* Highest fd in fd set */</div><div>    int event_fdsz;</div><div>    int resize_out_sets;</div><div>    fd_set *event_readset_in;</div><div>    fd_set *event_writeset_in;</div><div>    fd_set *event_readset_out;</div><div>    fd_set *event_writeset_out;</div><div>};//每个后端的不共有特征的集合</div><div><br/></div><div>const struct eventop selectops = {</div><div>    &quot;select&quot;,//多路复用名字</div><div>    select_init,//初始化select函数</div><div>    select_add,//将文件描述符或套接字或信号加入到IO复用中</div><div>    select_del,//删除指定的fd</div><div>    select_dispatch,//事件循环</div><div>    select_dealloc,//释放event_base中有关select的部分</div><div>    0, /* doesn't need reinit. *///如果我们需要在fork之后重新初始化event_base，则设置</div><div>    EV_FEATURE_FDS,//这个后端可以支持的event_method_features的位数组</div><div>    0,</div><div>};</div></div><div><br/></div><div><span style="font-weight: bold;">这些函数的实现也都在select.c文件中。</span></div><div><span style="font-weight: bold;">由于libevnt是一个跨平台的开源库，集成了多个平台的IO复用，但是在指定的平台上，只能使用对应平台支持的后端。</span><span style="font-weight: bold;">在Linux下./configure会检查系统环境，并生成一个event-config.h的文件，该文件中通过系统检测来定义一些宏，这些被定义的宏一般用于定义一些不同平台之间有所差异的变量。如在Linux下执行./configure,生成的event-config.h文件会定义</span><span style="font-weight: bold;">EVENT__HAVE_SELECT，</span><span style="font-weight: bold;">EVENT__HAVE_EPOLL，</span><span style="font-weight: bold;">EVENT__HAVE_POLL这三个宏。libevent的核心文件event.c中最开始就会进行条件宏的判断：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#ifdef EVENT__HAVE_EVENT_PORTS</div><div>extern const struct eventop evportops;</div><div>#endif</div><div>#ifdef EVENT__HAVE_SELECT</div><div>extern const struct eventop selectops;</div><div>#endif</div><div>...</div><div>static const struct eventop *eventops[] = {</div><div>#ifdef EVENT__HAVE_EVENT_PORTS</div><div>    &amp;evportops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_WORKING_KQUEUE</div><div>    &amp;kqops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_EPOLL</div><div>    &amp;epollops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_DEVPOLL</div><div>    &amp;devpollops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_POLL</div><div>    &amp;pollops,</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">...</span></div></div><div><span style="font-weight: bold;">最后由于平台原因，只有如上所述三个宏被定义，因此最后只有三个后端的eventop结构体会被记录到全局数组eventops中。event-config.h文件除了对后端的控制外，还会对不同平台一些其他差异进行调整。</span></div><div><br/></div><div><span style="font-weight: bold;">最后调用函数</span><span style="color: rgb(255, 0, 0); font-weight: bold;">event_base_new_with_config（struct *config)</span><span style="font-weight: bold;">返回一个event_base完成结构体event_base的创建。</span></div><div><span style="font-weight: bold;">该函数会创建一个event_base结构体，对其成员进行一系列的初始化，并将之前对config的配置引入，通过遍历全局数组和config的avoid链表来跳过指定的不使用的后端，直到找到第一个可使用的后端并使用它。（在全局数组eventops中所有的eventop结构都是按照IO复用的性能从高到排列的，所以使用的后但一定是除了我们指定不使用的后端外，此平台上性能最好的后端），最后event_base-&gt;evsel=eventop[i]，将后端结构体保存到event_base的成员evsel中。同时base-&gt;evbase=base-&gt;evsel-&gt;init(base)。调用对应后端的初始化函数对base并返回一个对应后端的特征结构体给event_base的evbase成员。</span></div><div><br/></div><div><span style="font-weight: bold;">至此event_base的配置结束。</span></div><div><br/></div><hr/><div><span style="font-weight: bold;">创建好event_base后，就会调用函数event_new或者event_assign来创建一个“事件”。</span></div><div><br/></div><div><span style="font-weight: bold;">函数event_new会为一个event结构体分配堆内存并调用event_assign函数对此event进行初始化。</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">int </span><span style="color: rgb(255, 0, 0); font-weight: bold;">event_assign(struct event *ev, struct event_base *base, evutil_socket_t fd, short</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">events, void (*callback)(evutil_socket_t, short, void *), void *arg)</span></div><div><br/></div><div><span style="font-weight: bold;">该函数会将此event是否在全局链表</span><span style="font-weight: bold;">global_debug_map中，并打印对应信息到日志文件。</span></div><div><span style="font-weight: bold;">并将fd,</span><span style="font-weight: bold;">events和回调函数以及回调函数的参数赋给event的对应成员，并设置</span><span style="color: rgb(209, 0, 255); font-weight: bold;">event-&gt;flags为EVLIST_INIT</span><span style="font-weight: bold;">状态。</span></div><div><br/></div><div><span style="font-weight: bold;">ev-&gt;ev_base=base;记录其所属的event_base</span></div><div><span style="font-weight: bold;">并进行判断，如果此fd为信号（events标志为EV_SIGNAL)，（就不能有标志EV_READ,EV_WRITE和EV_CLOSED标志，否则会出错）就将ev-&gt;closure=EV_CLOSURE_EVENT_SIGNAL。</span></div><div><br/></div><div><span style="font-weight: bold;">如果为套接还设置了EV_PERSIST标志，则ev-&gt;ev_closure = EV_CLOSURE_EVENT_PERSIST;否则为</span><span style="font-weight: bold;">EV_CLOSURE_EVENT。最后将此event加入到全局链表</span><span style="font-weight: bold;">global_debug_map中。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define EVLIST_TIMEOUT      0x01//event从属于定时器队列或者时间堆</div><div>#define EVLIST_INSERTED     0x02//event从属于注册队列</div><div>#define EVLIST_SIGNAL       0x04//没有使用</div><div>#define EVLIST_ACTIVE       0x08//event从属于活动队列</div><div>#define EVLIST_INTERNAL     0x10//该event是内部使用的。信号处理时有用到</div><div>#define EVLIST_ACTIVE_LATER 0x20</div><div>#define EVLIST_FINALIZING   0x40</div><div>#define EVLIST_INIT     0x80//event已经被初始化了</div><div>    </div><div>#define EVLIST_ALL          0xff//所有标志。这个不能取</div></div><div><br/></div><hr/><div><span style="font-weight: bold;">接下来就会调用函数event_add将事件加入到event_base中。</span></div><div><br/></div><div><span style="font-weight: bold;">函数</span><span style="font-weight: bold;">int </span><span style="font-weight: bold;">event_add(struct event *ev, const struct timeval *tv)</span></div><div><span style="font-weight: bold;">会调用函数</span><span style="font-weight: bold;">int </span><span style="font-weight: bold;">event_add_nolock_(struct event *ev, const struct timeval *tv,</span><span style="font-weight: bold;">int tv_is_absolute)其中传入的tv_is_absolute为0，即传入的为相对时间，所以libevent默认event_add擦传入的是相对时间。如果传入的tv不为NULL即event为超时事件，则在小根堆中为其预留一个位置（小根堆为一个struct event**类型数组）。</span></div><div><br/></div><div><span style="font-weight: bold;">这里暂时不分析超时事件的处理。</span></div><div><br/></div><div><span style="font-weight: bold;">根据events标志调用不同函数：</span></div><div><span style="font-weight: bold;">如果标志为EV_SIGNAL,调用函数</span><span style="font-weight: bold;">evmap_signal_add_，如果标志为EV_READ或EV_WRITE或EV_CLOSED位运算结果，则调用函数</span><span style="font-weight: bold;">evmap_io_add_，这两个函数在Linux下的定义大致相同。</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">event_base有一个成员</span><span style="color: rgb(255, 0, 0); font-weight: bold;">struct event_io_map io;和成员</span><span style="color: rgb(255, 0, 0); font-weight: bold;">struct event_signal_map sigmap;</span></div><div><span style="font-weight: bold;">这两个结构体都被定义为</span></div><div><span style="font-weight: bold;">#define event_io_map event_signal_map</span></div><div><span style="font-weight: bold;">struct event_signal_map {</span></div><div><span style="font-weight: bold;">    void **entries;</span></div><div><span style="font-weight: bold;">    int nentries;</span></div><div><span style="font-weight: bold;">};  </span></div><div><span style="font-weight: bold;">其中void **entries为一段分配的内存，这段内存中为nentries个evmap_io*的大小。其中</span><span style="font-weight: bold;">nentries大于</span><span style="font-weight: bold;">传入的套接字或文件描述符的整数值的大小，如果原来的</span><span style="font-weight: bold;">nentries小于或等于传入的fd大小，则会将</span><span style="font-weight: bold;">nentries加倍，直到大于传入的fd大小。很好理解这段内存是可扩展的，程序调用realloc函数在原基础上“加一段内存”。并更新event_io_map的</span><span style="font-weight: bold;">void **entries和</span><span style="font-weight: bold;">int nentries。接下来，通过判断fd的大小，将事件加入到ev</span><span style="font-weight: bold;">tries数组中。图示如下：</span></div><div><span style="font-weight: bold;"><img src="8.总结_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">如果数组evmap_io的对应成员为NULL，则为其创建一段内存并指向它，并将其成员都初始化为0。</span></div><div><br/></div><div><span style="font-weight: bold;">结构体struct evmap_io:</span></div><div><span style="font-weight: bold;">struct evmap_io {</span></div><div><span style="font-weight: bold;">    struct event_dlist events;//</span><span style="font-weight: bold;">struct event_dlist { struct event *lh_first; };</span></div><div><span style="font-weight: bold;">    ev_uint16_t nread;</span></div><div><span style="font-weight: bold;">    ev_uint16_t nwrite;</span></div><div><span style="font-weight: bold;">    ev_uint16_t nclose;</span></div><div><span style="font-weight: bold;">};</span></div><div><span style="font-weight: bold;">一个fd可以有EV_READ,EV_WRITE,EV_CLOSE三个标志，</span><span style="font-weight: bold;">nread,nwrite,nclose分别代表此fd对应的那个标志是否已经被使用（1为使用了，0为未被使用），在这里会判断传入的event如果使用同一fd已经使用的标志，则无法再次注册。所以对于同一个fd，他的三个标志每个只能被使用一次，只需要使用一次，即将其注册到可读，可写和关闭的队列，如果再出现一个此fd的时间，由于此fd已经添加到IO复用，只用将事件添加到fd的链表中即可。</span></div><div><br/></div><div><span style="font-weight: bold;">接下来机会调用对应后端的add函数：</span></div><div><span style="font-weight: bold;">evsel-&gt;add(base, ev-&gt;ev_fd,old, (ev-&gt;ev_events &amp; EV_ET) | res, extra) == -1)</span></div><div><br/></div><div><span style="font-weight: bold;">对于select来说，就是更新最大文件描述符和将对应fd根据不同标志加入到对用的fd_set位数组中。</span></div><div>if (sop-&gt;event_fds &lt; fd) {</div><div>        int fdsz = sop-&gt;event_fdsz;//更新select最大文件描述符，扩展内存</div><div>if (events &amp; EV_READ)</div><div>        FD_SET(fd, sop-&gt;event_readset_in);</div><div>    if (events &amp; EV_WRITE)</div><div>        FD_SET(fd, sop-&gt;event_writeset_in);//加入文件描述符到对应位数组</div><div><br/></div><div><span style="font-weight: bold;">然后更新nread，nwrite，nclose。</span></div><div><span style="font-weight: bold;">要注意的是，一个event可以注册多次，除了可以对同一fd注册EV_READ,EV_WRITE,EV_CLOSE外。</span></div><div><span style="font-weight: bold;">一个event可以注册多个fd，即每个event也有自己的一个链表，链接着所有的关联的fd的struct evmap_io结构体。</span></div><div><span style="font-weight: bold;">最后将fd对应struct evmap_io结构加入到event链表。</span></div><div><br/></div><div><span style="font-weight: bold;">同样一个信号可被多个event注册，一个event也可以注册多个信号。信号结构体：</span></div><div><span style="font-weight: bold;">struct evmap_signal {</span></div><div><span style="font-weight: bold;">    struct event_dlist events;</span></div><div><span style="font-weight: bold;">};只有链表成员。</span></div><div><br/></div><div><span style="font-weight: bold;">接下来回到函数</span><span style="font-weight: bold;">event_add_nolock_:</span></div><div><span style="font-weight: bold;">将信号或fd加入到对应的数组后，<span style="font-weight: bold; color: rgb(209, 0, 255);">event的flags标志就加上了EVLIST_INSERTED</span></span></div><div><span style="font-weight: bold;">同样信号也有对应注册过程，其被链接到event_base的struct </span><span style="font-weight: bold;">event_signal_map sigmap成员的void **entries成员上。</span></div><hr/><div><span style="font-weight: bold;">接下来是超时事件的注册，</span><span style="font-weight: bold;">在函数event_add_nolock函数最开始会检测参数tv的值，如果tv不为NULL，会在event_base的timeheap中为此超时event预留一个位置，应该知道的是：一个event可以被多次add，一个event可以注册为超时的同时，在超时事件过后会被激活，同时此event发生事件响应也会被激活一次，两种激活方式是互不影响。</span></div><div><br/></div><div><span style="font-weight: bold;">如果event被设置了标志EV_</span><span style="font-weight: bold;">CLOSURE_EVENT_PERSIST,这是在event_new是设置的，则直接设置此event的ev_io_timeout成员为超时值（记录相对时间）。（#define ev_io_timeout _ev.ev_io.ev_timeout,event-internal.h）</span></div><div><br/></div><div><span style="font-weight: bold;">一个event可以被重复添加，如果在重复添加一个event时此event正处于激活状态，且为超时event，就将其从激活队列中删除。</span></div><div><br/></div><div><span style="font-weight: bold;">超时事件的注册有两种方式，先说一种：</span></div><div><span style="font-weight: bold;">超时时间tv为在未来tv时间后超时，对于相对时间的记录需要相对时间和绝对时间来确定，将相对时间转换为绝对时间会更好处理。获取系统时间，并将tv相对时间转为绝对时间并保存到</span><span style="font-weight: bold;">ev_io_timeout中，并将event加入到小根堆中。加入</span><span style="color: rgb(209, 0, 255); font-weight: bold;">EVLIST_TIMEOUT</span><span style="font-weight: bold;">标志。</span></div><div><br/></div><div><span style="font-weight: bold;">最后将此事件在全局链表中标记为已添加状态。</span></div><div><span style="font-weight: bold;">这是第一种注册超时的方式。</span></div><div><br/></div><div><span style="font-weight: bold;">第二种方式：</span></div></div><div><span style="font-weight: bold;">当存在大量具有相同超时时间的event被注册时，就会用到common-timeout。</span></div><div><span style="font-weight: bold;">首先要想使用ct，就必须自己调用函数：</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">const struct timeval * </span><span style="color: rgb(255, 0, 0); font-weight: bold;">event_base_init_common_timeout(struct event_base *base,</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">const struct timeval *duration)</span></div><div><span style="font-weight: bold;">此函数接受一个公共超时值，也就时event的超时时间，再返回一个tv结构。</span></div><div><span style="font-weight: bold;">由于event_add只有两个参数，我们想要注册到ct而不是小根堆就必须向这两个参数加入某个特征。事实上，是在第二个参数tv中加入特征表示此event为ct。结构体tv有两个成员tv_usec是为微秒，所以其值最大应该为999999.只用20bit就可以存储，而其为32bit变量，就还剩12bit未使用，libevent就利用了着12bit来区分event的注册方式。</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">使用最高4bit作为标志位，标志它是一个专门用于ct的时间。</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">后8bit</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">用来记录该超时时长在common_timeout_queues数组中的位置。</span></div><div><span style="font-weight: bold;">这也限制了common_timeout_queues数组的长度，最大为2的8次方，即256。</span></div><div><br/></div><div><span style="font-weight: bold;">libevent还定义了一系列宏去按位与上usec取出这12bit。</span></div><div><span style="font-weight: bold;">COMMON_TIMEOUT_MICROSECONDS_MASK和</span><span style="font-weight: bold;">MICROSECONDS_MASK 取出usec的前12bit。</span></div><div><span style="font-weight: bold;">COMMON_TIMEOUT_IDX_MASK取出前12bit的后8bit</span></div><div><span style="font-weight: bold;">COMMON_TIMEOUT_MASK取出前12bit的前4bit</span></div><div><span style="font-weight: bold;">#define COMMON_TIMEOUT_MAGIC    0x50000000为ct标志</span></div><div><br/></div><div>static inline int</div><div>is_common_timeout(const struct timeval *tv,</div><div>    const struct event_base *base)</div><div>{</div><div>    int idx;</div><div>    //不具有common-timeout标志位，那么就肯定不是commont-timeout时间了</div><div>    if ((tv-&gt;tv_usec &amp; COMMON_TIMEOUT_MASK) != COMMON_TIMEOUT_MAGIC)</div><div>        return 0;</div><div>    idx = COMMON_TIMEOUT_IDX(tv);//获取数组下标</div><div>    return idx &lt; base-&gt;n_common_timeouts;</div><div>}</div><div><span style="font-weight: bold;">该函数用来判断此tv是否为ct类型的tv</span></div><div><br/></div><div><span style="font-weight: bold;">接下来就是去获取一个ct时间，也就是：</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">const struct timeval * </span><span style="color: rgb(255, 0, 0); font-weight: bold;">event_base_init_common_timeout(struct event_base *base,</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">const struct timeval *duration)</span><span style="font-weight: bold;">函数</span></div><div><span style="font-weight: bold;">此函数传入一个普通tv，返回一个带有ct标志的tv。</span></div><div><br/></div><div><span style="font-weight: bold;">函数首先判断tv的usec的值，如果大于1000000，就进位为1s，并更新tv的值。</span></div><div><span style="font-weight: bold;">然后在event_base的</span><span style="font-weight: bold;">struct common_timeout_list **common_timeout_queues;成员也就是</span><span style="font-weight: bold;">common_timeout_queues数组中找是否已经存在此tv，如果存在就证明之前已经申请过此tv了，直接返回。</span></div><div><br/></div><div><span style="font-weight: bold;">base的</span><span style="font-weight: bold;">n_common_timeouts记录了当前event_base中</span><span style="font-weight: bold;">common_timeout_queues的长度，限制为256，如果超过就返回，不能再注册。</span></div><div><span style="font-weight: bold;">base的</span><span style="font-weight: bold;">n_common_timeouts_allocated为已经分配的</span><span style="font-weight: bold;">common_timeout_queues的长度。此数组是动态分配的。分配了不一定会使用。如果分配的内存已被完全使用，即</span><span style="font-weight: bold;">base-&gt;n_common_timeouts_allocated == base-&gt;n_common_timeouts，就再次分配，分配以16开始倍增。</span></div><div><br/></div><div><span style="font-weight: bold;">如果此tv并没有被注册到common_timeout_queues数组过，就为此tv分配一个common_timeout_list结构：</span></div><div><span style="font-weight: bold;">struct common_timeout_list {</span></div><div><span style="font-weight: bold;">    //超时event队列。将所有具有相同超时时长的超时event放到一个队列里面</span></div><div><span style="font-weight: bold;">    struct event_list events;</span></div><div><span style="font-weight: bold;">    struct timeval duration;//超时时长</span></div><div><span style="font-weight: bold;">    struct event</span> <span style="color: rgb(255, 0, 0); font-weight: bold;">timeout_event</span><span style="font-weight: bold;">;//具有相同超时时长的超时event代表</span></div><div><span style="font-weight: bold;">    struct event_base *base;</span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">其次结构体</span><span style="font-weight: bold;">不仅记录了tv值，还会创建event：</span><span style="color: rgb(255, 0, 0); font-weight: bold;">timeout_event</span><span style="font-weight: bold;">。此event参数就是此ctl结构体，回调函数为</span><span style="color: rgb(255, 0, 0); font-weight: bold;">common_timeout_callback</span><span style="font-weight: bold;">。</span><span style="font-weight: bold;">并设置<span style="font-weight: bold; color: rgb(255, 0, 0);">ev-&gt;flags标志</span></span><span style="color: rgb(209, 0, 255); font-weight: bold;">EVLIST_INTERNAL</span><span style="font-weight: bold;">，</span><span style="color: rgb(255, 0, 0); font-weight: bold;">优先级为0</span><span style="font-weight: bold;">（最高，超时事件）。</span><span style="font-weight: bold;">在回调函数中，有了这个指针，就可以访问events变量，即访问到该结构体上的所有超时event。于是就能手动激活这些超时event。</span></div><div><br/></div><div><span style="font-weight: bold;">将tv记录到此结构，并加上ct标志，记录event_base到此结构，将其放入：base-&gt;common_timeout_queues[base-&gt;n_common_timeouts++] = new_ctl;返回tv，今后使用此tv注册的事件，就都会注册到</span><span style="font-weight: bold;">common_timeout_queues</span><span style="font-weight: bold;">对应的位置。最后返回带有ct标志的tv结构。</span></div><div><br/></div><div><span style="font-weight: bold;">接下来在event_add函数中，其注册方式就改变了，调用event_add的此二个参数如果是一个经过event_base_init_common_timeout初始化的tv，就会采用ct注册，将其转为绝对事件加入标志位。并注册到event_base的common_timeout_queues数组对应下标的链表，函数event_queue_insert_timeout(base, ev);在此event的tv为ct或者普通时，会有不同行为：</span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">static void</span></div><div><span style="font-weight: bold;">event_queue_insert_timeout(struct event_base *base, struct event *ev)</span></div><div><span style="font-weight: bold;">{</span></div><div><span style="font-weight: bold;">    ...</span></div><div><span style="font-weight: bold;">    ev-&gt;ev_flags |= EVLIST_TIMEOUT;</span></div><div><br/></div><div><span style="font-weight: bold;">    if (is_common_timeout(&amp;ev-&gt;ev_timeout, base)) {</span></div><div><span style="font-weight: bold;">        struct common_timeout_list *ctl =</span></div><div><span style="font-weight: bold;">   </span><span style="color: rgb(255, 0, 0); font-weight: bold;">         get_common_timeout_list(base, &amp;ev-&gt;ev_timeout);//根据超时值从event_base的</span><span style="color: rgb(255, 0, 0); font-weight: bold;">common_timeout_queues获取对应</span><span style="color: rgb(255, 0, 0); font-weight: bold;">struct common_timeout_list *ctl</span></div><div><span style="font-weight: bold;">        </span><span style="color: rgb(255, 0, 0); font-weight: bold;">insert_common_timeout_inorder(ctl, ev);</span></div><div><span style="font-weight: bold;">    } else {</span></div><div><span style="font-weight: bold;">        </span><span style="color: rgb(255, 0, 0); font-weight: bold;">min_heap_push_(&amp;base-&gt;timeheap, ev);//加入小根堆</span></div><div><span style="font-weight: bold;">    }</span></div><div><span style="font-weight: bold;">}</span></div><div><br/></div><div><span style="font-weight: bold;">static void</span></div><div><span style="font-weight: bold;">insert_common_timeout_inorder(struct common_timeout_list *ctl,</span></div><div><span style="font-weight: bold;">    struct event *ev)</span></div><div><span style="font-weight: bold;">{</span></div><div><span style="font-weight: bold;">    struct event *e;</span></div><div><br/></div><div><span style="font-weight: bold;">    TAILQ_FOREACH_REVERSE(e, &amp;ctl-&gt;events,</span></div><div><span style="font-weight: bold;">        event_list, ev_timeout_pos.ev_next_with_common_timeout) {</span></div><div><span style="font-weight: bold;">     //虽然有相同超时时长，但超时时间却是 超时时长 + 调用event_add的时间。</span></div><div><span style="font-weight: bold;">    //所以是在不同的时间触发超时的。它们根据绝对超时时间，升序排在队列中。</span></div><div><span style="font-weight: bold;">    //一般来说，直接插入队尾即可。因为后插入的，绝对超时时间肯定大。</span></div><div><span style="font-weight: bold;">    //但由于线程抢占的原因，可能一个线程在evutil_timeradd(&amp;now, &amp;tmp, &amp;ev-&gt;ev_timeout);</span></div><div><span style="font-weight: bold;">    //执行完，还没来得及插入，就被另外一个线程抢占了。而这个线程也是要插入一个</span></div><div><span style="font-weight: bold;">    //common-timeout的超时event。这样就会发生：超时时间小的反而后插入。</span></div><div><span style="font-weight: bold;">    //所以要从后面开始遍历队列，寻找一个合适的地方。</span></div><div><span style="font-weight: bold;">        ...</span></div><div><span style="font-weight: bold;">        if (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;e-&gt;ev_timeout, &gt;=)) {</span></div><div><span style="font-weight: bold;">            TAILQ_INSERT_AFTER(&amp;ctl-&gt;events, e, ev,</span> <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(250, 250, 250);"><span style="background-color: rgb(250, 250, 250); font-size: 14px; font-family: &quot;Source Code Pro&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Anonymous Pro&quot;, &quot;Droid Sans Mono&quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">//从队列后面插入</span></span></div><div><span style="font-weight: bold;">                ev_timeout_pos.ev_next_with_common_timeout);</span></div><div><span style="font-weight: bold;">            return;</span></div><div><span style="font-weight: bold;">        }</span></div><div><span style="font-weight: bold;">    }</span></div><div><span style="font-weight: bold;">    </span> <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(250, 250, 250); font-family: &quot;Source Code Pro&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Anonymous Pro&quot;, &quot;Droid Sans Mono&quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">//在队列头插入，只会发生在前面的寻找都没有寻找到的情况下</span></div><div><span style="font-weight: bold;">    TAILQ_INSERT_HEAD(&amp;ctl-&gt;events, ev,</span></div><div><span style="font-weight: bold;">        ev_timeout_pos.ev_next_with_common_timeout);</span></div><div><span style="font-weight: bold;">}</span></div><div><br/></div><div><span style="font-weight: bold;">超时时间却是 超时时长 + 调用event_add的时间,加入到</span><span style="font-weight: bold;">common_timeout_queues数组的对应位置的链表的对应位置。</span></div><div><br/></div><div><span style="font-weight: bold;">函数event_add还没完，如果此event注册到ctl的events链表且为第一个元素，将其加入</span> <span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">common_timeout_queues数组的同时，以绝对时间注册清空了ct标志的ctl结构的event事件到event_base，这样，ctl链表的自身成员注册到小根堆，此成员在超时时间后被激活，同时会调用回调函数：</span></div><div><span style="font-weight: bold;">static void </span><span style="font-weight: bold;">common_timeout_callback(evutil_socket_t fd, short what, void *arg)</span></div><div><span style="font-weight: bold;">其参数为自身结构</span></div><div><span style="font-weight: bold;">此函数会遍历自身的event链表，即有着相同tv的但是有着不同绝对时间的event集合，并从第一个event开始判断是否超时，并手动激活这些event，然后从链表中删除。当然，如果第一次event还没超时，那么所有event都不会超时。第一个event的超时时间一定是最近的。</span></div><div><span style="font-weight: bold;">如果还有未超时的event，就将ctl的event再次加入到event_base，此次的超时时间为当前链表中第一个event的绝对超时值。</span></div><div><br/></div><div><span style="font-weight: bold;">至此event_add就分析完了。</span></div><div><br/></div><div><span style="font-weight: bold;">最后调用函数event_base_loop</span></div><div><br/></div><div><span style="font-weight: bold;">该函数获取小根堆中第一个结构的tv（第一个tv为最小的），并根据tv-noew_time获取到一个相对时间用于io复用函数的超时值。</span></div><div><span style="font-weight: bold;">接下来根据当前时间，遍历小根堆是否有事件超时（遇到没有超时的就不用往后遍历了），并将超时事件添加到激活队列。</span></div><div><span style="font-weight: bold;">接下来调用io复用函数，io复用函数返回，会将激活的event加入到激活队列。</span></div><div><span style="font-weight: bold;">最后处理激活队列事件，如果事件带有PERSIST标志，则再次注册，</span></div><div><span style="font-weight: bold;">对于超时事件，无论是tv还是ct的tv，都记录到event结构这种，只需要判断tv的类型，就可以将event再次注册到对应超时队列中。</span></div><div><span style="font-weight: bold;">如果激活的event是ctl数组放到小根堆中的event，调用此event的回调函数会将遍历ctl成员的超时链表，并根据超时值来判断是否激活，同样链表中超时值递增排列。如果链表没处理完，即里面还有未超时的event，就更新ctl的event的tv并再次添加到小根堆，接下来loop循环会再次获取小根堆中最小的tv，将其作为io复用的超时值。再次遍历小根堆中event到激活队列，io复用返回，将event添加到激活队列。激活队列事件运行，如此往复。。。，值得注意的是，如果ctl中event并不是一个PERSIST的event，它会在此ctl链中有超时event时被添加到小根堆中。没有时，第一个event通过event_add到此ctl的链表时，ctl的event会被再次add。</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 