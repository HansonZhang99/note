<html>
<head>
  <title>5.串口驱动分析（二）open</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="671"/>
<h1>5.串口驱动分析（二）open</h1>

<div>
<span><div><div><span style="font-size: 12pt;">        对tty设备的打开操作，经过虚拟文件系统VFS层，字符设备驱动层，最后到达cdev的tty_open函数，也是被调用的tty子系统的第一个函数。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="color: rgb(65, 173, 28); font-size: 12pt;">分析tty_open函数，为了方便分析，只列出主要部分：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">static int tty_open(struct inode *inode, struct file *filp)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    struct</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">tty_struct *tty = NULL</span><span style="font-size: 12pt;">;</span></div><div><span style="font-size: 12pt;">    int noctty, retval;</span></div><div><span style="font-size: 12pt;">    struct tty_driver *driver;</span></div><div><span style="font-size: 12pt;">    int index;</span></div><div><span style="font-size: 12pt;">   <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> dev_t device = inode-&gt;i_rdev;</span></span></div><div><span style="font-size: 12pt;">    unsigned saved_flags = filp-&gt;f_flags;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    nonseekable_open(inode, filp);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">retry_open:</span></div><div><span style="font-size: 12pt;">    noctty = filp-&gt;f_flags &amp; O_NOCTTY;</span></div><div><span style="font-size: 12pt;">    index  = -1;</span></div><div><span style="font-size: 12pt;">    retval = 0;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">driver = get_tty_driver(device, &amp;index);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">        <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">tty = tty_init_dev(driver, index, 0);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">  <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">  retval = tty_add_file(tty, filp);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    check_tty_count(tty, &quot;tty_open&quot;);</span></div><div><span style="font-size: 12pt;">    if (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY &amp;&amp;</span></div><div><span style="font-size: 12pt;">        tty-&gt;driver-&gt;subtype == PTY_TYPE_MASTER)</span></div><div><span style="font-size: 12pt;">        noctty = 1;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    if (tty-&gt;ops-&gt;open)</span></div><div><span style="font-size: 12pt;">       <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> retval = tty-&gt;ops-&gt;open(tty, filp);</span></span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">函数分析：</span></div><ul><li><div><span style="font-size: 12pt;">通过inode-&gt;i_rdev域得到设备号，调用函数get_tty_driver，该函数会遍历tty_driver链表，通过设备号找到对应的tty_driver的地址，并返回其index。</span></div></li><li><div><span style="font-size: 12pt;">调用函数tty_init_dev，此函数需要分析:</span></div></li></ul><div><span style="font-size: 12pt;">        struct tty_struct *</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">tty_init_dev</span><span style="font-size: 12pt;">(struct tty_driver *driver, int idx,</span></div><div><span style="font-size: 12pt;">                                int first_ok)</span></div><div><span style="font-size: 12pt;">        {</span></div><div><span style="font-size: 12pt;">                struct tty_struct *tty;</span></div><div><span style="font-size: 12pt;">                int retval;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">               <span style="font-size: 12pt; color: rgb(255, 0, 0);"> tty = alloc_tty_struct(</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">);/*</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">函数alloc_tty_struct只是为tty_struct分配内存*/</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">           <span style="font-size: 12pt; color: rgb(255, 0, 0);"> </span><span style="font-size: 12pt; color: rgb(255, 0, 0);">    initialize_tty_struct(tty, driver, idx);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">                tty_ldisc_setup(tty, tty-&gt;link);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">                return tty;</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">        </span></div><div><span style="font-size: 12pt;">函数</span><span style="font-size: 12pt;">initialize_tty_struct将初始化tty的一些参数。</span></div><div><span style="font-size: 12pt;">调用</span><span style="font-size: 12pt;">tty_ldisc_init(tty)初始化tty_struct结构的ldisc的ops域，对于N_TTY(0)，其ops域指向此结构：</span></div><div><span style="font-size: 12pt;">struct tty_ldisc_ops tty_ldisc_N_TTY = {</span></div><div><span style="font-size: 12pt;">    .magic           = TTY_LDISC_MAGIC,</span></div><div><span style="font-size: 12pt;">    .name            = &quot;n_tty&quot;,</span></div><div><span style="font-size: 12pt;">    .open            = n_tty_open,</span></div><div><span style="font-size: 12pt;">    .close           = n_tty_close,</span></div><div><span style="font-size: 12pt;">    .flush_buffer    = n_tty_flush_buffer,</span></div><div><span style="font-size: 12pt;">    .chars_in_buffer = n_tty_chars_in_buffer,</span></div><div><span style="font-size: 12pt;">    .read            = n_tty_read,</span></div><div><span style="font-size: 12pt;">    .write           = n_tty_write,</span></div><div><span style="font-size: 12pt;">    .ioctl           = n_tty_ioctl,</span></div><div><span style="font-size: 12pt;">    .set_termios     = n_tty_set_termios,</span></div><div><span style="font-size: 12pt;">    .poll            = n_tty_poll,</span></div><div><span style="font-size: 12pt;">    .receive_buf     = n_tty_receive_buf,</span></div><div><span style="font-size: 12pt;">    .write_wakeup    = n_tty_write_wakeup</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">调用</span><span style="font-size: 12pt;">tty_buffer_init函数初始化tty_struct-&gt;buf域的成员如tail,head等，初始化工作队列。将tty_driver的ops域保存到tty_struct结构，将tty_driver自己保存到tty_struct,将index保存到tty_struct，并通过</span><span style="font-size: 12pt;">tty_get_device(tty)函数将tty_driver的dev域保存到tty_struct中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">调用函数</span><span style="font-size: 12pt;">tty_ldisc_setup，此函数会调用tty-&gt;ldisc-&gt;ops-&gt;open函数——n_tty_open:</span></div><div><span style="font-size: 12pt;">static int n_tty_open(struct tty_struct *tty)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">        <span style="font-size: 12pt; color: rgb(255, 0, 0);">tty-&gt;read_buf = kzalloc(N_TTY_BUF_SIZE, GFP_KERNEL);/*分配内存*/</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">        tty-&gt;echo_buf = kzalloc(N_TTY_BUF_SIZE, GFP_KERNEL);/*分配内存*/</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">        <span style="font-size: 12pt; color: rgb(255, 0, 0);">reset_buffer_flags(tty);/*初始化*/</span></span></div><div><span style="font-size: 12pt;">        tty-&gt;column = 0;</span></div><div><span style="font-size: 12pt;">        n_tty_set_termios(tty, NULL);</span></div><div><span style="font-size: 12pt;">        tty-&gt;minimum_to_wake = 1;</span></div><div><span style="font-size: 12pt;">        tty-&gt;closing = 0;</span></div><div><span style="font-size: 12pt;">    return 0;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">static void</span> <span style="font-size: 12pt; color: rgb(255, 0, 0);">reset_buffer_flags</span><span style="font-size: 12pt;">(struct tty_struct *tty)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    tty-&gt;read_head = tty-&gt;read_tail = tty-&gt;read_cnt = 0;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    tty-&gt;echo_pos = tty-&gt;echo_cnt = tty-&gt;echo_overrun = 0;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    tty-&gt;canon_head = tty-&gt;canon_data = tty-&gt;erasing = 0;</span></div><div><span style="font-size: 12pt;">    memset(&amp;tty-&gt;read_flags, 0, sizeof tty-&gt;read_flags);</span></div><div><span style="font-size: 12pt;">    n_tty_set_room(tty);</span></div><div><span style="font-size: 12pt;">    check_unthrottle(tty);</span></div><div><span style="font-size: 12pt;">}</span></div><ul><li><div><span style="font-size: 12pt;">调用函数</span><span style="font-size: 12pt;">tty_add_file,将file-&gt;private_data域指向tty,并将priv加入到全局链表</span><span style="font-size: 12pt;">tty-&gt;tty_files</span></div></li><li><div><span style="font-size: 12pt;">最后调用tty-&gt;ops-&gt;open即函数uart_open函数。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(65, 173, 28);">调用到uart_open函数，就到了核心层。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">static int uart_open(struct tty_struct *tty, struct file *filp)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    struct uart_driver *drv = (struct uart_driver *)tty-&gt;driver-&gt;driver_state;</span></div><div><span style="font-size: 12pt;">    struct uart_state *state;</span></div><div><span style="font-size: 12pt;">    struct tty_port *port;</span></div><div><span style="font-size: 12pt;">    int retval, line = tty-&gt;index;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">state = uart_get(drv, line);/*返回uart_driver的state[index]*/</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    port = &amp;state-&gt;port;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    tty-&gt;driver_data = state;</span></div><div><span style="font-size: 12pt;">    state-&gt;uart_port-&gt;state = state;</span></div><div><span style="font-size: 12pt;">    tty-&gt;low_latency = (state-&gt;uart_port-&gt;flags &amp; UPF_LOW_LATENCY) ? 1 : 0;</span></div><div><span style="font-size: 12pt;">    tty-&gt;alt_speed = 0;</span></div><div><span style="font-size: 12pt;">    tty_port_tty_set(port, tty);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">retval = uart_startup(tty, state, 0);/*函数uart_startup最终调用uart_driver的state-&gt;uart_port-&gt;ops-&gt;startup函数，即最底层的</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_serial_startup函数*/</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="5.串口驱动分析（二）open_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 12pt;"><img src="5.串口驱动分析（二）open_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">static int s3c24xx_serial_startup(struct uart_port *port)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    struct s3c24xx_uart_port *ourport = to_ourport(port);</span></div><div><span style="font-size: 12pt;">    int ret;</span></div><div><span style="font-size: 12pt;">    rx_enabled(port) = 1;</span></div><div><span style="font-size: 12pt;">    <font color="#FF0000">ret = request_irq(ourport-&gt;rx_irq, s3c24xx_serial_rx_chars, 0,</font></span></div><div><span style="font-size: 12pt;"><font color="#FF0000">              s3c24xx_serial_portname(port), ourport);</font></span></div><div><span style="font-size: 12pt;"><font color="#FF0000"><br/></font></span></div><div><span style="font-size: 12pt;">    ourport-&gt;rx_claimed = 1;</span></div><div><span style="font-size: 12pt;">    tx_enabled(port) = 1;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   <font color="#FF0000"> ret = request_irq(ourport-&gt;tx_irq, s3c24xx_serial_tx_chars, 0,</font></span></div><div><span style="font-size: 12pt;"><font color="#FF0000">              s3c24xx_serial_portname(port), ourport)；</font></span></div><div><span style="font-size: 12pt;">    ourport-&gt;tx_claimed = 1;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">经过层层的调用，最后调用函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_serial_startup</span><span style="font-size: 12pt;">完成硬件的初始化，并申请中断。需要注意的是，硬件此时只打开了接收中断。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">        </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 