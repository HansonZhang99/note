<html>
<head>
  <title>1.gpio模拟i2c</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="878"/>
<h1>1.gpio模拟i2c</h1>

<div>
<span><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/* USER CODE BEGIN Header */</div><div>/**</div><div>  ******************************************************************************</div><div>  * @file           : main.c</div><div>  * @brief          : Main program body</div><div>  ******************************************************************************</div><div>  ** This notice applies to any and all portions of this file</div><div>  * that are not between comment pairs USER CODE BEGIN and</div><div>  * USER CODE END. Other portions of this file, whether</div><div>  * inserted by the user or by software development tools</div><div>  * are owned by their respective copyright owners.</div><div>  *</div><div>  * COPYRIGHT(c) 2019 STMicroelectronics</div><div>  *</div><div>  * Redistribution and use in source and binary forms, with or without modification,</div><div>  * are permitted provided that the following conditions are met:</div><div>  *   1. Redistributions of source code must retain the above copyright notice,</div><div>  *      this list of conditions and the following disclaimer.</div><div>  *   2. Redistributions in binary form must reproduce the above copyright notice,</div><div>  *      this list of conditions and the following disclaimer in the documentation</div><div>  *      and/or other materials provided with the distribution.</div><div>  *   3. Neither the name of STMicroelectronics nor the names of its contributors</div><div>  *      may be used to endorse or promote products derived from this software</div><div>  *      without specific prior written permission.</div><div>  *</div><div>  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div><div>  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div>  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</div><div>  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</div><div>  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</div><div>  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</div><div>  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</div><div>  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</div><div>  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</div><div>  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div><div>  *</div><div>  ******************************************************************************</div><div>  */</div><div>/* USER CODE END Header */</div><div><br/></div><div><br/></div><div>/* Includes ------------------------------------------------------------------*/</div><div>#include &quot;main.h&quot;</div><div>#include &quot;usart.h&quot;</div><div>#include &quot;gpio.h&quot;</div><div><br/></div><div><br/></div><div>/* Private includes ----------------------------------------------------------*/</div><div>/* USER CODE BEGIN Includes */</div><div><br/></div><div><br/></div><div>/* USER CODE END Includes */</div><div><br/></div><div><br/></div><div>/* Private typedef -----------------------------------------------------------*/</div><div>/* USER CODE BEGIN PTD */</div><div><br/></div><div><br/></div><div>/* USER CODE END PTD */</div><div><br/></div><div><br/></div><div>/* Private define ------------------------------------------------------------*/</div><div>/* USER CODE BEGIN PD */</div><div><br/></div><div><br/></div><div>/* USER CODE END PD */</div><div><br/></div><div><br/></div><div>/* Private macro -------------------------------------------------------------*/</div><div>/* USER CODE BEGIN PM */</div><div><br/></div><div><br/></div><div>/* USER CODE END PM */</div><div><br/></div><div><br/></div><div>/* Private variables ---------------------------------------------------------*/</div><div><br/></div><div><br/></div><div>/* USER CODE BEGIN PV */</div><div><br/></div><div><br/></div><div>/* USER CODE END PV */</div><div><br/></div><div><br/></div><div>/* Private function prototypes -----------------------------------------------*/</div><div>void SystemClock_Config(void);</div><div>/* USER CODE BEGIN PFP */</div><div><br/></div><div><br/></div><div>/* USER CODE END PFP */</div><div><br/></div><div><br/></div><div>/* Private user code ---------------------------------------------------------*/</div><div>/* USER CODE BEGIN 0 */</div><div><br/></div><div><br/></div><div>#include &lt;stdio.h&gt;</div><div>/* Private includes ----------------------------------------------------------*/</div><div>/* USER CODE BEGIN Includes */</div><div>#ifdef __GNUC__</div><div>#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</div><div>#else</div><div>#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</div><div>#endif</div><div>/* USER CODE END PFP */</div><div>/* USER CODE BEGIN 0 */</div><div>PUTCHAR_PROTOTYPE</div><div>{</div><div>    HAL_UART_Transmit(&amp;huart1 , (uint8_t *)&amp;ch, 1, 0xFFFF);</div><div>    return ch;</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>void MX_GPIO_Init(void)</div><div>{</div><div><br/></div><div><br/></div><div>  GPIO_InitTypeDef GPIO_InitStruct;</div><div><br/></div><div><br/></div><div>  /* GPIO Ports Clock Enable */</div><div>  __HAL_RCC_GPIOH_CLK_ENABLE();</div><div>  //__HAL_RCC_GPIOG_CLK_ENABLE();</div><div>  __HAL_RCC_GPIOC_CLK_ENABLE();</div><div>  __HAL_RCC_GPIOB_CLK_ENABLE();</div><div><br/></div><div><br/></div><div>  /*Configure GPIO pin Output Level */</div><div>  //HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);</div><div><br/></div><div><br/></div><div>  /*Configure GPIO pin Output Level */</div><div>  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13|GPIO_PIN_14, GPIO_PIN_RESET);</div><div><br/></div><div><br/></div><div>  /*Configure GPIO pin : PG7 */</div><div>/* GPIO_InitStruct.Pin = GPIO_PIN_13;</div><div>  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</div><div>  GPIO_InitStruct.Pull = GPIO_NOPULL;</div><div>  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</div><div>  HAL_GPIO_Init(GPIOG, &amp;GPIO_InitStruct);*/</div><div><br/></div><div><br/></div><div>  /*Configure GPIO pins : PB6 PB9 */</div><div>  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14;                        </div><div>  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;               </div><div>  GPIO_InitStruct.Pull = GPIO_NOPULL;                                          </div><div>  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</div><div>  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);                                   </div><div>}</div><div>#define GPIO_PORT_I2C    GPIOB                 </div><div>#define I2C_SCL_PIN        GPIO_PIN_13             </div><div>#define I2C_SDA_PIN        GPIO_PIN_14            </div><div><br/></div><div><br/></div><div>#define SDA_IN()  {GPIOB-&gt;MODER&amp;=~(3&lt;&lt;(14*2));GPIOB-&gt;MODER|=0&lt;&lt;14*2;}    </div><div>#define SDA_OUT() {GPIOB-&gt;MODER&amp;=~(3&lt;&lt;(14*2));GPIOB-&gt;MODER|=1&lt;&lt;14*2;}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>#define I2C_SCL_1()  GPIO_PORT_I2C-&gt;BSRR = I2C_SCL_PIN                            // SCL = 1</div><div>#define I2C_SCL_0()  GPIO_PORT_I2C-&gt;BSRR = (uint32_t)I2C_SCL_PIN &lt;&lt; 16U          // SCL = 0</div><div><br/></div><div><br/></div><div>#define I2C_SDA_1()  GPIO_PORT_I2C-&gt;BSRR = GPIO_PIN_14                           // SDA = 1</div><div>#define I2C_SDA_0()  GPIO_PORT_I2C-&gt;BSRR = (uint32_t)GPIO_PIN_14 &lt;&lt; 16U          // SDA = 0</div><div><br/></div><div><br/></div><div>#define I2C_SDA_READ()  (GPIO_PORT_I2C-&gt;IDR &amp; GPIO_PIN_14)                       </div><div>#define I2C_SCL_READ()  (GPIO_PORT_I2C-&gt;IDR &amp; I2C_SCL_PIN)                      </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>static void i2c_Delay(void)</div><div>{</div><div>    uint8_t i;</div><div>    for (i = 0; i &lt; 100; i++);</div><div>}</div><div>void i2c_Start(void)</div><div>{</div><div>    </div><div>    </div><div>    I2C_SDA_1();</div><div>    I2C_SCL_1();</div><div>    i2c_Delay();</div><div>    I2C_SDA_0();</div><div>    i2c_Delay();</div><div>    </div><div>    I2C_SCL_0();</div><div>    i2c_Delay();</div><div>}</div><div><br/></div><div><br/></div><div>void i2c_Stop(void)</div><div>{</div><div>   </div><div>    I2C_SCL_0();</div><div>    I2C_SDA_0();</div><div>    i2c_Delay();</div><div>    I2C_SCL_1();</div><div>    I2C_SDA_1();</div><div>    i2c_Delay();</div><div>}</div><div>void i2c_SendByte(uint8_t _ucByte)</div><div>{</div><div>    uint8_t i;</div><div>    </div><div>   </div><div>    for (i = 0; i &lt; 8; i++)</div><div>    {</div><div>        if (_ucByte &amp; 0x80)</div><div>        {</div><div>            I2C_SDA_1();</div><div>        }</div><div>        else</div><div>        {</div><div>            I2C_SDA_0();</div><div>        }</div><div>        i2c_Delay();</div><div>        I2C_SCL_1();</div><div>        i2c_Delay();</div><div>        I2C_SCL_0();</div><div>        if (i == 7)</div><div>        {</div><div>             I2C_SDA_1();     </div><div>        }</div><div>        _ucByte &lt;&lt;= 1;       </div><div>        i2c_Delay();</div><div>    }</div><div>}</div><div>uint8_t i2c_ReadByte(void)</div><div>{</div><div>    uint8_t i;</div><div>    uint8_t value;</div><div><br/></div><div><br/></div><div>    </div><div>    value = 0;</div><div>    for (i = 0; i &lt; 8; i++)</div><div>    {</div><div>        value &lt;&lt;= 1;</div><div>        I2C_SCL_1();</div><div>        i2c_Delay();</div><div>        if (I2C_SDA_READ())</div><div>        {</div><div>            value++;</div><div>        }</div><div>        I2C_SCL_0();</div><div>        i2c_Delay();</div><div>    }</div><div>    return value;</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>uint8_t i2c_WaitAck(void)</div><div>{</div><div>    uint8_t re;</div><div><br/></div><div><br/></div><div>    I2C_SDA_1();   </div><div>//    i2c_Delay();</div><div>    I2C_SCL_1();   </div><div>    i2c_Delay();</div><div><br/></div><div><br/></div><div>    if (I2C_SDA_READ())   </div><div>    {</div><div>        re = 1;</div><div>    }</div><div>    else</div><div>    {</div><div>        re = 0;</div><div>    }</div><div><br/></div><div><br/></div><div>    I2C_SCL_0();</div><div>    i2c_Delay();</div><div>    return re;</div><div>}</div><div><br/></div><div><br/></div><div>void i2c_Ack(void)</div><div>{</div><div>    I2C_SDA_0();    </div><div>    i2c_Delay();</div><div>    I2C_SCL_1();    </div><div>    i2c_Delay();</div><div>    I2C_SCL_0();</div><div>    i2c_Delay();</div><div>    I2C_SDA_1();    </div><div>}</div><div>/*</div><div>void i2c_NAck(void)</div><div>{</div><div>    I2C_SDA_1();    </div><div>    i2c_Delay();</div><div>    I2C_SCL_1();    </div><div>    i2c_Delay();</div><div>    I2C_SCL_0();</div><div>    i2c_Delay();</div><div>}*/</div><div>void i2c_NAck(void)</div><div>{</div><div>    I2C_SCL_0();</div><div>  SDA_OUT();</div><div>    I2C_SDA_1();    </div><div>    i2c_Delay();</div><div>    I2C_SCL_1();    </div><div>    i2c_Delay();</div><div>    I2C_SCL_0();</div><div>    i2c_Delay();</div><div>}</div><div>void I2C_LM75read(void)</div><div>{</div><div><br/></div><div><br/></div><div>    uint8_t buf[2],hu[2],ot[2];</div><div>    uint16_t data,hum;</div><div>    float temp,humm;</div><div>    </div><div>    </div><div>    i2c_Start();</div><div>    i2c_SendByte(0x88);</div><div>    i2c_WaitAck();</div><div>    i2c_SendByte(0x2c);</div><div>    i2c_WaitAck();</div><div>    i2c_SendByte(0x06);</div><div>    i2c_WaitAck();</div><div>    i2c_Stop();</div><div>    i2c_Delay();</div><div>    i2c_Start();</div><div>    i2c_SendByte(0x89);</div><div>    i2c_WaitAck();</div><div>    buf[0]=i2c_ReadByte();</div><div>    i2c_Ack();</div><div>    buf[1]=i2c_ReadByte();</div><div>    i2c_Ack();</div><div>    ot[0]=i2c_ReadByte();</div><div>    i2c_Ack();</div><div>    hu[0]=i2c_ReadByte();</div><div>    i2c_Ack();</div><div>    hu[1]=i2c_ReadByte();</div><div>    i2c_Ack();</div><div>    ot[1]=i2c_ReadByte();</div><div>    i2c_NAck();</div><div>    i2c_Stop();</div><div><br/></div><div><br/></div><div>    printf(&quot;buf:%d    %d     \r\nhum:%d      %d\r\not:%d     %d\r\n&quot;,buf[0],buf[1],hu[0],hu[1],ot[0],ot[1]);</div><div>    //printf(&quot;buf:%d    %d     \r\n&quot;,buf[0],buf[1]);</div><div>    data=((buf[0]&lt;&lt;8)|buf[1]);</div><div>    hum=((hu[0]&lt;&lt;8)|hu[1]);</div><div>    temp= (175.0*data/65535.0-45.0);</div><div>    humm=(100.0*hum/65535.0);</div><div>    printf(&quot;temperature: %.2f\r\n humm:%.2f\r\n&quot;,temp,humm);</div><div>    //printf(&quot;temperature: %.2f\r\n&quot;,temp);</div><div>    return ;</div><div>}</div><div>/* USER CODE END PV */</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>/* Private user code ---------------------------------------------------------*/</div><div>/* USER CODE BEGIN 0 */</div><div><br/></div><div><br/></div><div>/* USER CODE END 0 */</div><div><br/></div><div><br/></div><div>/**</div><div>  * @brief  The application entry point.</div><div>  * @retval int</div><div>  */</div><div>int main(void)</div><div>{</div><div>  /* USER CODE BEGIN 1 */</div><div><br/></div><div><br/></div><div>  /* USER CODE END 1 */</div><div><br/></div><div><br/></div><div>  /* MCU Configuration--------------------------------------------------------*/</div><div><br/></div><div><br/></div><div>  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */</div><div>  HAL_Init();</div><div><br/></div><div><br/></div><div>  /* USER CODE BEGIN Init */</div><div><br/></div><div><br/></div><div>  /* USER CODE END Init */</div><div><br/></div><div><br/></div><div>  /* Configure the system clock */</div><div>  SystemClock_Config();</div><div><br/></div><div><br/></div><div>  /* USER CODE BEGIN SysInit */</div><div><br/></div><div><br/></div><div>  /* USER CODE END SysInit */</div><div><br/></div><div><br/></div><div>  /* Initialize all configured peripherals */</div><div>  MX_GPIO_Init();</div><div>  MX_USART1_UART_Init();</div><div>  /* USER CODE BEGIN 2 */</div><div><br/></div><div><br/></div><div>  /* USER CODE END 2 */</div><div><br/></div><div><br/></div><div>  /* Infinite loop */</div><div>  /* USER CODE BEGIN WHILE */</div><div>  while (1)</div><div>  {</div><div>        </div><div>    /* USER CODE END WHILE */</div><div>        I2C_LM75read();</div><div>        HAL_Delay(1000);</div><div>    /* USER CODE BEGIN 3 */</div><div>  }</div><div>  /* USER CODE END 3 */</div><div>}</div><div><br/></div><div><br/></div><div>/**</div><div>  * @brief System Clock Configuration</div><div>  * @retval None</div><div>  */</div><div>void SystemClock_Config(void)</div><div>{</div><div>  RCC_OscInitTypeDef RCC_OscInitStruct = {0};</div><div>  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};</div><div>  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};</div><div><br/></div><div><br/></div><div>  /**Initializes the CPU, AHB and APB busses clocks</div><div>  */</div><div>  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</div><div>  RCC_OscInitStruct.HSEState = RCC_HSE_ON;</div><div>  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</div><div>  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</div><div>  RCC_OscInitStruct.PLL.PLLM = 1;</div><div>  RCC_OscInitStruct.PLL.PLLN = 20;</div><div>  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;</div><div>  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;</div><div>  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;</div><div>  if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</div><div>  {</div><div>    Error_Handler();</div><div>  }</div><div>  /**Initializes the CPU, AHB and APB busses clocks</div><div>  */</div><div>  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</div><div>                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</div><div>  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</div><div>  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</div><div>  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;</div><div>  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</div><div><br/></div><div><br/></div><div>  if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)</div><div>  {</div><div>    Error_Handler();</div><div>  }</div><div>  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;</div><div>  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;</div><div>  if (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit) != HAL_OK)</div><div>  {</div><div>    Error_Handler();</div><div>  }</div><div>  /**Configure the main internal regulator output voltage</div><div>  */</div><div>  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)</div><div>  {</div><div>    Error_Handler();</div><div>  }</div><div>}</div><div><br/></div><div><br/></div><div>/* USER CODE BEGIN 4 */</div><div><br/></div><div><br/></div><div>/* USER CODE END 4 */</div><div><br/></div><div><br/></div><div>/**</div><div>  * @brief  This function is executed in case of error occurrence.</div><div>  * @retval None</div><div>  */</div><div>void Error_Handler(void)</div><div>{</div><div>  /* USER CODE BEGIN Error_Handler_Debug */</div><div>  /* User can add his own implementation to report the HAL error return state */</div><div><br/></div><div><br/></div><div>  /* USER CODE END Error_Handler_Debug */</div><div>}</div><div><br/></div><div><br/></div><div>#ifdef  USE_FULL_ASSERT</div><div>/**</div><div>  * @brief  Reports the name of the source file and the source line number</div><div>  *         where the assert_param error has occurred.</div><div>  * @param  file: pointer to the source file name</div><div>  * @param  line: assert_param error line source number</div><div>  * @retval None</div><div>  */</div><div>void assert_failed(char *file, uint32_t line)</div><div>{</div><div>  /* USER CODE BEGIN 6 */</div><div>  /* User can add his own implementation to report the file name and line number,</div><div>     tex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</div><div>  /* USER CODE END 6 */</div><div>}</div><div>#endif /* USE_FULL_ASSERT */</div><div><br/></div><div><br/></div><div>/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 