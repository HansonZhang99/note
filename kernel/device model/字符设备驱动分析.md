# 简单led字符设备驱动

内核版本：linux4.9.88

## 硬件原理图

当gpio输出低电平时，led亮

![image-20230503195017544](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230503195017544.png)

## 控制寄存器

![image-20230503195415235](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230503195415235.png)

### gpio输入输出控制寄存器

![image-20230503195330801](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230503195330801.png)

### gpio数据寄存器

![image-20230503195443571](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230503195443571.png)

### io复用寄存器

![image-20230503195829965](https://gitee.com/zhanghang1999/typora-picture/raw/master/image-20230503195829965.png)

## demo

如下是一个不使用bus的led字符设备驱动程序：

### source

```cpp
#include <linux/module.h>
#include <asm/io.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/miscdevice.h>
#include <linux/kernel.h>
#include <linux/major.h>
#include <linux/mutex.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/stat.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/tty.h>
#include <linux/kmod.h>
#include <linux/gfp.h>

struct led_operations {
        int num;
        int (*init) (int which);
        int (*ctl) (int which, char status);
};

struct led_operations *get_board_led_opr(void);



static int major = 0;
static struct class *led_class;
struct led_operations *p_led_opr;


#define MIN(a, b) (a < b ? a : b)
static volatile unsigned int *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;
static volatile unsigned int *GPIO5_GDIR                             ;
static volatile unsigned int *GPIO5_DR                               ;

static int board_demo_led_init (int which) /* 初始化LED, which-哪个LED */
{
    unsigned int val;

    //printk("%s %s line %d, led %d\n", __FILE__, __FUNCTION__, __LINE__, which);
    if (which == 0)
    {
        if (!IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3)
        {
            IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x2290014, 4);//直接iormap寄存器地址，这个寄存器地址用来使能led对应的gpio
            GPIO5_GDIR                              = ioremap(0x020AC000 + 0x4, 4);//这个寄存器地址用来配置gpio输入和输出
            GPIO5_DR                                = ioremap(0x020AC000 + 0, 4);//数据寄存器，可以向寄存器写入数据
        }


        /* b. 设置GPIO5_IO03用于GPIO
         * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3
         *      to configure GPIO5_IO03 as GPIO
         * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3  0x2290014
         * bit[3:0] = 0b0101 alt5
         */
        val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;
        val &= ~(0xf);
        val |= (5);
        *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = val;


        /* b. 设置GPIO5_IO03作为output引脚
         * set GPIO5_GDIR to configure GPIO5_IO03 as output
         * GPIO5_GDIR  0x020AC000 + 0x4
         * bit[3] = 0b1
         */
        *GPIO5_GDIR |= (1<<3);
    }

    return 0;
}

static int board_demo_led_ctl (int which, char status) /* 控制LED, which-哪个LED, status:1-亮,0-灭 */
{
    //printk("%s %s line %d, led %d, %s\n", __FILE__, __FUNCTION__, __LINE__, which, status ? "on" : "off");
    if (which == 0)
    {
        if (status) /* on: output 0*/
        {
            /* d. 设置GPIO5_DR输出低电平
             * set GPIO5_DR to configure GPIO5_IO03 output 0
             * GPIO5_DR 0x020AC000 + 0
             * bit[3] = 0b0
             */
            *GPIO5_DR &= ~(1<<3);
        }
        else  /* off: output 1*/
        {
            /* e. 设置GPIO5_IO3输出高电平
             * set GPIO5_DR to configure GPIO5_IO03 output 1
             * GPIO5_DR 0x020AC000 + 0
             * bit[3] = 0b1
             */
            *GPIO5_DR |= (1<<3);
        }

    }
    return 0;
}

static struct led_operations board_demo_led_opr = {
    .num  = 1,
    .init = board_demo_led_init,
    .ctl  = board_demo_led_ctl,
};

struct led_operations *get_board_led_opr(void)
{
    return &board_demo_led_opr;
}

static ssize_t led_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)
{
        printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
        return 0;
}

static ssize_t led_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)
{
        int err;
        char status;
        struct inode *inode = file_inode(file);
        int minor = iminor(inode);

        printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
        err = copy_from_user(&status, buf, 1);

        p_led_opr->ctl(minor, status);

        return 1;
}

static int led_drv_open (struct inode *node, struct file *file)
{
        int minor = iminor(node);

        printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
        p_led_opr->init(minor);

        return 0;
}

static int led_drv_close (struct inode *node, struct file *file)
{
        printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
        return 0;
}

static struct file_operations led_drv = {//字符设备驱动要求绑定file_operations结构体
        .owner   = THIS_MODULE,
        .open    = led_drv_open,
        .read    = led_drv_read,
        .write   = led_drv_write,
        .release = led_drv_close,
};

static int __init led_init(void)
{
        int err;
        int i;

        printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
        major = register_chrdev(0, "100ask_led", &led_drv);  /* /dev/led */


        led_class = class_create(THIS_MODULE, "100ask_led_class");
        err = PTR_ERR(led_class);
        if (IS_ERR(led_class)) {
                printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
                unregister_chrdev(major, "led");
                return -1;
        }

        p_led_opr = get_board_led_opr();

        for (i = 0; i < p_led_opr->num; i++)
                device_create(led_class, NULL, MKDEV(major, i), NULL, "100ask_led%d", i); /* /dev/100ask_led0,1,... */


        return 0;
}


static void __exit led_exit(void)
{
        int i;
        printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);

        for (i = 0; i < p_led_opr->num; i++)
                device_destroy(led_class, MKDEV(major, i)); /* /dev/100ask_led0,1,... */

        device_destroy(led_class, MKDEV(major, 0));
        class_destroy(led_class);
        unregister_chrdev(major, "100ask_led");
}




module_init(led_init);
module_exit(led_exit);

MODULE_LICENSE("GPL");


```

#### register_chrdev

```cpp
/*
向内核注册一个字符设备：
1.分配一个主设备号，并从chardevs资源池中分配一个char_device_struct结构
2.分配并向内核注册一个cdev结构，cdev结构根据主次设备号和此设备号范围被保存到全局变量cdev_map中
*/
static inline int register_chrdev(unsigned int major, const char *name,
				  const struct file_operations *fops)
{
	return __register_chrdev(major, 0, 256, name, fops);
}

int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,
			const char *name)
{
	struct char_device_struct *cd;
	cd = __register_chrdev_region(0, baseminor, count, name);//通过major,minor,count从chardevs资源池中分配一个char_device_struct结构
	if (IS_ERR(cd))
		return PTR_ERR(cd);
	*dev = MKDEV(cd->major, cd->baseminor);//返回一个设备号
	return 0;
}
int __register_chrdev(unsigned int major, unsigned int baseminor,
		      unsigned int count, const char *name,
		      const struct file_operations *fops)
{
	struct char_device_struct *cd;
	struct cdev *cdev;
	int err = -ENOMEM;

	cd = __register_chrdev_region(major, baseminor, count, name);//通过major,minor,count从chardevs资源池中分配一个char_device_struct结构
	if (IS_ERR(cd))
		return PTR_ERR(cd);

	cdev = cdev_alloc();//分配一个cdev结构
	if (!cdev)
		goto out2;

	cdev->owner = fops->owner;
	cdev->ops = fops;
	kobject_set_name(&cdev->kobj, "%s", name);

	err = cdev_add(cdev, MKDEV(cd->major, baseminor), count);//将cdev注册到内核
	if (err)
		goto out;

	cd->cdev = cdev;//在cd中保存cdev

	return major ? 0 : cd->major;
out:
	kobject_put(&cdev->kobj);
out2:
	kfree(__unregister_chrdev_region(cd->major, baseminor, count));
	return err;
}
```

##### __register_chrdev_region

分配一个char_device_struct结构体并填充，并将其加入到chrdevs中管理。如果major传入0，则动态分配一个major：

```cpp
static struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;//主设备号
	unsigned int baseminor;//次设备号起始编号
	int minorct;//次设备号个数
	char name[64];
	struct cdev *cdev;		/* will die */
} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];//全局指针数组，最大元素个数255


static struct char_device_struct *
__register_chrdev_region(unsigned int major, unsigned int baseminor,
			   int minorct, const char *name)
{
	struct char_device_struct *cd, **cp;
	int ret = 0;
	int i;

	cd = kzalloc(sizeof(struct char_device_struct), GFP_KERNEL);//分配一个char_device_struct结构体
	if (cd == NULL)
		return ERR_PTR(-ENOMEM);

	mutex_lock(&chrdevs_lock);

	/* temporary */
	if (major == 0) {//主设备号为0则在chrdevs中选出一个未使用的主设备号，方法时从后向前遍历chrdevs指针数组，找到指针为空的成员，并取其索引作为主设备号，这里可以看出主设备号最多254个(0排除)，动态分配范围是234-254(低于234会给出警告不会报错），动态分配时由大到小
		for (i = ARRAY_SIZE(chrdevs)-1; i > 0; i--) {
			if (chrdevs[i] == NULL)
				break;
		}

		if (i < CHRDEV_MAJOR_DYN_END)
			pr_warn("CHRDEV \"%s\" major number %d goes below the dynamic allocation range\n",
				name, i);

		if (i == 0) {
			ret = -EBUSY;
			goto out;
		}
		major = i;
	}

	cd->major = major;
	cd->baseminor = baseminor;//起始次设备号为0
	cd->minorct = minorct;//次设备号个数
	strlcpy(cd->name, name, sizeof(cd->name));

	i = major_to_index(major);
	//每个chrdevs元素都管理一条链表，chrdevs[i]链表中所有成员的major都满足i = major_to_index(major);条件，makor按从打到小排列在链表中，链表中可能有相同的major，但是其minor范围不同
	for (cp = &chrdevs[i]; *cp; cp = &(*cp)->next)
		if ((*cp)->major > major ||
		    ((*cp)->major == major &&
		     (((*cp)->baseminor >= baseminor) ||
		      ((*cp)->baseminor + (*cp)->minorct > baseminor))))
			break;

	/* Check for overlapping minor ranges.  */
	if (*cp && (*cp)->major == major) {
		int old_min = (*cp)->baseminor;
		int old_max = (*cp)->baseminor + (*cp)->minorct - 1;
		int new_min = baseminor;
		int new_max = baseminor + minorct - 1;

		/* New driver overlaps from the left.  */
		if (new_max >= old_min && new_max <= old_max) {
			ret = -EBUSY;
			goto out;
		}

		/* New driver overlaps from the right.  */
		if (new_min <= old_max && new_min >= old_min) {
			ret = -EBUSY;
			goto out;
		}
	}

	cd->next = *cp;//swap
	*cp = cd;//swap
	mutex_unlock(&chrdevs_lock);
	return cd;//最后返回新创建的char_device_struct结构
out:
	mutex_unlock(&chrdevs_lock);
	kfree(cd);
	return ERR_PTR(ret);
}
```

#### cdev

```cpp
struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

```

##### cdev_alloc

```cpp
//动态分配初始化并返回一个cdev结构
struct cdev *cdev_alloc(void)
{
	struct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);//分配一个cdev
	if (p) {
		INIT_LIST_HEAD(&p->list);
		kobject_init(&p->kobj, &ktype_cdev_dynamic);//初始化kobj
	}
	return p;
}
```

##### cdev_init

```cpp
//初始化一个cdev结构，并绑定fops
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
{
	memset(cdev, 0, sizeof *cdev);
	INIT_LIST_HEAD(&cdev->list);
	kobject_init(&cdev->kobj, &ktype_cdev_default);
	cdev->ops = fops;
}
```

##### cdev_add

```cpp
//向内核注册一个cdev结构体，cdev会保存到一个cdev_map的全局变量中，保存位置和dev,count有关
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
{
	int error;

	p->dev = dev;//设备号
	p->count = count;//次设备号范围

	error = kobj_map(cdev_map, dev, count, NULL,
			 exact_match, exact_lock, p);//cdev_map是个全局变量
	if (error)
		return error;

	kobject_get(p->kobj.parent);

	return 0;
}

static struct kobj_map *cdev_map;

struct kobj_map {
	struct probe {
		struct probe *next;
		dev_t dev;
		unsigned long range;
		struct module *owner;
		kobj_probe_t *get;
		int (*lock)(dev_t, void *);
		void *data;
	} *probes[255];
	struct mutex *lock;
};
//将cdev,dev,range保存到cdev_map全局变量中，保存位置和dev,range值有关
int kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range,
	     struct module *module, kobj_probe_t *probe,
	     int (*lock)(dev_t, void *), void *data)
{
	unsigned n = MAJOR(dev + range - 1) - MAJOR(dev) + 1;//n默认为1，range表示分配的次设备号数量，当数量超过1<<8时，n会加1
	unsigned index = MAJOR(dev);//主设备号
	unsigned i;
	struct probe *p;

	if (n > 255)
		n = 255;

	p = kmalloc_array(n, sizeof(struct probe), GFP_KERNEL);//分配n个probe结构
	if (p == NULL)
		return -ENOMEM;

	for (i = 0; i < n; i++, p++) {//初始化每个probe结构
		p->owner = module;
		p->get = probe;
		p->lock = lock;
		p->dev = dev;
		p->range = range;
		p->data = data;
	}
	mutex_lock(domain->lock);
    //对所有新分配的probe结构，根据主设备号找到cdev_map->probes的索引，并根据新分配的probe结构的range大小，将其加入到对应索引成员的链表中，链表中range从小到大排列
    //当range超过1<<8时，会将新分配的probe保存到下一个major对应的cdev_map->probes链表中
	for (i = 0, p -= n; i < n; i++, p++, index++) {
		struct probe **s = &domain->probes[index % 255];
		while (*s && (*s)->range < range)
			s = &(*s)->next;
		p->next = *s;
		*s = p;
	}
	mutex_unlock(domain->lock);
	return 0;
}

```

#### device_create

```cpp
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
{
	va_list vargs;
	struct device *dev;

	va_start(vargs, fmt);
	dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);
	va_end(vargs);
	return dev;
}
```

##### device_create_vargs

```cpp
struct device *device_create_vargs(struct class *class, struct device *parent,
				   dev_t devt, void *drvdata, const char *fmt,
				   va_list args)
{
	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
					  fmt, args);
}


static struct device *
device_create_groups_vargs(struct class *class, struct device *parent,
			   dev_t devt, void *drvdata,
			   const struct attribute_group **groups,
			   const char *fmt, va_list args)
{
	struct device *dev = NULL;
	int retval = -ENODEV;

	if (class == NULL || IS_ERR(class))
		goto error;

	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
	if (!dev) {
		retval = -ENOMEM;
		goto error;
	}

	device_initialize(dev);//初始化一个设备包括kset，ktype
	dev->devt = devt;//设置设备的设备号
	dev->class = class;//设置设备的类
	dev->parent = parent;//父设备
	dev->groups = groups;//属性组NULL
	dev->release = device_create_release;//release回调函数
	dev_set_drvdata(dev, drvdata);//dev->driver_data = drvdata;

	retval = kobject_set_name_vargs(&dev->kobj, fmt, args);//设置dev->kobj->name
	if (retval)
		goto error;

	retval = device_add(dev);//注册设备
	if (retval)
		goto error;

	return dev;

error:
	put_device(dev);
	return ERR_PTR(retval);
}

```

## Makefile

```Makefile
PWD := $(shell pwd)
CROSS_COMPILE=arm-linux-
KERNELDIR ?= ${PWD}/../../../100ask_imx6ull-sdk/Linux-4.9.88/

obj-m := leddrv.o

default:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

clean:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) clean

```

## APP

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

/*
 * ./ledtest /dev/100ask_led0 on
 * ./ledtest /dev/100ask_led0 off
 */
int main(int argc, char **argv)
{
        int fd;
        char status;

        /* 1. 判断参数 */
        if (argc != 3)
        {
                printf("Usage: %s <dev> <on | off>\n", argv[0]);
                return -1;
        }

        /* 2. 打开文件 */
        fd = open(argv[1], O_RDWR);
        if (fd == -1)
        {
                printf("can not open file %s\n", argv[1]);
                return -1;
        }

        /* 3. 写文件 */
        if (0 == strcmp(argv[2], "on"))
        {
                status = 1;
                write(fd, &status, 1);
        }
        else
        {
                status = 0;
                write(fd, &status, 1);
        }

        close(fd);

        return 0;
}

```

## test

```cpp
[root@imx6ull:~/test]# insmod leddrv.ko
[root@imx6ull:~/test]# ./ledtest /dev/100ask_led0 on  //led亮
[root@imx6ull:~/test]# ./ledtest /dev/100ask_led0 off //led灭
```

## 其他

字符设备注册成功后，在device_add函数中会根据设备号调用devtmpfs_create_node在devtmpfs虚拟文件系统中创建一个文件节点，通常devtmpfs挂载在/dev目录下，因此如上驱动程序会在device_add被调用后，在/dev下创建一个名为dev->name的节点。通过vfs文件系统，用户层调用的open read ioctl等系统调用都会转换为file_operations结构体中的对应函数，具体转换过程如下：

...

->do_dentry_open

​	->f->f_op = fops_get(inode->i_fop);

​		f->f_op->open

​			->chrdev_open

​				->led_drv_open

后续的read write因为chrdev_open中将filp->fops改成file_operations，所以后面会直接调用led_drv_read...

```cpp
static int chrdev_open(struct inode *inode, struct file *filp)
{
	const struct file_operations *fops;
	struct cdev *p;
	struct cdev *new = NULL;
	int ret = 0;

	spin_lock(&cdev_lock);
	p = inode->i_cdev;
	if (!p) {
		struct kobject *kobj;
		int idx;
		spin_unlock(&cdev_lock);
		kobj = kobj_lookup(cdev_map, inode->i_rdev, &idx);//根据cdev_map和设备号找到kobj
		if (!kobj)
			return -ENXIO;
		new = container_of(kobj, struct cdev, kobj);//根据kobj找到cdev，cdev中有fops
		spin_lock(&cdev_lock);
		/* Check i_cdev again in case somebody beat us to it while
		   we dropped the lock. */
		p = inode->i_cdev;
		if (!p) {
			inode->i_cdev = p = new;//获取新的fops
			list_add(&inode->i_devices, &p->list);
			new = NULL;
		} else if (!cdev_get(p))
			ret = -ENXIO;
	} else if (!cdev_get(p))
		ret = -ENXIO;
	spin_unlock(&cdev_lock);
	cdev_put(new);
	if (ret)
		return ret;

	ret = -ENXIO;
	fops = fops_get(p->ops);
	if (!fops)
		goto out_cdev_put;

	replace_fops(filp, fops);//将新的fops给到filp
	if (filp->f_op->open) {
		ret = filp->f_op->open(inode, filp);//调用新的fops的open
		if (ret)
			goto out_cdev_put;
	}

	return 0;

 out_cdev_put:
	cdev_put(p);
	return ret;
}
```

在第一次open中，会调用chrdev_open函数，是因为devtmpfs_create_node中最终调用的vfs_mknod函数会调用shmem_mknod函数，而shmem_mknod会调用shmem_get_inode进而调用init_special_inode。对于字符设备，init_special_inode函数会将inode->i_fop = &def_chr_fops:

```cpp
const struct file_operations def_chr_fops = {
	.open = chrdev_open,
	.llseek = noop_llseek,
};
```

以下是此驱动程序insmod时，systemtap监测内核执行的路径的一些数据：

stp脚本：

```shell
probe begin {
        printf("begin\n")
}

probe kernel.function("*@fs/char_dev.c").call {
                printf("%s -> %s\n", thread_indent(4), ppfunc())
}
probe kernel.function("*@fs/char_dev.c").return {
                printf("%s -> %s\n", thread_indent(-4), ppfunc())
}
probe kernel.function("*@drivers/base/\*.c").call {
                printf("%s -> %s\n", thread_indent(4), ppfunc())
}
probe kernel.function("*@drivers/base/\*.c").return {
                printf("%s -> %s\n", thread_indent(-4), ppfunc())
}
probe kernel.function("vfs_mknod").call {
                printf("%s -> %s\n", thread_indent(4), ppfunc())
}
probe kernel.function("vfs_mknod").return {
                printf("%s -> %s\n", thread_indent(-4), ppfunc())
}
probe kernel.function("*mknod*").call {
                printf("%s -> %s\n", thread_indent(4), ppfunc())
}
probe kernel.function("*mknod*").return {
                printf("%s -> %s\n", thread_indent(-4), ppfunc())
}

```

insmod时的输出：

```shell
```

