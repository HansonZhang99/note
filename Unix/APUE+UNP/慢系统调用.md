# 慢系统调用

**慢系统调用：**
        可能永远阻塞的系统调用，系统调用可能永远无法返回，大多数网络接口如accept,read等，都有可能永久阻塞，都是慢系统调用。

慢系统调用被永久阻塞包括一下类别：
1.读写慢设备，如管道，终端设备，网络等。读时数据不存在，需要等待；写时，缓冲区满或其他原因，需要等待。
2.当打开某些特殊文件时，需要等待某些条件的完成才能打开。例如，打开中断设备时，需要等到连接设备的modem响应才能完成。
3.pause和wait函数，pause函数使得调用进程休眠，直到捕获一个信号。wait等待子进程终止。
4.某些ioctl操作
5.某些进程间通信操作

**EINTR：**
当一个慢系统调用阻塞时，当捕获到某个信号，且对应信号处理函数返回时，这个系统调用不再阻塞而是被中断，调用返回错误，同时置errno为EINTR。
如函数read，write及对其封装的高级函数send，recv。open，sem_wait等函数都会产生EINTR。

**EAGAIN:**
顾名思义，again再试一次。
在非阻塞的系统调用中，由于函数想要的资源未得到满足，非阻塞函数会直接返回并置errno为EAGAIN，意味着你需要再调用此函数一次，才有可能获取到想要的资源。
当把系统调用read和write设置为非阻塞时，read读不到数据会直接返回EAGAIN，write写数据由于本地缓冲区已满，也可能导致write返回EAGAIN。

当非阻塞系统调用调用阻塞操作时，由于资源还没有准备好，就会返回这个EAGIAN。在此处这个EAGAIN并不是一个错误，继续调用此系统调用直到取得资源即可。

在自己封装一些函数时，由于可以对这两个错误一起进行处理：
```c
again:
rv = recv(sockfd, buf, n, 0);
if(rv < 0)
{
    if(errno == EAGAIN || errno == EINTR)
        goto agian;
}
```
在大型项目中，需要注意errno变量是线程不安全的，多线程其他线程也可以改变这个变量

**重启被中断的系统调用：**

当EINTR错误出现时，可以重启这个被中断的系统调用，如read，write，accept，open，select等都可以重启，直接进行一个goto语句的跳转即可。
但是对套接字编程中的connect函数，是不能进行重启的，若connect返回EINTR，并不能马上调用它进行重启，因为connect的三次握手建立连接已经在进行中，重新调用connnect时对方会拒绝后者。
接下来可以调用select取监听connnect的套接字等待连接的完成。另外，非阻塞的connect函数在建立连接时，如果返回-1且errno被置为EINPROGRESS，也可以调用select完成连接。

使用信号重启被中断的系统调用：
sigaction系列信号处理函数，可以设置被此信号中断的系统调用自动重启动，但是并不是对所有系统调用适用。
也可以使用信号处理函数忽略信号，让系统不产生信号中断。