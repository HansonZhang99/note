<html>
<head>
  <title>4.串口驱动分析（一）register</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="659"/>
<h1>4.串口驱动分析（一）register</h1>

<div>
<span><div><div><span style="font-size: 12pt;">Linux内核中，串口驱动的代码做的已经非常完善，不需要用户去自己去格外添加什么，在/driver/tty下，包含了串口驱动的所有代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Linux内核为了支持不同类型的CPU对应串口地址，采用了platform总线机制，用户只需要添加platform_device的相关信息，就可以使能对应cpu的串口。</span></div><div><span style="font-size: 12pt;">对于platform总线串口驱动和设备的匹配，只是整个tty驱动的一部分，也可以说，是震整个tty驱动的最底层部分。</span></div><div><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image.png" type="image/png" data-filename="Image.png" width="331"/></span></div><div><span style="font-size: 12pt;">先给出一个比较简单的图解，给出的是文件操作函数的部分，其实，这往往也是最重要也是最难的部分。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们从核心层tty_core开始分析：</span></div><div><span style="font-size: 12pt;">在/tty/serial/samsung.c中，module_init函数注册了一个uart_driver结构体：</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">ret = uart_register_driver(&amp;s3c24xx_uart_drv);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">结构体</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_uart_drv</span><span style="font-size: 12pt;">也定义在这个文件中：</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 12pt;">static struct uart_driver</span> <span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_uart_drv</span> <span style="font-size: 12pt;">= {</span></div><div><span style="font-size: 12pt;">    .owner      = THIS_MODULE,</span></div><div><span style="font-size: 12pt;">    .driver_name    = &quot;s3c2410_serial&quot;,</span></div><div><span style="font-size: 12pt;">    .nr     = CONFIG_SERIAL_SAMSUNG_UARTS,     值为3，</span></div><div><span style="font-size: 12pt;">    .cons       = S3C24XX_SERIAL_CONSOLE,            这也是一个结构</span></div><div><span style="font-size: 12pt;">    .dev_name   = S3C24XX_SERIAL_NAME,             </span><span style="font-size: 12pt;">&quot;ttyS&quot;</span></div><div><span style="font-size: 12pt;">    .major      = S3C24XX_SERIAL_MAJOR,                204</span></div><div><span style="font-size: 12pt;">    .minor      = S3C24XX_SERIAL_MINOR,                 64</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">再看看注册函数定义在serial_core.c中：</span></div><div><span style="font-size: 12pt;">int</span> <span style="font-size: 12pt; color: rgb(255, 0, 0);">uart_register_driver</span><span style="font-size: 12pt;">(struct uart_driver *drv)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    struct <span style="font-size: 12pt; color: rgb(255, 0, 0);">tty_driver *normal;</span></span></div><div><span style="font-size: 12pt;">    int i, retval;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">drv-&gt;state = kzalloc(sizeof(struct uart_state) * drv-&gt;nr, GFP_KERNEL);</span></span></div><div><span style="font-size: 12pt;">    if (!drv-&gt;state)</span></div><div><span style="font-size: 12pt;">        goto out;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">normal = alloc_tty_driver(drv-&gt;nr);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    drv-&gt;tty_driver = normal;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    normal-&gt;owner       = drv-&gt;owner;</span></div><div><span style="font-size: 12pt;">    normal-&gt;driver_name = drv-&gt;driver_name;</span></div><ul><li><div><span style="font-size: 12pt;">    normal-&gt;name        = drv-&gt;dev_name;</span></div></li></ul><div><span style="font-size: 12pt;">    normal-&gt;major       = drv-&gt;major;</span></div><div><span style="font-size: 12pt;">    normal-&gt;minor_start = drv-&gt;minor;</span></div><div><span style="font-size: 12pt;">    normal-&gt;type        = TTY_DRIVER_TYPE_SERIAL;</span></div><div><span style="font-size: 12pt;">    normal-&gt;subtype     = SERIAL_TYPE_NORMAL;</span></div><div><span style="font-size: 12pt;">    normal-&gt;init_termios    = tty_std_termios;</span></div><div><span style="font-size: 12pt;">    normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span></div><div><span style="font-size: 12pt;">    normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = 9600;</span></div><div><span style="font-size: 12pt;">    normal-&gt;flags       = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">normal-&gt;driver_state    = drv;</span></span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">tty_set_operations(normal, &amp;uart_ops);</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    for (i = 0; i &lt; drv-&gt;nr; i++) {</span></div><div><span style="font-size: 12pt;">        struct uart_state *state = drv-&gt;state + i;</span></div><div><span style="font-size: 12pt;">        struct tty_port *port = &amp;state-&gt;port;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">        tty_port_init(port);</span></div><div><span style="font-size: 12pt;">        port-&gt;ops = &amp;uart_port_ops;</span></div><div><span style="font-size: 12pt;">        port-&gt;close_delay     = 500;    /* .5 seconds */</span></div><div><span style="font-size: 12pt;">        port-&gt;closing_wait    = 30000;  /* 30 seconds */</span></div><div><span style="font-size: 12pt;">        tasklet_init(&amp;state-&gt;tlet, uart_tasklet_action,</span></div><div><span style="font-size: 12pt;">                 (unsigned long)state);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">retval = tty_register_driver(normal);</span></span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">这个函数主要做了如下事情：</span></div><ul><li><div><span style="font-size: 12pt;">为uart_driver的state域分配大小为uart_state*nr的空间。</span></div></li><li><div><span style="font-size: 12pt;">分配tty_driver结构，并将uart_driver的owner/dev_name/major/minor/nr赋值给tty_driver,将自身地址保存到tty_driver中。</span></div></li><li><div><span style="font-size: 12pt;">设置tty_driver的ops域为uart_ops，这是核心层的file_operation结构。</span></div></li><li><div><span style="font-size: 12pt;">初始化uart_driver-&gt;uart_state[nr].tty_port域，包括等待队列，ops域为</span><span style="font-size: 12pt;">uart_port_ops。</span></div></li><li><div><span style="font-size: 12pt;">调用tty_register_driver函数（定义在tty/tty_io.c中）注册tty_driver结构，函数静态申请主次设备号，并为tty_driver的ttys域和termios域分配内存，注册tty_driver-&gt;cdev域到内核，绑定cdev和ops（tty_ops)结构，并将tty_driver添加到全局链表tty_driver中。</span></div></li><li><div><span style="font-size: 12pt;">在proc文件系统中添加相应信息。</span></div></li><li><div><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div></li></ul><div><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image [2].png" type="image/png" data-filename="Image.png" width="891"/></span></div><div><span style="font-size: 12pt;">这就是整个tty_core层所做的事，接下来是platform总线设备驱动匹配过程：</span></div><div><span style="font-size: 12pt;">tty/serial/s3c2440.c</span></div><div><span style="font-size: 12pt;">module_init调用函数s3c24xx_serial_init函数（定义在samsung.c中），该函数会注册平台驱动，平台驱动结构体：</span></div><div><span style="font-size: 12pt;">static struct platform_driver s3c2440_serial_driver = {</span></div><div><span style="font-size: 12pt;">    .probe      =</span> <span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c2440_serial_probe</span><span style="font-size: 12pt;">,</span></div><div><span style="font-size: 12pt;">    .remove     = __devexit_p(s3c24xx_serial_remove),</span></div><div><span style="font-size: 12pt;">    .driver     = {</span></div><div><span style="font-size: 12pt;">        .name   = &quot;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c2440-uart</span><span style="font-size: 12pt;">&quot;,</span></div><div><span style="font-size: 12pt;">        .owner  = THIS_MODULE,</span></div><div><span style="font-size: 12pt;">    },   </span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">位于平台设备链表和平台驱动链表的结构通过name域</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c2440-uart</span><span style="font-size: 12pt;">匹配成功会调用s3c2440_serial_probe函数-&gt;</span><span style="font-size: 12pt;">s3c24xx_serial_probe函数（定义在samsung.c中）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">int</span> <span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_serial_probe</span><span style="font-size: 12pt;">(struct platform_device *dev,</span></div><div><span style="font-size: 12pt;">             struct s3c24xx_uart_info *info)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    struct s3c24xx_uart_port *ourport;</span></div><div><span style="font-size: 12pt;">    int ret;</span></div><div><span style="font-size: 12pt;">......</span></div><div><span style="font-size: 12pt;">    <span style="font-size: 12pt; color: rgb(255, 0, 0);">ourport = &amp;s3c24xx_serial_ports[probe_index];</span></span></div><div><span style="font-size: 12pt;">    probe_index++;</span></div><div><span style="font-size: 12pt;">......</span></div><div><span style="font-size: 12pt;">    ret = s3c24xx_serial_init_port(ourport, info, dev);</span></div><div><span style="font-size: 12pt;">......</span></div><div><span style="font-size: 12pt;">    uart_add_one_port(&amp;s3c24xx_uart_drv, &amp;ourport-&gt;port);</span></div><div><span style="font-size: 12pt;">    platform_set_drvdata(dev, &amp;ourport-&gt;port);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    ret = device_create_file(&amp;dev-&gt;dev, &amp;dev_attr_clock_source);</span></div><div><span style="font-size: 12pt;">......</span></div><div><span style="font-size: 12pt;">    ret = s3c24xx_serial_cpufreq_register(ourport);</span></div><div><span style="font-size: 12pt;">......</span></div><div><span style="font-size: 12pt;">}  </span></div><div><span style="font-size: 12pt;">这个函数主要工作：</span></div><ul><li><div><span style="font-size: 12pt;">结构体</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_serial_ports</span><span style="font-size: 12pt;">是s3c24xx系列cpu共用的结构：</span></div></li></ul><div><span style="font-size: 12pt;">                static struct s3c24xx_uart_port                                                                    </span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_serial_ports[CONFIG_SERIAL_SAMSUNG_UARTS]</span> <span style="font-size: 12pt;">= {</span></div><div><span style="font-size: 12pt;">                [0] = {</span></div><div><span style="font-size: 12pt;">                            .port = {</span></div><div><span style="font-size: 12pt;">                            .lock       =                   __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[</span><span style="font-size: 12pt;">0</span><span style="font-size: 12pt;">].port.lock),</span></div><div><span style="font-size: 12pt;">                            .iotype     = UPIO_MEM,</span></div><div><span style="font-size: 12pt;">                            .irq        = IRQ_S3CUART_RX</span><span style="font-size: 12pt;">0</span><span style="font-size: 12pt;">,</span></div><div><span style="font-size: 12pt;">                            .uartclk    = 0,</span></div><div><span style="font-size: 12pt;">                            .fifosize   = 16,</span></div><div><span style="font-size: 12pt;">                            .ops        =</span> <span style="font-size: 12pt; color: rgb(255, 0, 0);">&amp;s3c24xx_serial_ops</span><span style="font-size: 12pt;">,</span></div><div><span style="font-size: 12pt;">                            .flags      = UPF_BOOT_AUTOCONF,</span></div><div><span style="font-size: 12pt;">                            .line       =</span> <span style="font-size: 12pt;">0</span><span style="font-size: 12pt;">,</span></div><div><span style="font-size: 12pt;">                        }</span></div><div><span style="font-size: 12pt;">                ...</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">por域中包含了最底层文件操作的函数实现，直接操作硬件的函数集合数据结构</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">s3c24xx_serial_ops</span><span style="font-size: 12pt;">。</span></div><ul><li><div><span style="font-size: 12pt;">probe函数将dev和</span><span style="font-size: 12pt;">s3c24xx_serial_ports</span><span style="font-size: 12pt;">结构提供的信息包括硬件信息，中断等以及底层操作函数都保存到结构</span><span style="font-size: 12pt;">s3c24xx_uart_port-&gt;</span><span style="font-size: 12pt;">uart_port中，</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">uart_port-&gt;dev域为platform_device，</span><span style="font-size: 12pt;">由函数</span><span style="font-size: 12pt;">s3c24xx_serial_init_port实现</span><span style="font-size: 12pt;">。</span></div></li><li><div><span style="font-size: 12pt;">调用uart_add_one_port函数，将</span><span style="font-size: 12pt;">s3c24xx_uart_port-&gt;uart_port域与uart_driver类型结构体</span><span style="font-size: 12pt;">s3c24xx_uart_drv绑定。结构uart_driver-&gt;state域我们在核心层给它分配了内存，但是一直没用到，在这里，将</span><span style="font-size: 12pt;">uart_driver-&gt;state-&gt;uart_port=uport，实现uport绑定到uart_driver。</span></div></li><li><div><span style="font-size: 12pt;">调用</span><span style="font-size: 12pt;">tty_register_device函数，</span> <span style="font-size: 12pt;">device_create创建设备节点。</span></div></li></ul><div><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image [3].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image [4].png" type="image/png" data-filename="Image.png" width="852"/></span></div><div><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image [5].png" type="image/png" data-filename="Image.png" width="852"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在uart_register_driver函数中，会注册cdev到内核，随后platform总线匹配调用probe函数，最后会在/dev下生成”ttyS0“设备。</span></div><div><span style="font-size: 12pt;">接下来会分析ops中的函数的层次调用。</span></div><div><span style="font-size: 12pt;">先给出一张图：</span></div><div><span style="font-size: 12pt;">来自：</span> <span style="font-size: 12pt;"><a href="https://blog.csdn.net/lizuobin2/article/details/51801183" style="font-size: 12pt;">https://blog.csdn.net/lizuobin2/article/details/51801183</a></span></div><div><img src="4.串口驱动分析（一）register_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image [7].png" type="image/png" data-filename="Image.png"/></span><span style="font-size: 12pt;"><img src="4.串口驱动分析（一）register_files/Image [8].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">参考博文：</span> <span style="font-size: 12pt;"><a href="http://www.wowotech.net/tty_framework/435.html" style="font-size: 12pt;">http://www.wowotech.net/tty_framework/435.html</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div></div><div><br/></div></span>
</div></body></html> 