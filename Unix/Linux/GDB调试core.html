<html>
<head>
  <title>GDB调试core</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1158"/>
<h1>GDB调试core</h1>

<div>
<span><div><b><font style="font-size: 14pt;">开启core文件的生成</font></b></div><div><span>    </span>Linux :man core</div><div><span>    </span>由于核心文件都比较大，大部分系统默认不开启核心文件的生成。</div><div><span>    </span>在Linux命令行下：</div><div><span>   <span>    </span> </span>ulimit -c打印0表示没有开启核心文件，打印unlimited，则说明coredump已打开</div><div><span> <span>    </span>   </span>ulimit -c unlimited开启核心文件生成</div><div><span>  <span>    </span>  </span>ulimit -c 0关闭核心文件生成</div><div><span>    </span>默认生成路径：输入可执行文件运行命令的同一路径下</div><div><span>    </span>默认生成名字：默认命名为core。新的core文件会覆盖旧的core文件</div><div><br clear="none"/></div><div><b><font style="font-size: 14pt;">设置pid作为文件扩展名</font></b></div><div><br clear="none"/></div><div>1：添加pid作为扩展名，生成的core文件名称为core.pid</div><div>0：不添加pid作为扩展名，生成的core文件名称为core</div><div>修改 /proc/sys/kernel/core_uses_pid 文件内容为: 1</div><div>修改文件命令： echo &quot;1&quot; &gt; /proc/sys/kernel/core_uses_pid</div><div>或者</div><div>sysctl -w kernel.core_uses_pid=1 kernel.core_uses_pid = 1</div><div><font style="font-size: 14pt;"><br clear="none"/></font></div><div><font style="font-size: 14pt;"> <b>控制core文件保存位置和文件名格式</b></font></div><div><br clear="none"/></div><div>修改文件命令： echo &quot;/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern</div><div>或者：</div><div>sysctl -w kernel.core_pattern=/corefile/core.%e.%p.%s.%E</div><div>可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳</div><div>以下是参数列表:</div><div>%p - insert pid into filename 添加pid(进程id)</div><div>%u - insert current uid into filename 添加当前uid(用户id)</div><div>%g - insert current gid into filename 添加当前gid(用户组id)</div><div>%s - insert signal that caused the coredump into the filename 添加导致产生core的信号</div><div>%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间</div><div>%h - insert hostname where the coredump happened into filename 添加主机名</div><div>%e - insert coredumping executable name into filename 添加导致产生core的命令名</div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int sys_core_dump_open(char *pCorePid, char *pCorePath)</div><div>{</div><div>int iRet = -1;</div><div>int iFd1 = -1;</div><div>int iFd2 = -1;</div><div>struct rlimit limit;</div><div>struct rlimit limit_set;</div><div><br/></div><div><br/></div><div>do{</div><div>/* 1, set core ulimit */</div><div>if (getrlimit(RLIMIT_CORE, &amp;limit))</div><div>{</div><div>printf(&quot;get resource limit fail!\n)&quot;;</div><div>break;</div><div>}</div><div>limit_set.rlim_cur = limit_set.rlim_max = RLIM_INFINITY;</div><div>if (setrlimit(RLIMIT_CORE, &amp;limit_set))</div><div>{</div><div>limit_set.rlim_cur = limit_set.rlim_max = limit.rlim_max;</div><div>if (limit.rlim_max != RLIM_INFINITY)</div><div>{</div><div>//printf( &quot;CORE: cur=0x%x, max=0x%x\n&quot;,</div><div>//limit.rlim_cur, limit.rlim_max);</div><div>}</div><div>if (setrlimit(RLIMIT_CORE, &amp;limit_set))</div><div>{</div><div>printf( &quot;set core ulimited fail!\n&quot;);</div><div>break;</div><div>}</div><div>}</div><div>/* 2, set core use pid */</div><div>if (pCorePid &amp;&amp; strlen(pCorePid) &gt; 0)</div><div>{</div><div>iFd1 = open(&quot;/proc/sys/kernel/core_uses_pid&quot;, O_RDWR|O_NDELAY|O_TRUNC, DEFAULT_FILE_MODE);</div><div>if (iFd1 &lt; 0)</div><div>{</div><div>printf( &quot;open core_uses_pid fail!\n&quot;);</div><div>break;</div><div>}</div><div>if (strlen(pCorePid) != write(iFd1, pCorePid, strlen(pCorePid)))</div><div>{</div><div>printf(&quot;set core_uses_pid fail!\n&quot;);</div><div>close(iFd1);</div><div>break;</div><div>}</div><div>close(iFd1);</div><div>}</div><div><br/></div><div><br/></div><div>/* 3, set core pattern */</div><div>if (pCorePath &amp;&amp; strlen(pCorePath) &gt; 0)</div><div>{</div><div>iFd2 = open(&quot;/proc/sys/kernel/core_pattern&quot;, O_RDWR|O_NDELAY|O_TRUNC, DEFAULT_FILE_MODE);</div><div>if (iFd2 &lt; 0)</div><div>{</div><div>printf(&quot;open core_pattern fail!\n&quot;);</div><div>break;</div><div>}</div><div>if (strlen(pCorePath) != write(iFd2, pCorePath, strlen(pCorePath)))</div><div>{</div><div>printf(&quot;set core_pattern fail!\n&quot;);</div><div>close(iFd2);</div><div>break;</div><div>}</div><div>close(iFd2);</div><div>}</div><div><br/></div><div><br/></div><div>/* 4, set core dump open succ */</div><div>iRet = OK;</div><div>printf(&quot;set core dump open succ!\n&quot;);</div><div>}while(0);</div><div><br/></div><div><br/></div><div>return iRet;</div><div>}</div><div><br/></div><div><br/></div><div>//用于启动过程也需要coredump，例如系统测试的稳定性测试</div><div>void set_core_dump_inner(void)</div><div>{</div><div>char szCorePid[32]={0};</div><div>char szCorePath[128]={0};</div><div><br/></div><div><br/></div><div>/*为了唯一区分core文件,文件名格式追加IP地址及设备序列号*/</div><div>strcpy(szCorePid, &quot;1&quot;);</div><div><br/></div><div><br/></div><div>/*core保存目录,按实际情况修改*/</div><div>strcpy(szCorePath, &quot;/home&quot;);</div><div><br/></div><div><br/></div><div>/*core 文件名称 */</div><div>strcat(szCorePath, &quot;core-%s-%e-%p-%t&quot;);</div><div><br/></div><div><br/></div><div>if (OK != sys_core_dump_open(szCorePid, szCorePath))</div><div>{</div><div>printf(&quot;========= gdb core dump open fail! =========\n\n&quot;);</div><div>}</div><div>else</div><div>{</div><div>printf(&quot;sys gdb core open succ ~~~ \n&quot;);</div><div>}</div><div>}</div></div><div><br/></div><div><font style="font-size: 14pt;"><b>可以产生core文件的信号</b></font></div><div><br clear="none"/></div><div>| 名字 | 说明 | 缺省动作 |</div><div>| :------ | :------------------------ | :--------- |</div><div>| SIGABRT | 异常终止(abort) | 终止w/core |</div><div>| SIGBUS | 硬件故障 | 终止w/core |</div><div>| SIGEMT | 硬件故障 | 终止w/core |</div><div>| SIGFPE | 算术异常 | 终止w/core |</div><div>| SIGILL | 非法硬件指令 | 终止w/core |</div><div>| SIGIOT | 硬件故障 | 终止w/core |</div><div>| SIGQUIT | 终端退出符 | 终止w/core |</div><div>| SIGSEGV | 无效存储访问 | 终止w/core |</div><div>| SIGSYS | 无效系统调用 | 终止w/core |</div><div>| SIGTRAP | 硬件故障 | 终止w/core |</div><div>| SIGXCPU | 超过CPU限制(setrlimit) | 终止w/core |</div><div>| SIGXFSZ | 超过文件长度限制(setrlimit) | 终止w/core |</div><div><br clear="none"/></div><div>示例：</div><div>服务器支持客户端某些命令，将其中一条命令加入`int *p; *p=100;`当客户端调用次命令时，服务器产生SIGSEGV信号并产生核心文件</div><div>使用gdb调试核心文件可以快速追踪程序崩溃点：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>zhanghang22@Cpl-MT-General-13-131:~/work/Custom/9396aes/package/packhisi3519v101/hicore/hik$ arm-hisiv500-linux-gdb hisi_g core-11-processClient-938-1608825113</div><div>GNU gdb (Hisilicon_v500_20170427) 7.6.1-2013.10</div><div>Copyright (C) 2013 Free Software Foundation, Inc.</div><div>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div>This is free software: you are free to change and redistribute it.</div><div>There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;</div><div>and &quot;show warranty&quot; for details.</div><div>This GDB was configured as &quot;--host=x86_64-linux-gnu --target=arm-hisiv500-linux-uclibcgnueabi&quot;.</div><div>For bug reporting instructions, please see:</div><div>&lt;http://www.hisilicon.com/cn/service/claim.html&gt;...</div><div>Reading symbols from /data2/zhanghang22/work/Custom/9396aes/package/packhisi3519v101/hicore/hik/hisi_g...done.</div><div><br/></div><div><br/></div><div>warning: core file may not match specified executable file.</div><div>warning: Could not load shared library symbols for 29 libraries, e.g. /lib/libm.so.0.</div><div>Use the &quot;info sharedlibrary&quot; command to see the complete listing.</div><div>Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?</div><div>Core was generated by `./hisi'.</div><div>Program terminated with signal 11, Segmentation fault.</div><div>#0 sdk_netClientManualCapture (connfd=connfd@entry=77, recvbuff=recvbuff@entry=0x637f4ea8 &quot;&quot;, sdkcmd=sdkcmd@entry=1118378, pClientSockAddr=&lt;optimized out&gt;) at funcModules/sdk/dvrNet.c:13944</div><div>13944 *p = 100;</div><div>(gdb) bt</div><div>#0 sdk_netClientManualCapture (connfd=connfd@entry=77, recvbuff=recvbuff@entry=0x637f4ea8 &quot;&quot;, sdkcmd=sdkcmd@entry=1118378, pClientSockAddr=&lt;optimized out&gt;) at funcModules/sdk/dvrNet.c:13944</div><div>#1 0x00156370 in sdk_processClientRequest (connfd=77, client_s_addr=&lt;optimized out&gt;) at funcModules/sdk/dvrNet.c:2589</div><div>#2 0x76eb2f5c in ?? ()</div><div>#3 0x76eb2f5c in ?? ()</div><div>Backtrace stopped: previous frame identical to this frame (corrupt stack?)</div><div>(gdb) f 0</div><div>#0 sdk_netClientManualCapture (connfd=connfd@entry=77, recvbuff=recvbuff@entry=0x637f4ea8 &quot;&quot;, sdkcmd=sdkcmd@entry=1118378, pClientSockAddr=&lt;optimized out&gt;) at funcModules/sdk/dvrNet.c:13944</div><div>13944 *p = 100;</div></div><div><br/></div><div>执行bt打印函数栈帧，3调用2调用1调用0，最后进程在文件dvrNet.c的13944行，对应函数sdk_netClientManualCapture中出现错误，错误指令*p = 100;</div><div>Core文件调试死机不是万能的，如果所有栈帧都是这样#3 0x76eb2f5c in ?? ()，有三种可能:1.没有包含对应的执行文件，比如libxxx.so；2.包含了对应的文件但是文件编译没加-g；3.函数栈帧已经被覆盖了，gdb调试已经没用了。</div><div><br clear="none"/></div><div>gdb+core用来查找程序因为一些信号导致的崩溃死机。优点是只要core文件，有对应程序的gcc -g版本，和对应的gdb工具链，即可在任何地方复现问题。</div><div><br clear="none"/></div></span>
</div></body></html> 