# 函数重载和函数模板
#### 函数重载
函数重载的关键是函数的参数列表，也称为函数的特征标。C++允许定义名称相同的函数，条件是特征标不同。
原理：
C++编译器在处理同名但特征标不同的函数时，会对函数进行加密，类似：
```cpp
void func(int a);
void func(double b);

//C++编译器处理后
void IUWHDIUHWDfuncWODIHD(int a);
void UWHGDIUHWIfuncHWIUDHO(double b);
```
```cpp
print(const char *str, int width);
print(int integer, int width);
print(double d);
print(long l);
...
```
编译器在检查函数特征标时，把类型引用和类型本身视为同意特征标：
`double cube(double x);
double cube(douele &x);`
匹配函数时，不去非const和const 变量。即参数为const的函数可接受非const变量，但是反之不行。

调用最匹配版本：
```cpp
void stove(double& r1);//1 匹配可修改的左值
void stove(const double& r2);//2 匹配可修改，不可修改的左值，右值
void stove(double && r3);//3  匹配右值

double x = 88.9;
const double y = 100.99;
stove(x);//1
stove(y);//2
stove(x+y);//3 如果不定义3，则调用2
```


#### 函数模板
C++允许使用泛型的方式定制函数，通过将类型作为参数传递给模板，可以使编译器生成该类型的函数。
模板定义：
```cpp
//声明：
template <class T> //template <typename T> ----C++98
void swap(T&a, T& b);
//定义：
template <class T> //template <typename T> ----C++98
void swap(T&a, T& b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
```
函数重载模板的局限性：
在对函数重载使用模板时，可能遇到如下情况：
```cpp
template <class T>
bool compare(T& a, T&b)
{
    return a > b;
}
```
T的类型如果是结构体/类， 函数就不支持使用>进行比较。
因此，通常定义类和结构体时，需要对结构体和类重载opeator< ,operator>, operator=, operator==运算符。

#### 具体化
对给定的函数名，可以有非模板函数，模板函数和显式具体化模板以及他们的重载版本。
优先级：非模板函数>显式具体化>模板
非模板：
`void swap(job& j1,job& j2)`
模板：
```cpp
template <class T>
void swap(T& a,T& b);
```
显式具体化：
```cpp
//explicit specialization
template <> void swap<job>(job&, job& );
template <> void swap(job& ,job& );
```
隐式实例化：
编译使用模板为特定类型生成实例。如`swap(i,j)使用模板生成int类型的函数定义被称为隐式实例化implicit instantiation。
显式实例化：
直接命令编译器创建特定实例，如
```cpp
swap<int>();
```
语法：
```cpp
template void swap<int>(int, int);
```
等价于隐式实例化的“swap(i,j)使用模板生成int类型的函数定义”
隐式实例化和显式实例化都使用模板函数的定义创建一个类型的实例，而具体化有自己单独的函数定义。
```cpp
template <class T>
T add(T a,T b)
{
    return a + b;
}
int m = 6;
double x = 0.2;
cout << add<double>(m,x);//yes
int n = 20;
double y = 0.87;
swap<double>(n,y);//error ,swap的参数为引用，而double&与int&不能相互转换
```

```cpp
template <class T>
void swap(T&, T&)//normal template
{
    ....
}
template<> void swap<jobs>(jobs &, jobs&)//explicit specialization
{
    ....
}
int main()
{
    ...
    template void swap<char>(char &,char &);//explicit instantiation
    short a, b;
    swap(a,b);//normal template,implicit instantiation
    jobs m,n;
    swap(m,n);//explicit specialization
    char x,y;
    swap(x,y);//explicit instantiation
}
```
#### 模板返回类型
在模板函数中定义与模板参数相同类型的参数
```cpp
int x;
decltype(x) y;//y is the same type as x
decltype(x+y) z;//z is the same type as (x+y)
decltype(x+y) u = x + y;
template <class T>
void func(T t1, T t2)
{
    ...
    decltype(t1 + t2) z = x + y;
}

long funcc(int x);
decltype(funcc(p)) k;//k is long
```
模板函数返回类型：
```cpp
//对如下函数
double h(int x, float y);
{
}
//可定义为
auto double(int x, float y) -> double;
{
}
//auto为占位符，而double为后置返回类型
template<class T1,class T2>
auto gt(T1 x, T2 y) -> decltype(x+y)
{
    return x+y;
}
```