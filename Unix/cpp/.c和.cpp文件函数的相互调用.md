## .c和.cpp文件函数的相互调用

由于`C++`支持重载，`.cpp`文件在被编译成`.o`文件时，函数名会因为重载特性被加上前缀后缀如：

```cpp
#include <iostream>
#ifndef __cplusplus
extern "C"
{
#endif
    void func(void);
#ifndef __cplusplus
}
#endif
int testNumber;
void func()
{
    std::cout << "Hello world" << std::endl;
}
```

```shell
[Thu Apr 21 16:26:54~]$ g++ test2.cpp -c
[Thu Apr 21 16:27:15~]$ nm test2.o
                 U _GLOBAL_OFFSET_TABLE_
0000000000000078 t _GLOBAL__sub_I_testNumber
000000000000002f t _Z41__static_initialization_and_destruction_0ii
0000000000000000 T _Z4funcv  #func因为重载被改名
                 U _ZNSolsEPFRSoS_E
                 U _ZNSt8ios_base4InitC1Ev
                 U _ZNSt8ios_base4InitD1Ev
                 U _ZSt4cout
                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
0000000000000000 r _ZStL19piecewise_construct
0000000000000004 b _ZStL8__ioinit
                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
                 U __cxa_atexit
                 U __dso_handle
0000000000000000 B testNumber

```

由于C++这种这种特性，在编译`cpp`文件时，所有函数名最后被链接时名字都不是原来的，导致在`.c`文件中调用`.cpp`文件中的函数，或者`.cpp`文件中调用`.c`文件中的函数，都会提示：

```shell
test1.o: In function `main':
test1.c:(.text+0x5): undefined reference to `func' (c文件中找不到cpp文件中定义的func,因为cpp文件中的func在编译时名字已经改变)
collect2: error: ld returned 1 exit status
```

```shell
test2.o: In function `main':
test2.cpp:(.text+0x5): undefined reference to `func()' (cpp文件中找不到c文件中定义的func,因为cpp文件中的func在编译时名字已经改变,而c中还是func)
collect2: error: ld returned 1 exit status
```

### extern "C"

`extern "C"`的作用是告诉C++编译器用C规则编译指定的代码（除函数重载外，`extern "C"`不影响C++其他特性）。

只要在`.cpp`文件中在函数声明前加上`extern "C"`，就可以让编译器在编译`.cpp`文件时不改写符号，如果在头文件中声明，最好使用`__cplusplus`宏进行限制。

```cpp
extern "C" void func(void);
//or
extern "C"
{
    void func(void);
    //...
}
```

#### .cpp文件调用.c文件的函数

#### `test1.c`

```cpp
#include <iostream>
#include "test2.h"
void func()
{
    std::cout << "Hello world" << std::endl;
}
```

#### `test2.cpp`

```cpp
#include "test2.h"

int main()
{
    func();
}
```

#### `test2.h`

```cpp
#ifndef __TEST2_H__
#define __TEST2_H__
#ifdef __cplusplus
extern "C"
{
#endif
    void func(void);
#ifdef __cplusplus
}
#endif
#endif
```

##### `compile`

```cpp
gcc test1.c -c
g++ test2.cpp -c
gcc *.o -o test -lstdc++ //link
```

##### `run`

```
./test
Hello world
```



#### .c文件调用.cpp文件函数

##### `test1.c`

```cpp
#include "test2.h"

int main()
{
    func();
}
```

##### `test2.cpp`

```cpp
#include <iostream>
#include "test2.h"
void func()
{
    std::cout << "Hello world" << std::endl;
}
```

#### `test2.h`

```cpp
#ifndef __TEST2_H__
#define __TEST2_H__
#ifdef __cplusplus
extern "C"
{
#endif
    void func(void);
#ifdef __cplusplus
}
#endif
#endif
```

##### `compile`

```cpp
gcc test1.c -c
g++ test2.cpp -c
gcc *.o -o test -lstdc++ //link
```

##### `run`

```
./test
Hello world
```