# 类模板
```cpp
template <class T> //template <typename T>
class vt
{
    ...
    public:
        void push_back(const T&);
}

```
使用：
```cpp
vt<int> vt_example;
```
T可以被基本类型或类代替实现具体化。
成员函数定义：
```cpp
//defintion
template <class T>
void vt<T>::push_back(const T&)
{
    ...
}
```
在类外定义需要加上模板头和类限定符，模板的声明和定义需要在同一文件中。

模板支持非类型/表达式参数：
```cpp
template <class T, int n>
class vt
{
    ...
}
```
表达式可以是整形，枚举，引用或指针。模板代码不能修改参数的值，不能使用参数的地址。不能执行&n 或n++的操作。在实例化时，表达式参数的值必须是常量表达式。
类可以包含多个模板参数：
```cpp
template <class T1, class T2>
```
可以为类模板类型参数提供默认值：（函数模板不可以），可以为模板类或模板函数提供非类型参数默认值
```cpp
template <class T1, class T2 = int>
class vt
{  
}
vt<double>  //==vt<double,int>
vt<double ,char> //==vt<double, char>

template <class T1,int n = 0>
class vt
{
}
vt<double> // ==vt<double,0>
vt<double ,10> //==vt<double, 10>
```

```cpp
#include <iostream>
using namespace std;

template <class T1, class T2 = int>
void func(T1 t1,T2 t2 = 10)
{
    cout << t1 << " " << t2 << endl;
}

int main()
{
    double n = 12.9;
    func(n);
}
```
## 模板具体化
隐式实例化:
```cpp
arrayTp<int, 100> stuff;//implicit instantation

arrayTp<double ,30> *pt;
pt = new arrayTp<double, 30>;
```
显式实例化：
```cpp
template class arrayTP<string, 100>;//根据通用模板生成具体化explicit instantation
```
即使没有创建或提及类对象，编译器也会生成类声明（包括方法定义），使用通用模板生成生成具体化。

显示具体化：
```cpp
template <class T>//class template definition
class arrayTP
{
    ...
};
```
具体化类模板的定义：
```cpp
template<> class arrayTp<const char*>
{
    ...
};
```
```cpp
arrayTp<int> a1;//genernal definition
arrayTp<const char *> a2;//specialized definition
```
部分具体化：
```cpp
//general
template <class T1, class T2> class pair {...};
//specialization with T2 set to int
template <class T1> class pair<T1, int> pair {...};
```
指针具体化：
```cpp
template <class T>
class Feeb {...};//1
template <class T*>
class Feeb {...};//2

Feeb<char> f1;//use 1
Feeb<char *> f2;//use 2
```
成员模板
模板参数