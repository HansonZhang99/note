<html>
<head>
  <title>3.Linux内核串口驱动分析（一）注册</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="674"/>
<h1>3.Linux内核串口驱动分析（一）注册</h1>

<div>
<span><div><span style="font-size: 12pt;">在Linux下，串口驱动实现在tty子系统下，类似input子系统，tty子系统也有它严格的分层，每层实现不同的功能。</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">Linux tty子系统包含：tty核心，tty线路规程和tty驱动。tty核心是对整个tty设备的抽象，对用户提供统一的接口，tty线路规程是对传输数据的格式化，tty驱动则是面向tty设备的硬件驱动。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3.Linux内核串口驱动分析（一）注册_files/Image.png" type="image/png" data-filename="Image.png" width="735"/></span></div><div><span style="font-size: 12pt;">代码分析：</span><span style="font-size: 12pt;">linux-3.0/drivers/tty/serial/samsung.c</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">static struct uart_driver <font color="#FF0000"><b>s3c24xx_uart_drv</b></font> = {</font></div><div><font style="font-size: 9pt;">    .owner      = THIS_MODULE,</font></div><div><font style="font-size: 9pt;">    .driver_name    = &quot;s3c2410_serial&quot;,</font></div><div><font style="font-size: 9pt;">    .nr     = CONFIG_SERIAL_SAMSUNG_UARTS,</font></div><div><font style="font-size: 9pt;">    .cons       = S3C24XX_SERIAL_CONSOLE,</font></div><div><font style="font-size: 9pt;">    .dev_name   = S3C24XX_SERIAL_NAME,</font></div><div><font style="font-size: 9pt;">    .major      = S3C24XX_SERIAL_MAJOR,</font></div><div><font style="font-size: 9pt;">    .minor      = S3C24XX_SERIAL_MINOR,</font></div><div><font style="font-size: 9pt;">};</font></div><div><font style="font-size: 9pt;"><font>sta</font><font>tic int __init s3c24xx_serial_modinit(void)</font></font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    int ret;</font></div><div><font style="font-size: 9pt;">    ret = <b><font color="#FF0000">uart_register_driver(&amp;s3c24xx_uart_drv);</font></b></font></div><div><font style="font-size: 9pt;">    if (ret &lt; 0) {</font></div><div><font style="font-size: 9pt;">        printk(KERN_ERR &quot;failed to register UART driver\n&quot;);</font></div><div><font style="font-size: 9pt;">        return -1;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;">    return 0;</font></div><div><font style="font-size: 9pt;">}</font></div></div><div><span style="font-size: 12pt;">注册一个uart_driver类型的结构。</span></div><div><span style="font-size: 12pt;">linux-3.0/include/linux/serial_core.h</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;"><font>struc</font><font>t <b><font color="#FF0000">uart_driver</font></b> {</font></font></div><div><font style="font-size: 9pt;"><font>    struct module       *owner;</font>/* 拥有该uart_driver的模块,一般为THIS_MODULE */</font></div><div><font style="font-size: 9pt;"><font>    const char      *driver_name;</font>/* 串口驱动名，串口设备文件名以驱动名为基础 */</font></div><div><font style="font-size: 9pt;"><font>    const char      *dev_name;</font>/* 串口设备名 */</font></div><div><font style="font-size: 9pt;"><font>    int          major;</font>/* 主设备号 */</font></div><div><font style="font-size: 9pt;">    int          minor;/*次设备号*/</font></div><div><font style="font-size: 9pt;"><font>    int          nr;</font>/* 该uart_driver支持的串口个数(最大) */</font></div><div><font style="font-size: 9pt;">    struct console      *cons;</font></div><div><font style="font-size: 9pt;">   <font color="#A8A8A8"> /*</font></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">     * these are private; the low level driver should not</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">     * touch these; they should be initialised to NULL</font></div><div><font style="font-size: 9pt;"><font color="#A8A8A8">     */</font>/* 下面这俩，它们应该被初始化为NULL */</font></div><div><font style="font-size: 9pt;"><font>    <b><font color="#FF0000">struct uart_state   *state;</font></b></font>/* 下层，串口驱动层 */</font></div><div><font style="font-size: 9pt;"><font>    <font color="#FF0000"><b>struct tty_driver   *tty_driver;</b></font></font>/* tty相关 */</font></div><div><font style="font-size: 9pt;">};</font></div></div><div><font style="font-size: 9pt;">linux-3.0/include/linux/tty_driver.h</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">struct <b><font color="#FF0000">tty_driver</font></b> {</font></div><div><font style="font-size: 9pt;">    int magic;      /* magic number for this structure */</font></div><div><font style="font-size: 9pt;">    struct kref kref;   /* Reference management */</font></div><div><font style="font-size: 9pt;">    struct cdev cdev;</font></div><div><font style="font-size: 9pt;">    struct module   *owner;</font></div><div><font style="font-size: 9pt;">    const char  *driver_name;</font></div><div><font style="font-size: 9pt;">    const char  *name;</font></div><div><font style="font-size: 9pt;">    int name_base;  /* offset of printed name */</font></div><div><font style="font-size: 9pt;">    int major;      /* major device number */</font></div><div><font style="font-size: 9pt;">    int minor_start;    /* start of minor device number */</font></div><div><font style="font-size: 9pt;">    int minor_num;  /* number of *possible* devices */</font></div><div><font style="font-size: 9pt;">    int num;        /* number of devices allocated */</font></div><div><font style="font-size: 9pt;">    short   type;       /* type of tty driver */</font></div><div><font style="font-size: 9pt;">    short   subtype;    /* subtype of tty driver */</font></div><div><font style="font-size: 9pt;">    struct ktermios init_termios; /* Initial termios */</font></div><div><font style="font-size: 9pt;">    int flags;      /* tty driver flags */</font></div><div><font style="font-size: 9pt;">    struct proc_dir_entry *proc_entry; /* /proc fs entry */</font></div><div><font style="font-size: 9pt;">    struct tty_driver *other; /* only used for the PTY driver */</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    /*</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">     * Pointer to the tty data structures</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">     */</font></div><div><font style="font-size: 9pt;">    struct tty_struct **ttys;</font></div><div><font style="font-size: 9pt;">    struct ktermios **termios;</font></div><div><font style="font-size: 9pt;">    struct ktermios **termios_locked;</font></div><div><font style="font-size: 9pt;">    <b>void *driver_state;</b></font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    /*</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">     * Driver methods</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">     */</font></div><div><font style="font-size: 9pt;">    <b>const struct tty_operations *ops;</b></font></div><div><font style="font-size: 9pt;">    <b>struct list_head tty_drivers;</b></font></div><div><font style="font-size: 9pt;">};</font></div></div><div><br/></div><div><span style="font-size: 12pt;">再来看看注册函数：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">int <b><font color="#FF0000">uart_register_driver</font></b>(struct uart_driver *drv)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    struct tty_driver *normal;</font></div><div><font style="font-size: 9pt;">    int i, retval;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    BUG_ON(drv-&gt;state);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /*</font></div><div><font style="font-size: 9pt;">     * Maybe we should be using a slab cache for this, especially if</font></div><div><font style="font-size: 9pt;">     * we have a large number of ports to handle.</font></div><div><font style="font-size: 9pt;">     */</font></div><div><font style="font-size: 9pt;">    <font color="#FF0000"><b>drv-&gt;state = kzalloc(sizeof(struct uart_state) * drv-&gt;nr, GFP_KERNEL);</b></font>/*nr为支持的最大串口数量，为每个串口分配一个uart_state结构*/</font></div><div><font style="font-size: 9pt;">    if (!drv-&gt;state)</font></div><div><font style="font-size: 9pt;">        goto out;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">   <font color="#FF0000"> normal = <b>alloc_tty_driver(drv-&gt;nr)</b>;</font>/*分配一个tty_driver类型结构体，设置其magic域和<font color="#FF0000">num域为nr即设备数量</font>*/</font></div><div><font style="font-size: 9pt;">    if (!normal)</font></div><div><font style="font-size: 9pt;">        goto out_kfree;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    drv-&gt;tty_driver = normal;/*将tty的tty_driver域指向normal*/</font></div><div><font style="font-size: 9pt;">    /*都是在对drv的tty_driver域进行设置*/</font></div><div><font style="font-size: 9pt;">    normal-&gt;owner       = drv-&gt;owner;/*驱动模块的拥有者，通常为THIS_MODULE*/</font></div><div><font style="font-size: 9pt;">    normal-&gt;driver_name = drv-&gt;driver_name;</font></div><div><font style="font-size: 9pt;">    normal-&gt;name        = drv-&gt;dev_name;</font></div><div><font style="font-size: 9pt;">    normal-&gt;major       = drv-&gt;major;/*主设备号*/</font></div><div><font style="font-size: 9pt;">    normal-&gt;minor_start = drv-&gt;minor;/*次设备号起始点*/</font></div><div><font style="font-size: 9pt;">    normal-&gt;type        = TTY_DRIVER_TYPE_SERIAL;/*设置tty驱动类型，如pty，串口等，这里为serial串口*/</font></div><div><font style="font-size: 9pt;">    normal-&gt;subtype     = SERIAL_TYPE_NORMAL;</font></div><div><font style="font-size: 9pt;">    normal-&gt;init_termios    = tty_std_termios;</font></div><div><font style="font-size: 9pt;">    normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</font></div><div><font style="font-size: 9pt;">    normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = 9600;</font></div><div><font style="font-size: 9pt;">    normal-&gt;flags       = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</font></div><div><font style="font-size: 9pt;">    normal-&gt;driver_state    = drv;</font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">tty_set_operations(normal, &amp;uart_ops);/*设置normal的ops域为uart_ops,这个地方会重点分析*/</font></b></font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /*</font></div><div><font style="font-size: 9pt;">     * Initialise the UART state(s).</font></div><div><font style="font-size: 9pt;">     */</font></div><div><font style="font-size: 9pt;">/*初始化每一个串口设备的port成员，设置相应参数*/</font></div><div><font style="font-size: 9pt;">    for (i = 0; i &lt; drv-&gt;nr; i++) {</font></div><div><font style="font-size: 9pt;">     <b><font color="#FF0000">   struct uart_state *state = drv-&gt;state + i;</font></b></font></div><div><font color="#FF0000" style="font-size: 9pt;"><b>        struct tty_port *port = &amp;state-&gt;port;</b></font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">        tty_port_init(port);/*初始化等待队列*/</font></div><div><font style="font-size: 9pt;">        <b><font color="#FF0000">port-&gt;ops = &amp;uart_port_ops;/*设置每一个prot的ops域*/</font></b></font></div><div><font style="font-size: 9pt;"><font color="#A8A8A8">        static const struct tty_port_operations</font> <b><font color="#FF0000">uart_port_ops</font></b> <font color="#A8A8A8">= {</font></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .carrier_raised = uart_carrier_raised,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .dtr_rts    = uart_dtr_rts,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        };</font></div><div><font style="font-size: 9pt;">        port-&gt;close_delay     = 500;    /* .5 seconds */</font></div><div><font style="font-size: 9pt;">        port-&gt;closing_wait    = 30000;  /* 30 seconds */</font></div><div><font style="font-size: 9pt;">        <b><font color="#FF0000">tasklet_init(&amp;state-&gt;tlet, uart_tasklet_action,</font></b></font></div><div><font color="#FF0000" style="font-size: 9pt;"><b>                 (unsigned long)state);/*tasklet用于中断的下半部，中断发生后，会调用action函数*/</b></font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font color="#FF0000" style="font-size: 9pt;">    <b>retval = tty_register_driver(normal);/*注册normal结构体到内核*/</b></font></div><div><font style="font-size: 9pt;">    if (retval &gt;= 0)</font></div><div><font style="font-size: 9pt;">        return retval;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">put_tty_driver(normal);/*注册失败调用*/</font></b></font></div><div><font style="font-size: 9pt;">out_kfree:</font></div><div><font style="font-size: 9pt;">    kfree(drv-&gt;state);</font></div><div><font style="font-size: 9pt;">out:</font></div><div><font style="font-size: 9pt;">    return -ENOMEM;</font></div><div><font style="font-size: 9pt;">}</font></div></div><div><font style="font-size: 9pt;">tasklet队列：<a href="https://www.cnblogs.com/sky-heaven/p/8043190.html">https://www.cnblogs.com/sky-heaven/p/8043190.html</a></font></div><div><font style="font-size: 9pt;">中断下半部： <a href="https://blog.csdn.net/myarrow/article/details/9287169">https://blog.csdn.net/myarrow/article/details/9287169</a></font></div><div><font style="font-size: 9pt;">下面分析tty_register_driver函数：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">int <b><font color="#FF0000">tty_register_driver</font></b>(struct tty_driver *driver)</font></div><div><font style="font-size: 9pt;">    int i;</font></div><div><font style="font-size: 9pt;">    dev_t dev;</font></div><div><font style="font-size: 9pt;">    void **p = NULL;</font></div><div><font style="font-size: 9pt;">    struct device *d;</font></div><div><font style="font-size: 9pt;"><font>    </font>if (!(driver-&gt;flags &amp; TTY_DRIVER_DEVPTS_MEM) &amp;&amp; driver-&gt;num)</font></div><div><font style="font-size: 9pt;">    {</font></div><div><font style="font-size: 9pt;"><font>        <b><font color="#FF0000">p = kzalloc(driver-&gt;num * 2 * sizeof(void *), GFP_KERNEL</font></b></font><b><font color="#FF0000">);</font></b></font></div><div><font style="font-size: 9pt;">        if (!p)</font></div><div><font style="font-size: 9pt;">            return -ENOMEM;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (!driver-&gt;major) {</font></div><div><font style="font-size: 9pt;">        error = <font color="#FF0000"><b>alloc_chrdev_region(&amp;dev, driver-&gt;minor_start,</b></font></font></div><div><font color="#FF0000" style="font-size: 9pt;"><b>                        driver-&gt;num, driver-&gt;name);/*动态申请主次设备号*/</b></font></div><div><font style="font-size: 9pt;">        if (!error) {</font></div><div><font style="font-size: 9pt;">            <b>driver-&gt;major = MAJOR(dev);</b></font></div><div><font style="font-size: 9pt;"><b>            driver-&gt;minor_start = MINOR(dev);</b></font></div><div><font style="font-size: 9pt;">        }</font></div><div><font style="font-size: 9pt;">    } else {</font></div><div><font style="font-size: 9pt;"><font>     </font><font><font>   dev = MKDEV(driver-&gt;major, driver-&gt;minor_start);</font>/*静态申请主次设备号*/</font></font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;">    if (error &lt; 0) {</font></div><div><font style="font-size: 9pt;">        kfree(p);</font></div><div><font style="font-size: 9pt;">        return error;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">if (p) {</font></b></font></div><div><font color="#FF0000" style="font-size: 9pt;"><b>        driver-&gt;ttys = (struct tty_struct **)p;</b></font></div><div><font color="#FF0000" style="font-size: 9pt;"><b>        driver-&gt;termios = (struct ktermios **)(p + driver-&gt;num);</b></font></div><div><font style="font-size: 9pt;">    } else {</font></div><div><font style="font-size: 9pt;">        driver-&gt;ttys = NULL;</font></div><div><font style="font-size: 9pt;">        driver-&gt;termios = NULL;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font color="#FF0000" style="font-size: 9pt;">    <b>cdev_init(&amp;driver-&gt;cdev, &amp;tty_fops);/*绑定cdev和fops*/</b></font></div><div><font style="font-size: 9pt;">    driver-&gt;cdev.owner = driver-&gt;owner;</font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">error = cdev_add(&amp;driver-&gt;cdev, dev, driver-&gt;num);/*注册cdev到内核*/</font></b></font></div><div><font style="font-size: 9pt;">    if (error) {</font></div><div><font style="font-size: 9pt;">        unregister_chrdev_region(dev, driver-&gt;num);</font></div><div><font style="font-size: 9pt;">        driver-&gt;ttys = NULL;</font></div><div><font style="font-size: 9pt;">        driver-&gt;termios = NULL;</font></div><div><font style="font-size: 9pt;">        kfree(p);</font></div><div><font style="font-size: 9pt;">        return error;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    mutex_lock(&amp;tty_mutex);</font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">list_add(&amp;driver-&gt;tty_drivers, &amp;tty_drivers);/*将tty_driver加入到链表*/</font></b></font></div><div><font style="font-size: 9pt;">    mutex_unlock(&amp;tty_mutex);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_DEV)) {</font></div><div><font style="font-size: 9pt;">        for (i = 0; i &lt; driver-&gt;num; i++) {</font></div><div><font style="font-size: 9pt;">            <b><font color="#FF0000">d = tty_register_device(driver, i, NULL);/*创建设备节点，由于flags域的设置，这个if语句不会执行*/</font></b></font></div><div><font style="font-size: 9pt;">            if (IS_ERR(d)) {</font></div><div><font style="font-size: 9pt;">                error = PTR_ERR(d);</font></div><div><font style="font-size: 9pt;">                goto err;</font></div><div><font style="font-size: 9pt;">            }</font></div><div><font style="font-size: 9pt;">        }</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">proc_tty_register_driver(driver);</font></b></font></div><div><font style="font-size: 9pt;">    driver-&gt;flags |= TTY_DRIVER_INSTALLED;</font></div><div><font style="font-size: 9pt;">    return 0;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">err:</font></div><div><font style="font-size: 9pt;">    for (i--; i &gt;= 0; i--)</font></div><div><font style="font-size: 9pt;">        tty_unregister_device(driver, i);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    mutex_lock(&amp;tty_mutex);</font></div><div><font style="font-size: 9pt;">    list_del(&amp;driver-&gt;tty_drivers);</font></div><div><font style="font-size: 9pt;">    mutex_unlock(&amp;tty_mutex);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    unregister_chrdev_region(dev, driver-&gt;num);</font></div><div><font style="font-size: 9pt;">    driver-&gt;ttys = NULL;</font></div><div><font style="font-size: 9pt;">    driver-&gt;termios = NULL;</font></div><div><font style="font-size: 9pt;">    kfree(p);</font></div><div><font style="font-size: 9pt;">    return error;</font></div><div><font style="font-size: 9pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">tty_register_device</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">struct device *<font color="#FF0000"><b>tty_register_device</b></font>(struct tty_driver *driver, unsigned index,</font></div><div><font style="font-size: 9pt;">                   struct device *device)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    char name[64];</font></div><div><font style="font-size: 9pt;">    dev_t dev = MKDEV(driver-&gt;major, driver-&gt;minor_start) + index;/*静态创建次设备号*/</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (index &gt;= driver-&gt;num) {</font></div><div><font style="font-size: 9pt;">        printk(KERN_ERR &quot;Attempt to register invalid tty line number &quot;</font></div><div><font style="font-size: 9pt;">               &quot; (%d).\n&quot;, index);</font></div><div><font style="font-size: 9pt;">        return ERR_PTR(-EINVAL);</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (driver-&gt;type == TTY_DRIVER_TYPE_PTY)</font></div><div><font style="font-size: 9pt;">        <b>pty_line_name(driver, index, name);</b></font></div><div><font style="font-size: 9pt;">    else</font></div><div><font style="font-size: 9pt;">        <b>tty_line_name(driver, index, name);/*通过type域判断创建tty还是pty类型设备节点*/</b></font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    return <b><font color="#FF0000">device_create(tty_class, device, dev, NULL, name);/*动态创建设备节点*/</font></b></font></div><div><font style="font-size: 9pt;">}</font></div></div><div><span style="font-size: 12pt;">pro_tty_register_driver</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">void <font color="#FF0000"><b>proc_tty_register_driver</b></font>(struct tty_driver *driver)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    struct proc_dir_entry *ent;</font></div><div><font style="font-size: 9pt;">        </font></div><div><font style="font-size: 9pt;">    if (!driver-&gt;driver_name || driver-&gt;proc_entry ||</font></div><div><font style="font-size: 9pt;">        !driver-&gt;ops-&gt;proc_fops)</font></div><div><font style="font-size: 9pt;">        return;</font></div><div><font style="font-size: 9pt;">        </font></div><div><font style="font-size: 9pt;">    ent <font color="#FF0000">= <b>proc_create_data(driver-&gt;driver_name, 0, proc_tty_driver,</b></font></font></div><div><font color="#FF0000" style="font-size: 9pt;"><b>                   driver-&gt;ops-&gt;proc_fops, driver);/*在proc文件系统下创建相应文件*/</b></font></div><div><font style="font-size: 9pt;">    driver-&gt;proc_entry = ent;</font></div><div><font style="font-size: 9pt;">} </font><font style="font-size: 12pt;">  </font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">到这里，都是核心层的实现，fops我们后面再聊，现在看看底层的实现：</span></div><div><span style="font-size: 12pt;">/linux-3.0/drivers/tty/serial/s3c2440.c</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">static int __init s3c2440_serial_init(void)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    return <b>s3c24xx_serial_init</b>(&amp;s3c2440_serial_driver, &amp;s3c2440_uart_inf);</font></div><div><font style="font-size: 9pt;">}</font></div><div><font style="font-size: 9pt;">static struct <b>platform_driver s3c2440_serial_driver</b> = {</font></div><div><font style="font-size: 9pt;">    .probe      = s3c2440_serial_probe,</font></div><div><font style="font-size: 9pt;">    .remove     = __devexit_p(s3c24xx_serial_remove),</font></div><div><font style="font-size: 9pt;">    .driver     = {</font></div><div><font style="font-size: 9pt;">        .name   = &quot;s3c2440-uart&quot;,</font></div><div><font style="font-size: 9pt;">        .owner  = THIS_MODULE,</font></div><div><font style="font-size: 9pt;">    },</font></div><div><font style="font-size: 9pt;">};</font></div><div><font style="font-size: 9pt;">static struct s3c24xx_uart_info <b>s3c2440_uart_inf</b> = {</font></div><div><font style="font-size: 9pt;">    .name       = &quot;Samsung S3C2440 UART&quot;,</font></div><div><font style="font-size: 9pt;">    .type       = PORT_S3C2440,</font></div><div><font style="font-size: 9pt;">    .fifosize   = 64,</font></div><div><font style="font-size: 9pt;">    .rx_fifomask    = S3C2440_UFSTAT_RXMASK,</font></div><div><font style="font-size: 9pt;">    .rx_fifoshift   = S3C2440_UFSTAT_RXSHIFT,</font></div><div><font style="font-size: 9pt;">    .rx_fifofull    = S3C2440_UFSTAT_RXFULL,</font></div><div><font style="font-size: 9pt;">    .tx_fifofull    = S3C2440_UFSTAT_TXFULL,</font></div><div><font style="font-size: 9pt;">    .tx_fifomask    = S3C2440_UFSTAT_TXMASK,</font></div><div><font style="font-size: 9pt;">    .tx_fifoshift   = S3C2440_UFSTAT_TXSHIFT,</font></div><div><font style="font-size: 9pt;">    .get_clksrc = s3c2440_serial_getsource,</font></div><div><font style="font-size: 9pt;">    .set_clksrc = s3c2440_serial_setsource,</font></div><div><font style="font-size: 9pt;">    .reset_port = s3c2440_serial_resetport,</font></div><div><font style="font-size: 9pt;">};</font></div></div><div><font style="font-size: 9pt;">看到了platform_driver，我们再看看s3c24xx_serial_init这个函数：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">int s3c24xx_serial_init(struct platform_driver *drv,</font></div><div><font style="font-size: 9pt;">            struct s3c24xx_uart_info *info)</font></div><div><font style="font-size: 9pt;">{   </font></div><div><font style="font-size: 9pt;">    dbg(&quot;s3c24xx_serial_init(%p,%p)\n&quot;, drv, info);</font></div><div><font style="font-size: 9pt;">        </font></div><div><font style="font-size: 9pt;">#ifdef CONFIG_PM</font></div><div><font style="font-size: 9pt;">    drv-&gt;suspend = s3c24xx_serial_suspend;</font></div><div><font style="font-size: 9pt;">    drv-&gt;resume = s3c24xx_serial_resume;</font></div><div><font style="font-size: 9pt;">#endif</font></div><div><font style="font-size: 9pt;">    return <b>platform_driver_register(drv)</b>;</font></div><div><font style="font-size: 9pt;">}</font></div></div><div><span style="font-size: 12pt;">主要就是注册平台驱动，驱动结构体就是</span><span style="font-size: 12pt;">s3c2440_serial_driver。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这里没有能继续向下深入的，既然知道了是platform总线的注册，一定还有平台设备的注册，设备和驱动匹配会调用平台驱动的probe函数，我们从probe函数开始：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">static int s3c2440_serial_probe(struct platform_device *dev)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    dbg(&quot;s3c2440_serial_probe: dev=%p\n&quot;, dev);</font></div><div><font style="font-size: 9pt;">    return <b>s3c24xx_serial_probe(dev, &amp;s3c2440_uart_inf);</b></font></div><div><font style="font-size: 9pt;">}</font></div><div><font style="font-size: 9pt;">int <b><font color="#FF0000">s3c24xx_serial_probe</font></b>(struct platform_device *dev,</font></div><div><font style="font-size: 9pt;">             struct s3c24xx_uart_info *info)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">struct s3c24xx_uart_port *ourport;</font></b></font></div><div><font style="font-size: 9pt;">    int ret;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    dbg(&quot;s3c24xx_serial_probe(%p, %p) %d\n&quot;, dev, info, probe_index);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    <b><font color="#FF0000">ourport = &amp;s3c24xx_serial_ports[probe_index];</font></b></font></div><div><font style="font-size: 9pt;">    probe_index++;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    dbg(&quot;%s: initialising port %p...\n&quot;, __func__, ourport);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    <b><font style="color: rgb(255, 0, 0);">ret = s3c24xx_serial_init_port(ourport, info, dev);</font></b></font></div><div><font style="font-size: 9pt;">    if (ret &lt; 0)</font></div><div><font style="font-size: 9pt;">        goto probe_err;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    dbg(&quot;%s: adding port\n&quot;, __func__);</font></div><div><font style="font-size: 9pt;">   <font color="#FF0000"><b> uart_add_one_port(&amp;s3c24xx_uart_drv, &amp;ourport-&gt;port);</b></font></font></div><div><font style="font-size: 9pt;">    platform_set_drvdata(dev, &amp;ourport-&gt;port);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    ret = device_create_file(&amp;dev-&gt;dev, &amp;dev_attr_clock_source);</font></div><div><font style="font-size: 9pt;">    if (ret &lt; 0)</font></div><div><font style="font-size: 9pt;">        printk(KERN_ERR &quot;%s: failed to add clksrc attr.\n&quot;, __func__);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    ret = s3c24xx_serial_cpufreq_register(ourport);</font></div><div><font style="font-size: 9pt;">    if (ret &lt; 0)</font></div><div><font style="font-size: 9pt;">        dev_err(&amp;dev-&gt;dev, &quot;failed to add cpufreq notifier\n&quot;);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    return 0;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">probe_err:</font></div><div><font style="font-size: 9pt;">    return ret;</font></div><div><font style="font-size: 9pt;">}</font></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#A8A8A8" style="font-size: 9pt;">static struct s3c24xx_uart_port s3c24xx_serial_ports[CONFIG_SERIAL_SAMSUNG_UARTS] = {</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    [0] = {</font></div><div><font style="font-size: 9pt;"><font color="#A8A8A8">        </font><font color="#FF0000"><b>.port</b></font> <font color="#A8A8A8">= {</font></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .lock       = __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[0].port.lock),</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .iotype     = UPIO_MEM,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .irq        = IRQ_S3CUART_RX0,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .uartclk    = 0,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .fifosize   = 16,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .ops        = &amp;s3c24xx_serial_ops,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .flags      = UPF_BOOT_AUTOCONF,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .line       = 0,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        }</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    },</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    [1] = {</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        .port = {</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .lock       = __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[1].port.lock),</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .iotype     = UPIO_MEM,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .irq        = IRQ_S3CUART_RX1,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .uartclk    = 0,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .fifosize   = 16,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .ops        = &amp;s3c24xx_serial_ops,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .flags      = UPF_BOOT_AUTOCONF,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .line       = 1,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        }</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    },</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#if CONFIG_SERIAL_SAMSUNG_UARTS &gt; 2</font></div><div><font color="#A8A8A8" style="font-size: 9pt;"><br/></font></div><div><font color="#A8A8A8" style="font-size: 9pt;"><br/></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    [2] = {</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        .port = {</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .lock       = __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[2].port.lock),</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .iotype     = UPIO_MEM,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .irq        = IRQ_S3CUART_RX2,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .uartclk    = 0,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .fifosize   = 16,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .ops        = &amp;s3c24xx_serial_ops,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .flags      = UPF_BOOT_AUTOCONF,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .line       = 2,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        }</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    },</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#endif</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#if CONFIG_SERIAL_SAMSUNG_UARTS &gt; 3</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    [3] = {</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        .port = {</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .lock       = __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[3].port.lock),</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .iotype     = UPIO_MEM,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .irq        = IRQ_S3CUART_RX3,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .uartclk    = 0,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .fifosize   = 16,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .ops        = &amp;s3c24xx_serial_ops,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .flags      = UPF_BOOT_AUTOCONF,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">            .line       = 3,</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">        }</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    }</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#endif</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">};</font></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;"><font color="#A8A8A8">struct</font> <b><font color="#FF0000">s3c24xx_uart_port</font></b> <font color="#A8A8A8">{</font></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char           rx_claimed;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char           tx_claimed;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int            pm_level;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned long           baudclk_rate;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;"><br/></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int            rx_irq;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int            tx_irq;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;"><br/></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct s3c24xx_uart_info    *info;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct s3c24xx_uart_clksrc  *clksrc;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct clk          *clk;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct clk          *baudclk;</font></div><div><font style="font-size: 9pt;"><font color="#A8A8A8">    </font><font color="#FF0000"><b>struct uart_port        port;</b></font></font></div><div><font color="#A8A8A8" style="font-size: 9pt;"><br/></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#ifdef CONFIG_CPU_FREQ</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct notifier_block       freq_transition;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#endif</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">};</font></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;"><span style="color: rgb(168, 168, 168);">struct</span> <font color="#FF0000"><b>uart_port</b></font> <span style="color: rgb(168, 168, 168);">{</span></font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    spinlock_t        lock;            /* port lock */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned long        iobase;            /* io端口基地址（物理） */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char __iomem    *membase;        /* io内存基地址（虚拟） */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        (*serial_in)(struct uart_port *, int);</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    void            (*serial_out)(struct uart_port *, int, int);</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        irq;            /* 中断号 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned long        irqflags;        /* 中断标志  */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        uartclk;        /* 串口时钟 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        fifosize;        /* 串口缓冲区大小 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char        x_char;            /* xon/xoff char */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char        regshift;        /* 寄存器位移 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char        iotype;            /* IO访问方式 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char        unused1;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        read_status_mask;    /* 关心 Rx error status */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        ignore_status_mask;    /* 忽略 Rx error status */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct uart_state    *state;            /* pointer to parent state */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct uart_icount    icount;            /* 串口信息计数器 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct console        *cons;            /* struct console, if any */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned long        sysrq;            /* sysrq timeout */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">#endif</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    upf_t            flags;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        mctrl;            /* 当前的Moden 设置 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        timeout;        /* character-based timeout */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        type;            /* 端口类型 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    const struct uart_ops    *ops;        /* 串口端口操作函数 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        custom_divisor;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned int        line;            /* 端口索引 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    resource_size_t        mapbase;        /* io内存物理基地址 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    struct device        *dev;            /* 父设备 */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char        hub6;            /* this should be in the 8250 driver */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char        suspended;</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    unsigned char        unused[2];</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">    void            *private_data;        /* generic platform data pointer */</font></div><div><font color="#A8A8A8" style="font-size: 9pt;">};</font></div></div><div><span style="font-size: 12pt;">结构体uart_port是一个通用结构体，他是我们自己填充的一个结构体，在s3c2440中，填充如上，而s3c2440还会有其他的信息需要添加，就使用了一个s3c特征结构体来包含uart_port以及自己的特殊信息。</span></div><div><span style="font-size: 12pt;">看到函数</span> <font style="font-size: 12pt;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); font-size: 12pt; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">s3c24xx_serial_init_port</span></font></div><div><font style="font-size: 12pt;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248);"><br/></span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport, </font></div><div><font style="font-size: 9pt;">            struct s3c24xx_uart_info *info, struct platform_device *platdev)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    struct uart_port *port = &amp;ourport-&gt;port;</font></div><div><font style="font-size: 9pt;">    struct s3c2410_uartcfg *cfg;</font></div><div><font style="font-size: 9pt;">    struct resource *res;</font></div><div><font style="font-size: 9pt;">    int ret;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    dbg(&quot;s3c24xx_serial_init_port: port=%p, platdev=%p\n&quot;, port, platdev);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (platdev == NULL)</font></div><div><font style="font-size: 9pt;">        return -ENODEV;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    <b>cfg = s3c24xx_dev_to_cfg(&amp;platdev-&gt;dev);</b></font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (port-&gt;mapbase != 0)</font></div><div><font style="font-size: 9pt;">        return 0;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (cfg-&gt;hwport &gt; CONFIG_SERIAL_SAMSUNG_UARTS) {</font></div><div><font style="font-size: 9pt;">        printk(KERN_ERR &quot;%s: port %d bigger than %d\n&quot;, __func__,</font></div><div><font style="font-size: 9pt;">               cfg-&gt;hwport, CONFIG_SERIAL_SAMSUNG_UARTS);</font></div><div><font style="font-size: 9pt;">        return -ERANGE;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /* setup info for port */</font></div><div><font style="font-size: 9pt;">    port-&gt;dev   = &amp;platdev-&gt;dev;</font></div><div><font style="font-size: 9pt;">    ourport-&gt;info   = info;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /* copy the info in from provided structure */</font></div><div><font style="font-size: 9pt;">    ourport-&gt;port.fifosize = info-&gt;fifosize;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    dbg(&quot;s3c24xx_serial_init_port: %p (hw %d)...\n&quot;, port, cfg-&gt;hwport);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">   port-&gt;uartclk = 1;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (cfg-&gt;uart_flags &amp; UPF_CONS_FLOW) {</font></div><div><font style="font-size: 9pt;">        dbg(&quot;s3c24xx_serial_init_port: enabling flow control\n&quot;);</font></div><div><font style="font-size: 9pt;">        port-&gt;flags |= UPF_CONS_FLOW;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /* sort our the physical and virtual addresses for each UART */</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    res = platform_get_resource(platdev, IORESOURCE_MEM, 0);</font></div><div><font style="font-size: 9pt;">    if (res == NULL) {</font></div><div><font style="font-size: 9pt;">        printk(KERN_ERR &quot;failed to find memory resource for uart\n&quot;);</font></div><div><font style="font-size: 9pt;">        return -EINVAL;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    dbg(&quot;resource %p (%lx..%lx)\n&quot;, res, res-&gt;start, res-&gt;end);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    port-&gt;mapbase = res-&gt;start;</font></div><div><font style="font-size: 9pt;">    port-&gt;membase = S3C_VA_UART + (res-&gt;start &amp; 0xfffff);</font></div><div><font style="font-size: 9pt;">    ret = platform_get_irq(platdev, 0);</font></div><div><font style="font-size: 9pt;">    if (ret &lt; 0)</font></div><div><font style="font-size: 9pt;">        port-&gt;irq = 0;</font></div><div><font style="font-size: 9pt;">    else {</font></div><div><font style="font-size: 9pt;">        port-&gt;irq = ret;</font></div><div><font style="font-size: 9pt;">        ourport-&gt;rx_irq = ret;</font></div><div><font style="font-size: 9pt;">        ourport-&gt;tx_irq = ret + 1;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    ret = platform_get_irq(platdev, 1);</font></div><div><font style="font-size: 9pt;">    if (ret &gt; 0)</font></div><div><font style="font-size: 9pt;">        ourport-&gt;tx_irq = ret;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    ourport-&gt;clk    = clk_get(&amp;platdev-&gt;dev, &quot;uart&quot;);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    dbg(&quot;port: map=%08x, mem=%08x, irq=%d (%d,%d), clock=%ld\n&quot;,</font></div><div><font style="font-size: 9pt;">        port-&gt;mapbase, port-&gt;membase, port-&gt;irq,</font></div><div><font style="font-size: 9pt;">        ourport-&gt;rx_irq, ourport-&gt;tx_irq, port-&gt;uartclk);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /* reset the fifos (and setup the uart) */</font></div><div><font style="font-size: 9pt;">    s3c24xx_serial_resetport(port, cfg);</font></div><div><font style="font-size: 9pt;">    return 0;</font></div><div><font style="font-size: 9pt;">}</font></div></div><div><span style="font-size: 12pt;">函数很复杂，大概就是做一些硬件的初始化。在这里，port中的某些硬件信息由platform_device提供。</span></div><div><span style="font-size: 12pt;">紧接着是函数</span><span style="font-size: 12pt;">uart_add_one_port</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)</font></div><div><font style="font-size: 9pt;">{</font></div><div><font style="font-size: 9pt;">    struct uart_state *state;</font></div><div><font style="font-size: 9pt;">    struct tty_port *port;</font></div><div><font style="font-size: 9pt;">    int ret = 0;</font></div><div><font style="font-size: 9pt;">    struct device *tty_dev;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    BUG_ON(in_interrupt());</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    if (uport-&gt;line &gt;= drv-&gt;nr)</font></div><div><font style="font-size: 9pt;">        return -EINVAL;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    state = drv-&gt;state + uport-&gt;line;</font></div><div><font style="font-size: 9pt;">    port = &amp;state-&gt;port;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    mutex_lock(&amp;port_mutex);</font></div><div><font style="font-size: 9pt;">    mutex_lock(&amp;port-&gt;mutex);</font></div><div><font style="font-size: 9pt;">    if (state-&gt;uart_port) {</font></div><div><font style="font-size: 9pt;">        ret = -EINVAL;</font></div><div><font style="font-size: 9pt;">        goto out;</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    state-&gt;uart_port = uport;</font></div><div><font style="font-size: 9pt;">    state-&gt;pm_state = -1;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    uport-&gt;cons = drv-&gt;cons;</font></div><div><font style="font-size: 9pt;">    uport-&gt;state = state;</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /*</font></div><div><font style="font-size: 9pt;">     * If this port is a console, then the spinlock is already</font></div><div><font style="font-size: 9pt;">     * initialised.</font></div><div><font style="font-size: 9pt;">     */</font></div><div><font style="font-size: 9pt;">    if (!(uart_console(uport) &amp;&amp; (uport-&gt;cons-&gt;flags &amp; CON_ENABLED))) {</font></div><div><font style="font-size: 9pt;">        spin_lock_init(&amp;uport-&gt;lock);</font></div><div><font style="font-size: 9pt;">        lockdep_set_class(&amp;uport-&gt;lock, &amp;port_lock_key);</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    uart_configure_port(drv, state, uport);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /*</font></div><div><font style="font-size: 9pt;">     * Register the port whether it's detected or not.  This allows</font></div><div><font style="font-size: 9pt;">     * setserial to be used to alter this ports parameters.</font></div><div><font style="font-size: 9pt;">     */</font></div><div><font style="font-size: 9pt;">    <b>tty_dev = tty_register_device(drv-&gt;tty_driver, uport-&gt;line, uport-&gt;dev);</b></font></div><div><font style="font-size: 9pt;">    if (likely(!IS_ERR(tty_dev))) {</font></div><div><font style="font-size: 9pt;">        device_init_wakeup(tty_dev, 1);</font></div><div><font style="font-size: 9pt;">        device_set_wakeup_enable(tty_dev, 0);</font></div><div><font style="font-size: 9pt;">    } else</font></div><div><font style="font-size: 9pt;">        printk(KERN_ERR &quot;Cannot register tty device on line %d\n&quot;,</font></div><div><font style="font-size: 9pt;">               uport-&gt;line);</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    /*</font></div><div><font style="font-size: 9pt;">     * Ensure UPF_DEAD is not set.</font></div><div><font style="font-size: 9pt;">     */</font></div><div><font style="font-size: 9pt;">    uport-&gt;flags &amp;= ~UPF_DEAD;</font></div><div><font style="font-size: 9pt;">out:</font></div><div><font style="font-size: 9pt;">    mutex_unlock(&amp;port-&gt;mutex);</font></div><div><font style="font-size: 9pt;">    mutex_unlock(&amp;port_mutex);</font></div><div><font style="font-size: 9pt;">    return ret;</font></div><div><font style="font-size: 9pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">struct uart_state {</font></div><div><font style="font-size: 9pt;">    struct tty_port     port;</font></div><div><font style="font-size: 9pt;">         </font></div><div><font style="font-size: 9pt;">    int         pm_state;</font></div><div><font style="font-size: 9pt;">    struct circ_buf     xmit;</font></div><div><font style="font-size: 9pt;">             </font></div><div><font style="font-size: 9pt;">    struct tasklet_struct   tlet;</font></div><div><font style="font-size: 9pt;">    struct uart_port    *uart_port;</font></div><div><font style="font-size: 9pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">主要完成</span><span style="font-size: 12pt; font-weight: bold;">tty_register_device设备节点的创建。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在停下来总结一下，在tty子系统串口注册这里，涉及到多个fops的file_operation类型结构体，这些结构我们待会会重点分析。重点了解samsung.c这个文件：</span></div><div><span style="font-size: 12pt;">调用uart_register_driver（定义在serial_core.c中）注册一个uart_driver类型结构体。</span><span style="font-size: 12pt;">函数uart_register_driver函数会注册tty_driver类型结构normal并设置其ops域为uart_ops，调用tty_register_driver（定义在tty_io.c中）函数注册normal结构体，此函数会申请注册设备号，并开辟tty_driver结构的ttys和termios域，最后注册cdev并绑定fops到内核，加入链表，在proc下创建对应文件。</span></div><div><br/></div><div><span style="font-size: 12pt;">由于cdev的注册，我们可以开始分析绑定cdev的结构fops，从open函数开始（定义在tty_io.c中）：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static const struct file_operations tty_fops = {</div><div>    .llseek     = no_llseek,</div><div>    .read       = tty_read,</div><div>    .write      = tty_write,</div><div>    .poll       = tty_poll,</div><div>    .unlocked_ioctl = tty_ioctl,</div><div>    .compat_ioctl   = tty_compat_ioctl,</div><div>    .open       = tty_open,</div><div>    .release    = tty_release,</div><div>    .fasync     = tty_fasync,</div><div>};</div></div><div><br/></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int <b>tty_open</b>(struct inode *inode, struct file *filp)</div><div>{</div><div>    struct tty_struct *tty = NULL;</div><div>    int noctty, retval;</div><div>    struct tty_driver *driver;</div><div>    int index;</div><div>    <b>dev_t device = inode-&gt;i_rdev;</b></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>.....</div><div><br/></div><div>    <b>driver = get_tty_driver(device, &amp;index);/*在tty_driver链表中通过设备号找到对应tty_driver</b></div><div><b>.....</b></div><div><b><br/></b></div><div>        <b>/* check whether we're reopening an existing tty */</b></div><div>       <b> tty = tty_driver_lookup_tty(driver, inode, index);/*如果tty_driver的ops域定义了lookup函数，就调用，反之返回tty_driver的ttys[index]*/</b></div><div><b>.....</b></div><div><b><br/></b></div><div>        <b>tty = tty_init_dev(driver, index, 0);</b></div><div><b>......</b></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    <b>if (tty-&gt;ops-&gt;open)</b></div><div><b>        retval = tty-&gt;ops-&gt;open(tty, filp);/*调用tty的ops域的open函数--uart_open()*/</b></div><div><b>......</b></div><div>}</div></div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct tty_struct *<b>tty_init_dev</b>(struct tty_driver *driver, int idx,</div><div>                                int first_ok)</div><div>{</div><div>    struct tty_struct *tty;</div><div>    int retval;</div><div><br/></div><div>  <b>  tty = alloc_tty_struct();为tty分配空间</b></div><div><b>......</b></div><div>    <b>initialize_tty_struct(tty, driver, idx);</b></div><div><b><br/></b></div><div><b>初始化tty成员，初始化ldise成员N_TTY,初始化等待队列，工作队列ops域为tty_driver的ops域，index域位位tty_driver的index域等*/</b></div><div><b>......</b></div><div>    <b>retval = tty_ldisc_setup(tty, tty-&gt;link);/*调用n_tty_open函数进行一些设置*/</b></div><div><b>......</b></div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void <b>initialize_tty_struct</b>(struct tty_struct *tty,</div><div>        struct tty_driver *driver, int idx)</div><div>{</div><div>    memset(tty, 0, sizeof(struct tty_struct));</div><div><b><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span></span>  tty_ldisc_init(tty);</b></div><div><b><span>    </span>tty_buffer_init(tty);</b><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>......</b></span></div><div><b><span>    </span></b>init_waitqueue_head(&amp;tty-&gt;write_wait);</div><div>    init_waitqueue_head(&amp;tty-&gt;read_wait);</div><div>    INIT_WORK(&amp;tty-&gt;hangup_work, do_tty_hangup);</div><div><b>......  </b></div><div>    <b>tty-&gt;driver = driver;</b></div><div><b>    tty-&gt;ops = driver-&gt;ops;</b></div><div>   <b> tty-&gt;index = idx;</b></div><div>    tty_line_name(driver, idx, tty-&gt;name);</div><div>    tty-&gt;dev = tty_get_device(tty);</div><div>}</div><div>void <b>tty_ldisc_init</b>(struct tty_struct *tty)</div><div>{</div><div>    <b>struct tty_ldisc *ld = tty_ldisc_get(N_TTY);</b></div><div>    if (IS_ERR(ld))</div><div>        panic(&quot;n_tty: init_tty&quot;);</div><div>    tty_ldisc_assign(tty, ld);</div><div>}   </div><div>void <b>tty_buffer_init</b>(struct tty_struct *tty)</div><div>{   </div><div>    spin_lock_init(&amp;tty-&gt;buf.lock);</div><div>    tty-&gt;buf.head = NULL;</div><div>    tty-&gt;buf.tail = NULL;</div><div>    tty-&gt;buf.free = NULL;</div><div>    tty-&gt;buf.memory_used = 0;</div><div>    INIT_WORK(&amp;tty-&gt;buf.work, flush_to_ldisc);</div><div>}  </div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int <b>tty_ldisc_setup</b>(struct tty_struct *tty, struct tty_struct *o_tty)</div><div>{   </div><div>    struct <b>tty_ldisc *ld = tty-&gt;ldisc;</b></div><div>    int retval;</div><div>    </div><div>    retval = <b>tty_ldisc_open(tty, ld)</b>;</div><div><br/></div><div>    if (o_tty) {</div><div>        retval = <b>tty_ldisc_open(o_tty, o_tty-&gt;ldisc);</b></div><div><b>......</b></div><div>    return 0;</div><div>}   </div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int <b>tty_ldisc_open</b>(struct tty_struct *tty, struct tty_ldisc *ld)</div><div>{</div><div>    WARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &amp;tty-&gt;flags));</div><div>    if (ld-&gt;ops-&gt;open) {</div><div>        int ret;</div><div>                /* BTM here locks versus a hangup event */</div><div>        WARN_ON(!tty_locked());</div><div>        <b>ret = ld-&gt;ops-&gt;open(tty);/*如果tty-&gt;ldisc-&gt;ops-&gt;open存在，就调用它，对于ntty来说是n_tty_open*/</b></div><div>        if (ret)</div><div>            clear_bit(TTY_LDISC_OPEN, &amp;tty-&gt;flags);</div><div>        return ret;</div><div>    }</div><div>    return 0;</div><div>}</div></div><div><br/></div><div><font style="font-size: 12pt;">函数tty_open：<br/></font></div><div><span style="font-size: 12pt;"><span>    </span><span>    </span>通过inode获取到相应的tty_driver结构。</span></div><div><span style="font-size: 12pt;"><span>    </span><span>    </span>创建tty_struct类型结构tty,初始化tty的相应成员，线路规程tty-&gt;ldisc域为N_TTY对用函数n_tty_open...。初始化tty-&gt;buf域，初始化等待队列等，ops域为tty_driver的ops域，tty_driver域为tty_driver等。</span></div><div><span style="font-size: 12pt;"><span>    </span><span>    tty-&gt;ops-&gt;open到tty_driver-&gt;ops-&gt;open-&gt;uart_open</span><br/></span></div><div><span style="font-size: 12pt;"><span><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">static int <b>uart_open</b>(struct tty_struct *tty, struct file *filp)</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    <b>struct uart_driver *drv = (struct uart_driver *)tty-&gt;driver-&gt;driver_state;/*获取到uart_driver结构*/</b></span></div><div><span style="font-size: 12pt;">    struct uart_state *state;</span></div><div><span style="font-size: 12pt;">    struct tty_port *port;</span></div><div><span style="font-size: 12pt;">    int retval, line = tty-&gt;index;</span></div><div><span style="font-size: 12pt;">...</span></div><div><span style="font-size: 12pt;">  <b>  state = uart_get(drv, line);</b></span></div><div><span style="font-size: 12pt;"><b>...</b></span></div><div><span style="font-size: 12pt;">    <b>port = &amp;state-&gt;port;</b></span></div><div><span style="font-size: 12pt;"><b>...</b></span></div><div><span style="font-size: 12pt;">    <b>tty-&gt;driver_data = state;</b></span></div><div><span style="font-size: 12pt;">    <b>state-&gt;uart_port-&gt;state = state;</b></span></div><div><span style="font-size: 12pt;">...</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    <b>retval = uart_startup(tty, state, 0);</b></span></div><div><span style="font-size: 12pt;"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></span></div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static struct uart_state <b>*uart_get</b>(struct uart_driver *drv, int line)</div><div>{</div><div>    struct uart_state *state;</div><div>    struct tty_port *port;</div><div>    int ret = 0;</div><div><br/></div><div>    <b>state = drv-&gt;state + line;</b></div><div>    <b>port = &amp;state-&gt;port;</b></div><div><br/></div><div>    port-&gt;count++;</div><div>    if (!state-&gt;uart_port || state-&gt;uart_port-&gt;flags &amp; UPF_DEAD) {</div><div>        ret = -ENXIO;</div><div>        goto err_unlock;</div><div>    }</div><div>    <b>return state;</b></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>}</div></div><div><span style="font-size: 12pt;">获取到uart_driver结构，tty-&gt;driver_data-&gt;uart_port-&gt;state指向uart_driver的state域。</span></div><div><span style="font-size: 12pt;">调用uart_startup函数。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int <b>uart_startup</b>(struct tty_struct *tty, struct uart_state *state, int init_hw)</div><div>{</div><div>    struct uart_port *uport = state-&gt;uart_port;</div><div>    struct tty_port *port = &amp;state-&gt;port;</div><div>    unsigned long page;</div><div>    int retval = 0;</div><div>...</div><div>    <b>retval = uport-&gt;ops-&gt;startup(uport);</b></div><div>...</div><div>    return retval;</div><div>}</div></div><div><span style="font-size: 12pt;">最终调用uart_state-&gt;uart_port-&gt;ops域的startup函数，前面的tty_open，uart_open，uart_startup都是内核提供固定执行函数，直到uart_port域的ops函数，对于不同的cpu这些函数实现是不同的，我们后面分析。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在看到tty_write函数：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static ssize_t <b>tty_write</b>(struct file *file, const char __user *buf,</div><div>                        size_t count, loff_t *ppos)</div><div>{</div><div>    struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;</div><div>    struct tty_struct *tty = file_tty(file);</div><div>    struct tty_ldisc *ld;</div><div>    ssize_t ret;</div><div>...</div><div>    <b>ld = tty_ldisc_ref_wait(tty);/*获取tty的线路规程*/</b></div><div>    if (!ld-&gt;ops-&gt;write)</div><div>        ret = -EIO;</div><div>    else</div><div>        ret = <b>do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count);/*最终调用回调函数ld-&gt;ops-&gt;write*/</b></div><div>    tty_ldisc_deref(ld);</div><div>    return ret;</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static inline ssize_t <b>do_tty_write</b>(</div><div>    ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t),</div><div>    struct tty_struct *tty,</div><div>    struct file *file,</div><div>    const char __user *buf,</div><div>    size_t count)</div><div>{</div><div>    ssize_t ret, written = 0;</div><div>    unsigned int chunk;</div><div>...</div><div><br/></div><div> <b>       buf_chunk = kmalloc(chunk, GFP_KERNEL);</b></div><div><b>...</b></div><div><b>        tty-&gt;write_cnt = chunk;</b></div><div><b>        tty-&gt;write_buf = buf_chunk;</b></div><div>    }</div><div><br/></div><div>    /* Do the write .. */</div><div>    for (;;) {</div><div>        size_t size = count;</div><div>        if (size &gt; chunk)</div><div>            size = chunk;</div><div>        ret = -EFAULT;</div><div>        if (<b>copy_from_user(tty-&gt;write_buf, buf, size)</b>)/*从应用层获取数据*/</div><div>            break;</div><div>       <b> ret = write(tty, file, tty-&gt;write_buf, size);/*调用ld-&gt;ops&gt;write函数即n_tty_write函数*/</b></div><div>        written += ret;</div><div>        buf += ret;</div><div>        count -= ret;</div><div>...</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static ssize_t <b>n_tty_write</b>(struct tty_struct *tty, struct file *file,</div><div>               const unsigned char *buf, size_t nr)</div><div>{</div><div>    const unsigned char *b = buf;</div><div>    DECLARE_WAITQUEUE(wait, current);</div><div>    int c;</div><div>    ssize_t retval = 0;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    <b>add_wait_queue(&amp;tty-&gt;write_wait, &amp;wait);</b></div><div>    while (1) {</div><div>        <b>set_current_state(TASK_INTERRUPTIBLE);</b></div><div>        if (signal_pending(current)) {</div><div>            retval = -ERESTARTSYS;</div><div>            break;</div><div>        }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>            while (nr &gt; 0) {</div><div>                c = <b>tty-&gt;ops-&gt;write(tty, b, nr);</b></div><div><b>...</b></div><div>}</div></div><div><span style="font-size: 12pt;">调用tty-&gt;ops-&gt;write即uart_write函数；</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int uart_write(struct tty_struct *tty,</div><div>                    const unsigned char *buf, int count)</div><div>{</div><div>    struct uart_state *state = tty-&gt;driver_data;</div><div>    struct uart_port *port;</div><div>    struct circ_buf *circ;</div><div>    unsigned long flags;</div><div>    int c, ret = 0;</div><div>...</div><div><br/></div><div><b>    uart_start(tty);</b></div><div>    return ret;</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void <b>uart_start</b>(struct tty_struct *tty)</div><div>{</div><div>    struct uart_state *state = tty-&gt;driver_data;</div><div>    struct uart_port *port = state-&gt;uart_port;</div><div>...</div><div>    <b>__uart_start(tty);</b></div><div>    spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void _<b>_uart_start</b>(struct tty_struct *tty)</div><div>{</div><div>    struct uart_state *state = tty-&gt;driver_data;</div><div>    struct uart_port *port = state-&gt;uart_port;</div><div><br/></div><div>    if (!uart_circ_empty(&amp;state-&gt;xmit) &amp;&amp; state-&gt;xmit.buf &amp;&amp;</div><div>        !tty-&gt;stopped &amp;&amp; !tty-&gt;hw_stopped)</div><div>       <b> port-&gt;ops-&gt;start_tx(port);</b></div><div>}</div></div><div><span style="font-size: 12pt;">调用tty_driver_data-&gt;uart_port-&gt;ops-&gt;start_tx函数。这个函数后面分析。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div></span>
</div></body></html> 