<html>
<head>
  <title>2.event_base注册</title>
  <basefont face="Verdana" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Verdana;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="931"/>
<h1>2.event_base注册</h1>

<div>
<span><div><div><span style="font-weight: bold;">libevent所有的核心工作函数运行都围绕着一个结构体struct event_base</span></div><div><br/></div><div><span style="font-weight: bold;">在调用任何libevent核心函数之前，都会先创建一个这样的结构体</span></div><div><br/></div><div><span style="font-weight: bold;">创建event_base（base可以理解为基础，根基的意思，所有事物的工作都必须围绕其展开）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event_base * event_base_new(void)</div><div>{       </div><div>    struct event_base *base = NULL;</div><div>    struct event_config *cfg = event_config_new();</div><div>    if (cfg) {</div><div>        <font style="color: rgb(255, 0, 0);">base = event_base_new_with_config(cfg);</font></div><div>        event_config_free(cfg);</div><div>    }   </div><div>    return base;</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">函数event_config_new()</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event_config *event_config_new(void)</div><div>{</div><div>    <font color="#FF0000">struct event_config *cfg = mm_calloc(1, sizeof(*cfg));//内存分配</font></div><div><br/></div><div><br/></div><div>    if (cfg == NULL)</div><div>        return (NULL);</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">TAILQ_INIT(&amp;cfg-&gt;entries);//初始化enteries</font></div><div><font color="#FF4635">    </font><font color="#FF7A74">cfg-&gt;max_dispatch_interval.tv_sec = -1;</font></div><div><font color="#FF7A74">    cfg-&gt;max_dispatch_callbacks = INT_MAX;</font></div><div><font color="#FF7A74">    cfg-&gt;limit_callbacks_after_prio = 1;//其他成员初始化</font></div><div><br/></div><div><br/></div><div>    return (cfg);</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">结构体struct event_config</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event_config {</div><div>    TAILQ_HEAD(event_configq, event_config_entry) entries;</div><div><br/></div><div><font color="#A8A8A8">    int n_cpus_hint;</font></div><div><font color="#A8A8A8">    struct timeval max_dispatch_interval;</font></div><div><font color="#A8A8A8">    int max_dispatch_callbacks;</font></div><div><font color="#A8A8A8">    int limit_callbacks_after_prio;</font></div><div>    enum event_method_feature require_features;</div><div>    enum event_base_config_flag flags;</div><div>};</div><div><br/></div><div>struct event_config_entry {</div><div>    TAILQ_ENTRY(event_config_entry) next;</div><div><br/></div><div>    const char *avoid_method;</div><div>};</div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">函数event_config_new只是做一些简单的初始化，最后会调用函数event_base_new_with_config去进行关键的初始化并返回event_base结构体。</span></div><div><br/></div><div><span style="font-weight: bold;">所以对event_base的初始化，实际上就是对结构体event_config的初始化。</span></div><div><br/></div><div><span style="font-weight: bold;">接下来分析此结构体成员：</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">TAILQ_HEAD(event_configq, event_config_entry) entries和 </span><span style="color: rgb(255, 0, 0); font-weight: bold;">TAILQ_ENTRY(event_config_entry) next;</span><span style="color: rgb(255, 0, 0); font-weight: bold;">;</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define TAILQ_HEAD(name, type)                        \</div><div>struct name {                                \</div><div>    struct type *tqh_first;    /* first element */            \</div><div>    struct type **tqh_last;    /* addr of last next element */        \</div><div>}</div><div>#define TAILQ_ENTRY(type)                        \</div><div>struct {                                \</div><div>    struct type *tqe_next;    /* next element */            \</div><div>    struct type **tqe_prev;    /* address of previous next element */    \</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">结果就是：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event_configq {                                \</div><div>    struct event_config_entry *tqh_first;    /* first element */            \</div><div>    struct event_config_entry **tqh_last;    /* addr of last next element */        \</div><div>} entries;</div></div><div><br/></div><div><span style="font-weight: bold;">结构体event_config_entry展开：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event_config_entry {</div><div>    struct {                                \</div><div>        struct event_config_entry *tqe_next;    /* next element */            \</div><div>        struct event_config_entry **tqe_prev;    /* address of previous next element */    \</div><div>    }next;</div><div>    const char *avoid_method;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">创建一个队列头，名为entries，首尾指针都是</span><span style="font-weight: bold;">struct event_config_entry类型。多个元素构成的队列如下：</span></div><div><br/></div><div><span style="font-weight: bold;"><img src="2.event_base注册_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">而队列元素的数据成员</span><span style="font-weight: bold;">avoid_method，代表此event_base避免使用过的后端。</span></div><div><span style="font-weight: bold;">这里的后端指的就是IO多路复用的方式，在libevent源码包里面，可以看到不同平台的不同的IO多路复用的实现文件如下：</span></div><div><span style="font-weight: bold;"><img src="2.event_base注册_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">在这里，</span><span style="font-weight: bold;">avoid_method通过字符串指定不使用的后端，字符串形式则为后端的名字如select，epoll等。由于可以指定多个不使用的后端，故使用链表将不使用的所有后端进行存储。</span></div><div><br/></div><div><span style="font-weight: bold;">拒绝使用特定后端的函数：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>event_config_avoid_method(struct event_config *cfg, const char *method)</div><div>{</div><div>    <font color="#FF0000">struct event_config_entry *entry = mm_malloc(sizeof(*entry));//为队列结构体分配内存</font></div><div>    if (entry == NULL)</div><div>        return (-1);</div><div><br/></div><div><br/></div><div>    <font color="#FF0000">if ((entry-&gt;avoid_method = mm_strdup(method)) == NULL) {//为不使用的后端method分配内存并保存到队列结构体</font></div><div>        mm_free(entry);</div><div>        return (-1);</div><div>    }</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    <font color="#FF0000">TAILQ_INSERT_TAIL(&amp;cfg-&gt;entries, entry, next);//将其插入到不使用的后端的队列中</font></div><div><br/></div><div>    return (0);</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">第二个参数调整CPU个数</span></div><div><span style="font-weight: bold;">不懂...</span></div><div><br/></div><div><span style="font-weight: bold;">其他元素会在event_config_new分配内存时进行初始化</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">require_fratures枚举体指定IO复用应该满足的特征：</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">可以是多个宏的或运算</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>enum event_method_feature {</div><div>    /** Require an event method that allows edge-triggered events with EV_ET. */</div><div>    <font style="color: rgb(255, 0, 0);">EV_FEATURE_ET = 0x01,    //允许使用EV_ET触发边缘事件</font></div><div>    /** Require an event method where having one event triggered among</div><div>     * many is [approximately] an O(1) operation. This excludes (for</div><div>     * example) select and poll, which are approximately O(N) for N</div><div>     * equal to the total number of possible events. */</div><div><font color="#FF0000">    EV_FEATURE_O1 = 0x02,//添加、删除、或者确定哪个事件激活这些动作的时间复杂度都为O(1)，select和poll不满足</font></div><div>    /** Require an event method that allows file descriptors as well as</div><div>     * sockets. */           </div><div>   <font color="#FF0000"> EV_FEATURE_FDS = 0x04, //允许是文描述符  </font></div><div>    /** Require an event method that allows you to use EV_CLOSED to detect</div><div>     * connection close without the necessity of reading all the pending data.</div><div>     *</div><div>     * Methods that do support EV_CLOSED may not be able to provide support on</div><div>     * all kernel versions.  </div><div>     **/</div><div><font color="#FF0000">    EV_FEATURE_EARLY_CLOSE = 0x08//需要允许使用EV_CLOSED检测的事件方法，连接关闭，无需读取所有挂起的数据。</font></div><div>};</div></div><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">函数</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">event_config_require_features对其进行设置</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int</div><div>event_config_require_features(struct event_config *cfg,</div><div>    int features)</div><div>{</div><div>    if (!cfg)</div><div>        return (-1);</div><div>    cfg-&gt;require_features = features;</div><div>    return (0);</div><div>}</div></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 11pt;"><span style="font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">从函数的实现可以看到，如果要设置多个特征，不能调用该函数多次，而应该使用位操作。比如: EV_FEATURE_O1 | EV_FEATURE_FDS作为参数。</span></font></span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">并不是对于任意的后端，任意的标志的或操作都有效，如使用select作为后端时，标志</span><span style="font-size: 11pt; font-weight: bold;">EV_FEATURE_ET是不能使用的，此时</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">event_base_new_with_config函数会返回NULL。</span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 11pt;"><span style="font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">查看后端可使用的标志会在后面介绍。</span></font></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-weight: bold;">最后一个变量，设置event_base的一些属性：</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word;"><span style="font-size: 11pt; font-weight: bold;">EVENT_BASE_FLAG_NOLOCK</span><span style="font-size: 11pt;">：不要为event_base分配锁。设置这个选项可以为event_base节省一点加锁和解锁的时间，但是当多个线程访问event_base会变得不安全。</span></span></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">EVENT_BASE_FLAG_IGNORE_ENV</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal;">：选择多路IO复用函数时，不检测EVENT_*环境变量。使用这个标志要考虑清楚：因为这会使得用户更难调试程序与Libevent之间的交互</span></span></div><div><br/></div><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-weight: bold;">EVENT_BASE_FLAG_STARTUP_IOCP</span><span style="font-size: 11pt; color: rgb(51, 51, 51);">：仅用于Windows。这使得Libevent在启动时就启用任何必需的IOCP分发逻辑，而不是按需启用。如果设置了这个宏，那么evconn_listener_new和bufferevent_socket_new函数的内部将使用IOCP</span></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">EVENT_BASE_FLAG_NO_CACHE_TIME</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal;">：在执行event_base_loop的时候没有cache时间。该函数的while循环会经常取系统时间，如果cache时间，那么就取cache的。如果没有的话，就只能通过系统提供的函数来获取系统时间。这将更耗时</span></span></div><div><br/></div><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-weight: bold;">EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST</span><span style="font-size: 11pt; color: rgb(51, 51, 51);">：告知Libevent，如果决定使用epoll这个多路IO复用函数，可以安全地使用更快的基于changelist 的多路IO复用函数：epoll-changelist多路IO复用可以在多路IO复用函数调用之间，同样的fd 多次修改其状态的情况下，避免不必要的系统调用。但是如果传递任何使用dup()或者其变体克隆的fd给Libevent，epoll-changelist多路IO复用函数会触发一个内核bug，导致不正确的结果。在不使用epoll这个多路IO复用函数的情况下，这个标志是没有效果的。也可以通过设置EVENT_EPOLL_USE_CHANGELIST 环境变量来打开epoll-changelist选项</span></div><div><br/></div><div><span style="font-weight: bold;">函数event_config_set_flag对其进行设置，同样位或运算支持多个标志</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int event_config_set_flag(struct event_config *cfg, int flag)</div><div>{</div><div>    if (!cfg)</div><div>        return -1;</div><div>    cfg-&gt;flags |= flag;</div><div>    return 0;</div><div>}</div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-weight: bold;">libevent——event_base实现跨平台的多路IO复用接口。</span></div><div><br/></div><div><span style="font-weight: bold;">libevent包括了各平台（Windows，Linux等）的IO多路复用的实现，并可通过配置event_base来指定不使用特定后端，来达到使用某后端的目的。具体过程如下：</span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">先看到结构体event_base（只列出此处重要的部分）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event_base {</div><div>    /** Function pointers and other data to describe this event_base's</div><div>     * backend. */</div><div>    const struct eventop *evsel;</div><div>    /** Pointer to backend-specific data. */</div><div>    void *evbase;</div></div><div><br/></div><div><span style="font-weight: bold;">结构体eventop:</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct eventop {</div><div>  </div><div>    const char *name;//后端名字</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    void *(*init)(struct event_base *);</div><div>/*函数设置event_base以使用此后端。它应该创建一个包含所需信息的新结构运行后端并返回它。返回的指针将得到由event_init存储到event_base.evbase字段。失败,这个函数应该返回NULL。*/</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);</div><div>/*在给定的fd或信号上启用读/写功能。“event”是我们要启用的事件:一个或多个EV_READ，EV_WRITE、EV_SIGNAL和EV_ET。“old”将是那些事件在此fd之前已启用。“fdinfo”将是一个通过evmap与fd关联的结构;它的大小在fdinfo字段里面决定。它将被设置为0的第一次fd时被添加。函数成功时返回0，错误时返回-1。*/</div><div><br/></div><div>    int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);</div><div>/*与add相反*/</div><div>    int (*dispatch)(struct event_base *, struct timeval *);</div><div>/*函数来实现事件循环的核心。它必须看哪一个添加的事件已经准备好，并将为每个事件调用event_active活动事件(通常通过event_io_active或类似的事件)。它应该成功返回0，错误返回-1。*/</div><div>    void (*dealloc)(struct event_base *);</div><div>/*清理和释放event_base中的数据/</div><div>    int need_reinit;</div><div>/*标志:如果我们需要在fork之后重新初始化event_base，则设置。*/</div><div>    enum event_method_feature features;</div><div>/*这个后端可以支持的event_method_features的位数组*/</div><div>    size_t fdinfo_len;</div><div>/*为每个fd记录额外信息的长度具有一个或多个活动事件。这些信息被记录下来作为每个fd的evmap条目的一部分，并作为参数传递到上面的add和del函数。*/</div><div>};</div></div><div><br/></div><div><span style="font-weight: bold;">看这个结构体应该可以看出来，这里面有后端的名字，还有多个函数指针，而且是比较大众的函数指针，所以猜测这个结构体，就是后端的一个抽象，并且每个后端应该都会实现这个结构体的各个函数。</span></div><div><span style="font-weight: bold;">而event_base中第一个成员就是指向特定后端的指针。</span></div><div><br/></div><div><span style="font-weight: bold;">在libevent中，每个后端都有对应的实现文件，我们以select为例：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">...</span></div><div>struct selectop {</div><div>    int event_fds;      /* Highest fd in fd set */</div><div>    int event_fdsz;</div><div>    int resize_out_sets;</div><div>    fd_set *event_readset_in;</div><div>    fd_set *event_writeset_in;</div><div>    fd_set *event_readset_out;</div><div>    fd_set *event_writeset_out;</div><div>};</div><div><br/></div><div><br/></div><div>static void *select_init(struct event_base *);</div><div>static int select_add(struct event_base *, int, short old, short events, void*);</div><div>static int select_del(struct event_base *, int, short old, short events, void*);</div><div>static int select_dispatch(struct event_base *, struct timeval *);</div><div>static void select_dealloc(struct event_base *);</div><div><br/></div><div><br/></div><div>const struct eventop selectops = {</div><div>    &quot;select&quot;,</div><div>    select_init,</div><div>    select_add,</div><div>    select_del,</div><div>    select_dispatch,</div><div>    select_dealloc,</div><div>    0, /* doesn't need reinit. */</div><div>    EV_FEATURE_FDS,</div><div>    0,</div><div>};</div><div>...</div></div><div><br/></div><div><span style="font-weight: bold;">可以看到，select.c文件中实现了结构体eventop,并且可以看到，select支持的特征只有</span><span style="font-weight: bold;">EV_FEATURE_FDS。</span></div><div><br/></div><div><span style="font-weight: bold;">也可以查看其他后端文件，每个后端文件都会实现自己的eventop结构体。</span></div><div><br/></div><div><span style="font-weight: bold;">现在只要解决event_base如何选择自己的eventop结构体就行了。</span></div><div><br/></div><div><span style="font-weight: bold;">很明显，并不是所有系统都支持所有的后端，如Linux，就只支持select，poll，epoll而不支持kqueue，所以，对于不同的操作系统，所支持的后端是不一样的。libevent的event-config.h文件会指定libevent所在的环境，从而指定能使用的后端。</span></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#ifdef EVENT__HAVE_EVENT_PORTS</div><div>extern const struct eventop evportops;</div><div>#endif</div><div>#ifdef EVENT__HAVE_SELECT</div><div>extern const struct eventop selectops;</div><div>#endif</div><div>#ifdef EVENT__HAVE_POLL</div><div>extern const struct eventop pollops;</div><div>#endif</div><div>#ifdef EVENT__HAVE_EPOLL</div><div>extern const struct eventop epollops;</div><div>#endif</div><div>#ifdef EVENT__HAVE_WORKING_KQUEUE</div><div>extern const struct eventop kqops;</div><div>#endif</div><div>#ifdef EVENT__HAVE_DEVPOLL</div><div>extern const struct eventop devpollops;</div><div>#endif</div><div>#ifdef _WIN32</div><div>extern const struct eventop win32ops;</div><div>#endif</div><div><br/></div><div><br/></div><div>/* Array of backends in order of preference. */</div><div>static const struct eventop *eventops[] = {</div><div>#ifdef EVENT__HAVE_EVENT_PORTS</div><div>    &amp;evportops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_WORKING_KQUEUE</div><div>    &amp;kqops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_EPOLL</div><div>    &amp;epollops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_DEVPOLL</div><div>    &amp;devpollops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_POLL</div><div>    &amp;pollops,</div><div>#endif</div><div>#ifdef EVENT__HAVE_SELECT</div><div>    &amp;selectops,</div><div>#endif</div><div>#ifdef _WIN32</div><div>    &amp;win32ops,</div><div>#endif</div><div>    NULL</div><div>};</div></div><div><span style="font-weight: bold;">libevent通过宏指定可使用的后端，并将可使用的后端添加到全局数组eventops中，以Linux为例，event-config.h文件只会定义</span><span style="font-weight: bold;">EVENT__HAVE_EPOLL，</span><span style="font-weight: bold;">EVENT__HAVE_POLL和</span><span style="font-weight: bold;">EVENT__HAVE_SELECT宏。</span></div><div><br/></div><div><span style="font-weight: bold;">所以最后全局数组eventops中只会有这三个后端。值得注意的是，Linux下IO多路复用效率最高的就是epoll,其次是poll，select，而此处也是按照这个顺序将其添加到数组中，也就是说，如果我们不去指定后端，默认就会使用效率最高的那个。</span></div><div><br/></div><div><span style="font-weight: bold;">libevent选取多路复用的函数：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct event_base *</div><div>event_base_new_with_config(const struct event_config *cfg)</div><div>{</div><div>    int i;</div><div>    struct event_base *base;</div><div>    int should_check_environment;</div><div><br/></div><div><br/></div><div>#ifndef EVENT__DISABLE_DEBUG_MODE</div><div>    event_debug_mode_too_late = 1;</div><div>#endif</div><div><br/></div><div><br/></div><div>   <font color="#FF0000"> if ((base = mm_calloc(1, sizeof(struct event_base))) == NULL) {//为event_base分配内存</font></div><div>        event_warn(&quot;%s: calloc&quot;, __func__);</div><div>        return NULL;</div><div>    }</div><div><br/></div><div><br/></div><div>    if (cfg)</div><div>        <font color="#FF0000">base-&gt;flags = cfg-&gt;flags;//标志设置，可在之前调用函数event_config_set_flag指定</font></div><div><br/></div><div><br/></div><div>    should_check_environment =</div><div>        !(cfg &amp;&amp; (cfg-&gt;flags &amp; EVENT_BASE_FLAG_IGNORE_ENV));</div><div><br/></div><div><br/></div><div><font color="#A8A8A8">    {</font></div><div><font color="#A8A8A8">        struct timeval tmp;</font></div><div><font color="#A8A8A8">        int precise_time =</font></div><div><font color="#A8A8A8">            cfg &amp;&amp; (cfg-&gt;flags &amp; EVENT_BASE_FLAG_PRECISE_TIMER);</font></div><div><font color="#A8A8A8">        int flags;</font></div><div><font color="#A8A8A8">        if (should_check_environment &amp;&amp; !precise_time) {</font></div><div><font color="#A8A8A8">            precise_time = evutil_getenv_(&quot;EVENT_PRECISE_TIMER&quot;) != NULL;</font></div><div><font color="#A8A8A8">            if (precise_time) {</font></div><div><font color="#A8A8A8">                base-&gt;flags |= EVENT_BASE_FLAG_PRECISE_TIMER;</font></div><div><font color="#A8A8A8">            }</font></div><div><font color="#A8A8A8">        }</font></div><div><font color="#A8A8A8">        flags = precise_time ? EV_MONOT_PRECISE : 0;</font></div><div><font color="#A8A8A8">        evutil_configure_monotonic_time_(&amp;base-&gt;monotonic_timer, flags);</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">        gettime(base, &amp;tmp);</font></div><div><font color="#A8A8A8">    }</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">    min_heap_ctor_(&amp;base-&gt;timeheap);</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">    base-&gt;sig.ev_signal_pair[0] = -1;</font></div><div><font color="#A8A8A8">    base-&gt;sig.ev_signal_pair[1] = -1;</font></div><div><font color="#A8A8A8">    base-&gt;th_notify_fd[0] = -1;</font></div><div><font color="#A8A8A8">    base-&gt;th_notify_fd[1] = -1;</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">  </font><font color="#000000">  TAILQ_INIT(&amp;base-&gt;active_later_queue);</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">    </font><font color="#FF0000">evmap_io_initmap_(&amp;base-&gt;io);</font></div><div><font color="#A8A8A8">/*void</font></div><div><font color="#A8A8A8">evmap_io_initmap_(struct event_io_map* ctx)</font></div><div><font color="#A8A8A8">{</font></div><div><font color="#A8A8A8">    evmap_signal_initmap_(ctx);</font></div><div><font color="#A8A8A8">}</font></div><div><font color="#A8A8A8">void</font></div><div><font color="#A8A8A8">evmap_signal_initmap_(struct event_signal_map *ctx)</font></div><div><font color="#A8A8A8">{</font></div><div><font color="#A8A8A8">    ctx-&gt;nentries = 0;</font></div><div><font color="#A8A8A8">    ctx-&gt;entries = NULL;</font></div><div><font color="#A8A8A8">}*/</font></div><div><font color="#A8A8A8">    </font><font color="#FF0000">evmap_signal_initmap_(&amp;base-&gt;sigmap);</font></div><div><font color="#FF0000"><br/></font></div><div><font color="#A8A8A8">    event_changelist_init_(&amp;base-&gt;changelist);</font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8"><br/></font></div><div><font color="#A8A8A8">    base-&gt;evbase = NULL;</font></div><div><font color="#A8A8A8">   if (cfg) {</font></div><div><font color="#A8A8A8">        memcpy(&amp;base-&gt;max_dispatch_time,</font></div><div><font color="#A8A8A8">            &amp;cfg-&gt;max_dispatch_interval, sizeof(struct timeval));</font></div><div><font color="#A8A8A8">        base-&gt;limit_callbacks_after_prio =</font></div><div><font color="#A8A8A8">            cfg-&gt;limit_callbacks_after_prio;</font></div><div><font color="#A8A8A8">    } else {</font></div><div><font color="#A8A8A8">        base-&gt;max_dispatch_time.tv_sec = -1;</font></div><div><font color="#A8A8A8">        base-&gt;limit_callbacks_after_prio = 1;</font></div><div><font color="#A8A8A8">    }</font></div><div><font color="#A8A8A8">    if (cfg &amp;&amp; cfg-&gt;max_dispatch_callbacks &gt;= 0) {</font></div><div><font color="#A8A8A8">        base-&gt;max_dispatch_callbacks = cfg-&gt;max_dispatch_callbacks;</font></div><div><font color="#A8A8A8">    } else {</font></div><div><font color="#A8A8A8">        base-&gt;max_dispatch_callbacks = INT_MAX;</font></div><div><font color="#A8A8A8">    }</font></div><div><font color="#A8A8A8">    if (base-&gt;max_dispatch_callbacks == INT_MAX &amp;&amp;</font></div><div><font color="#A8A8A8">        base-&gt;max_dispatch_time.tv_sec == -1)</font></div><div><font color="#A8A8A8">        base-&gt;limit_callbacks_after_prio = INT_MAX;</font></div><div><br/></div><div><br/></div><div>    <font color="#FF0000">for (i = 0; eventops[i] &amp;&amp; !base-&gt;evbase; i++) {//遍历后端数组</font></div><div>        <font color="#FF0000">if (cfg != NULL) {//如果event_config不为空，</font></div><div>            /* determine if this backend should be avoided */</div><div>            <font color="#FF0000">if (event_config_is_avoided_method(cfg,</font></div><div><font color="#FF0000">                eventops[i]-&gt;name))</font></div><div><font color="#FF0000">                continue;//如果设置不使用此后端就跳过（该函数会遍历不使用后端的队列）</font></div><div>           <font color="#FF0000"> if ((eventops[i]-&gt;features &amp; cfg-&gt;require_features)</font></div><div><font color="#FF0000">                != cfg-&gt;require_features)</font></div><div><font color="#FF0000">                continue;//如果设置的后端的标志不与此后端标志匹配，则跳过</font></div><div>        }</div><div><br/></div><div><br/></div><div>        /* also obey the environment variables */</div><div>        if (should_check_environment &amp;&amp;</div><div>            event_is_method_disabled(eventops[i]-&gt;name))</div><div>            continue;</div><div><br/></div><div><br/></div><div>      <font color="#FF0000">  base-&gt;evsel = eventops[i];//最后找到一个</font></div><div><br/></div><div><br/></div><div>       <font color="#FF0000"> base-&gt;evbase = base-&gt;evsel-&gt;init(base);//调用对应的后端初始化函数</font></div><div>    }</div><div><br/></div><div><br/></div><div>    if (base-&gt;evbase == NULL) {</div><div>        event_warnx(&quot;%s: no event mechanism available&quot;,</div><div>            __func__);</div><div>        base-&gt;evsel = NULL;</div><div>        event_base_free(base);</div><div>        return NULL;</div><div>    }</div><div><br/></div><div><br/></div><div>    if (evutil_getenv_(&quot;EVENT_SHOW_METHOD&quot;))</div><div>        event_msgx(&quot;libevent using: %s&quot;, base-&gt;evsel-&gt;name);</div><div><br/></div><div><br/></div><div>    /* allocate a single active event queue */</div><div>    if (event_base_priority_init(base, 1) &lt; 0) {</div><div>        event_base_free(base);</div><div>        return NULL;</div><div>    }</div><div><br/></div><div><br/></div><div>    /* prepare for threading */</div><div><br/></div><div><br/></div><div>#if !defined(EVENT__DISABLE_THREAD_SUPPORT) &amp;&amp; !defined(EVENT__DISABLE_DEBUG_MODE)</div><div>    event_debug_created_threadable_ctx_ = 1;</div><div>#endif</div><div><br/></div><div><br/></div><div>#ifndef EVENT__DISABLE_THREAD_SUPPORT</div><div>    if (EVTHREAD_LOCKING_ENABLED() &amp;&amp;</div><div>        (!cfg || !(cfg-&gt;flags &amp; EVENT_BASE_FLAG_NOLOCK))) {</div><div>        int r;</div><div>        EVTHREAD_ALLOC_LOCK(base-&gt;th_base_lock, 0);</div><div>        EVTHREAD_ALLOC_COND(base-&gt;current_event_cond);</div><div>        r = evthread_make_base_notifiable(base);</div><div>        if (r&lt;0) {</div><div>            event_warnx(&quot;%s: Unable to make base notifiable.&quot;, __func__);</div><div>            event_base_free(base);</div><div>            return NULL;</div><div>        }</div><div>    }</div><div>#endif</div><div><br/></div><div><br/></div><div>#ifdef _WIN32</div><div>    if (cfg &amp;&amp; (cfg-&gt;flags &amp; EVENT_BASE_FLAG_STARTUP_IOCP))</div><div>        event_base_start_iocp_(base, cfg-&gt;n_cpus_hint);</div><div>#endif</div><div><br/></div><div><br/></div><div>    return (base);</div><div>}</div></div><div><br/></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">后端存储数据的结构体：</span></font></div><div><br/></div><div><font style="font-size: 11pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">在本文最前面列出的event_base结构体中，除了evsel变量外，还有一个evbase变量。这也是一个很重要的变量，而且也是用于跨平台的。</span></font></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 11pt;"><span style="font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">像select、poll、epoll之类多路IO复用函数在调用时要传入一些数据，比如监听的文件描述符fd，监听的事件有哪些。在Libevent中，这些数据都不是保存在event_base这个结构体中的，而是存放在evbase这个指针指向的一个结构体中。</span></font></span></div><div><br/></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 11pt;"><span style="font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">在每个后端文件中，除了结构体eventop的定义，还会有一个包含自己后端名的结构体：</span></font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">struct pollop {</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int event_count;        /* Highest number alloc */</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int nfds;           /* Highest number used */</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int realloc_copy;       /* True iff we must realloc</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">                     * event_set_copy */</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    struct pollfd *event_set;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    struct pollfd *event_set_copy;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">};</font></span></div><div><font style="font-size: 9pt;"><br/></font></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">struct selectop {</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int event_fds;      /* Highest fd in fd set */</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int event_fdsz;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int resize_out_sets;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    fd_set *event_readset_in;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    fd_set *event_writeset_in;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    fd_set *event_readset_out;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    fd_set *event_writeset_out;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">};</font></span></div><div><font style="font-size: 9pt;"><br/></font></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">struct epollop {</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    struct epoll_event *events;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int nevents;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int epfd;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">#ifdef USING_TIMERFD</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">    int timerfd;</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">#endif</font></span></div><div><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 9pt;">};</font></span></div></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><font style="font-size: 11pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">在函数</span><span style="font-size: 11pt; font-weight: bold;">event_base_new_with_config初始化的最后，回调用对应后端的init函数：</span></font></div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">如select：</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void *</div><div>select_init(struct event_base *base)</div><div>{</div><div>    struct selectop *sop;</div><div><br/></div><div><br/></div><div>    if (!(sop = mm_calloc(1, sizeof(struct selectop))))</div><div>        return (NULL);</div><div><br/></div><div><br/></div><div>    if (select_resize(sop, SELECT_ALLOC_SIZE(32 + 1))) {</div><div>        select_free_selectop(sop);</div><div>        return (NULL);</div><div>    }</div><div><br/></div><div><br/></div><div>    evsig_init_(base);</div><div><br/></div><div><br/></div><div>    evutil_weakrand_seed_(&amp;base-&gt;weakrand_seed, 0);</div><div><br/></div><div><br/></div><div> <font color="#FF0000">   return (sop);</font></div><div>}</div></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><font style="font-size: 11pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">函数最后返回</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">selectop结构</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">给event_base的成员evbase。</span></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div></div><div><br/></div></span>
</div></body></html> 