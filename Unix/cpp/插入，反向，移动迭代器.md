# 插入，反向，移动迭代器
#### 插入迭代器：
插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。

|                |                                                              |
| -------------- | ------------------------------------------------------------ |
| 插入迭代器操作 | 插入迭代器操作                                               |
| it=t           | 在it指定的当前位置插入值t。假定c是it绑定的容器，依赖于插入迭代器的不同种类，此赋值分别调用c.push_back(t)、c.push_front(t)或c.insert(t,p),其中p为传递给inserter的迭代器位置 |
| *it,++it,it++  | 这些操作虽然存在，但不会对it做任何事情。每个操作都返回it     |

插入迭代器有三种类型，差异在于元素插入的位置：
`back_inserter`创建一个使用`push_back`的迭代器
`front_inserter`创建一个使用`push_front`的迭代器
`inserter`创建一个使用`insert`的迭代器。此函数接受三个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。

只有在容器支持`push_front`的情况下，我们才可以使用`front_inserter`。类似的，只有在容器支持`push_back`的情况下，我们才能使用`back_inserter`
当调用`inserter(c,iter)`时，我们得到一个迭代器，接下来使用它时，会将元素插入到`iter`原来所指的位置之前的位置。即，如果`it`是由`inserter`生成的迭代器，则下面这样的赋值语句:
`*it = val;`等价于
`it = c.insert(it, val); //it指向新加入的元素
++it;//指针后移指向原来的元素`

`front_inserter`生成的迭代器的行为与`inserter`生成的迭代器完全不一样。当我们使用`front_inserter`时，元素总是插入到容器第一个元素之前，即使我们传递给`inserter`的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：
```cpp
#include <iostream>
#include <iterator>
#include <algorithm>
#include <list>
int main()
{
    using namespace std;
    list<int> vt{1,2,3,4,5,6,7,8,9};
    list<int> vt2{10}, vt3{10}, vt4{10};
    copy(vt.begin(), vt.end(), back_inserter(vt2));
    for(auto x : vt2)
        cout << x << " ";
    cout << endl;
    copy(vt.begin(), vt.end(), front_inserter(vt3));
    for(auto x : vt3)
        cout << x << " ";
    cout << endl;
    copy(vt.begin(), vt.end(), inserter(vt4, vt4.begin()));
    for(auto x : vt4)
        cout << x << " ";
    cout << endl;
}
```
`
[Sun Sep 26 14:42:42~/test/cpp_learn/iterator]$ g++ test5.cpp
[Sun Sep 26 14:42:45~/test/cpp_learn/iterator]$ ./a.out
10 1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1 10
1 2 3 4 5 6 7 8 9 10
`
当调用`front_inserter(c)`时，我们得到一个插入迭代器，接下来会调用`push_front`.当每个元素被插入到容器`c`中时，它变为`c`的新的首元素。因此，`front_inserter`生成的迭代器会将插入的元素序列的顺序颠倒过来，而`inserter`和`back_inserter`则不会。


#### 反向迭代器：

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一迭代器（--it）会移动到下一个元素。

除了forward_list之外，其他容器都支持反向迭代器。我们可以通过调用rbegin、rcend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有const和非const版本。
```cpp
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
int main()
{
    using namespace std;
    vector<int> vt{2,1,3,8,5,10,7,9};
    for(auto x = vt.crbegin(); x != vt.crend(); x++)
        cout << *x << " ";
    cout << endl;
    sort(vt.begin(), vt.end());
    for(auto x : vt)
        cout << x << " ";
    cout << endl;
    sort(vt.rbegin(), vt.rend());
    for(auto x : vt)
        cout << x << " ";
    cout << endl;
}
```
`
[Sun Sep 26 14:53:08~/test/cpp_learn/iterator]$ g++ test6.cpp
[Sun Sep 26 14:53:17~/test/cpp_learn/iterator]$ ./a.out
9 7 10 5 8 3 1 2
1 2 3 5 7 8 9 10
10 9 8 7 5 3 2 1
`

#### 移动迭代器：